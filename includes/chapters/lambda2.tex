\section{System F}\label{sec:system_f}
System \(\lambda  2\) wprowadzony został przez J.-Y.  Girarda jako System
F i w literaturze szerzej znany jest pod tą nazwą. 

\subsection{Typy polimorficzne}

\begin{definicja}(Typy \(\mathbb{T}2\))
  Niech \(\mathbb{V}\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych. Zmienne te będziemy nazywali \emph{zmiennymi typowymi} i oznaczali literami alfabetu greckiego (\(\alpha, \beta, \gamma, \dots\)). Zbiór typów \(\mathbb{T}2\) systemu \(\lambda 2\) okreslamy w notacji BNF następującym zapisem:
  \begin{align*}
    \mathbb{T2}\ &\leftarrow\ \mathbb{V}\ |\ (\mathbb{T2}\to\mathbb{T2})\ |\ (\Pi \mathbb{V}:*.\,\mathbb{T2})
  \end{align*}
\end{definicja}
\begin{definicja}(Pretermy \(\mathbf{\tilde\Lambda}_\mathbb{T2}\))
  Niech \(V\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych. Zmienne te będziemy nazywali \emph{zmiennymi termowymi} i oznaczali literami alfabetu łacińskiego (\(x,\, y,\, z,\,\dots\)). Zbiór pretermów \(\mathbf{\tilde\Lambda}_\mathbb{T2}\) systemu \(\lambda 2\) okreslamy w notacji BNF następującym zapisem:
  \begin{align*}
      \mathbf{\tilde\Lambda}_\mathbb{T2}\ &\leftarrow \ V\ |\ (\mathbf{\tilde\Lambda}_\mathbb{T2}\,\mathbf{\tilde\Lambda}_\mathbb{T2}) \ |\ (\mathbf{\tilde\Lambda}_\mathbb{T2}\,\mathbb{T2}) \ |\ (\lambda V:\mathbb{T2}.\, \mathbf{\tilde\Lambda}_\mathbb{T2})\ |\ (\lambda V:*.\, \mathbf{\tilde\Lambda}_\mathbb{T2})
  \end{align*}
  Wyrażenia postaci \((\lambda V:*.\, \mathbf{\tilde\Lambda}_\mathbb{T2})\) i \((\mathbf{\tilde\Lambda}_\mathbb{T2}\,\mathbb{T2})\) nazywamy \emph{polimorficzną abstrakcją} i \emph{polimorficzną aplikacją}, odpowiednio. O zmiennej (termowej lub typowej) występującej bezpośrednio po znaku \(\lambda\) powiemy, że jest związana.  
\end{definicja}

\begin{uwaga*}
  Zakładamy, że \(V\cap\mathbb{V}=\emptyset\).
\end{uwaga*}
Wyrażenia \(\lambda\) (\(\lambda\)-termy) w systemie \(\lambda 2\) to klasy abstrakcji \(\alpha\)-konwersji. Konstrukcja jest analogiczna do zaprezentowanej w Rozdziale \ref{subsec:lambda_terms_untyped}, ale aby nie wchodzić w szczegóły, ustalmy, że utożsamiać będziemy wyrażenia, które różnią się między sobią wyłącznie zmiennymi związanymi. 

\begin{konwencja*}
Stosujemy standardowe konwencje notacyjne
\begin{easylist}
  & Opuszczamy najbardziej zewnętrzne nawiasy,
  & Aplikacja wiąże prawostronnie,
  & Aplikacja i \(\to\) wiążą mocniej niż \(\lambda-\) i \(\Pi\)-abstrakcja,
  & Kolejne \(\lambda\)- i \(\Pi\)-abstrakcje zmiennych tych samych typów mogą występować pod wspónym znakiem i wiążą prawostronnie,
  & Konstruktor typu \(\to\) wiaże prawostronnie.
\end{easylist}
  Przykładowo: \(\Pi\alpha\,\beta:*.\,\alpha\to\beta\to\alpha\ \equiv\ \Pi\alpha:*.(\Pi\beta:*.\,(\alpha\to(\beta\to\alpha))))\).
\end{konwencja*}

  \begin{definicja}(Zbiór \(\mathrm{FV}\) zmiennych wolnych)
    Przez \(\mathrm{FV}(M)\) oznaczamy zbiór wszystkich wolnych zmiennych termowych i typowych wystepujących w \(M\in\mathbf{\Lambda}_{\mathtt{T}2}\).
    \begin{align*}
      \mathrm{FV}(x) &= {x}\\
      \mathrm{FV}(\lambda x:\sigma.\,M) &= \mathrm{FV}(\sigma)\cup(\mathrm{FV}(M)\setminus \{x\})\\
      \mathrm{FV}(MN) &= \mathrm{FV}(M) \cup \mathrm{FV}(N)\\
      \mathrm{FV}(\lambda \alpha : *.\,M) &= \mathrm{FV}(M)\setminus \{\alpha\}\\
      \mathrm{FV}(M\sigma) &= \mathrm{FV}(M)\cup \mathrm{FV}(\sigma)
    \end{align*}
  \end{definicja}

  \begin{definicja}(Podstawienie) Rozszerzamy definicję podstawienia o reguły obejmujące zmienne typowe.
  \begin{align*}
    x[x/P] &= P,\\
    y[x/P] &= y,\\
    (MN)[x/P] &= M[x/P]N[x/P],\\
    (\lambda y:\sigma.\,M)[x/P] &= \lambda y:\sigma.\,M[x/P],\ \text{gdzie}\, y\not\in FV(P)\cup\{x\},\\
    (M\sigma)[x/P] &= M[x/P]\sigma,\\
    (\lambda \beta:*.\,M)[x/P] &= \lambda \beta:*.\,M[x/P],\ \text{gdzie}\ p\not\in\mathrm{FV}(P),\\
    x[\alpha/\sigma]&=x,\\
    (MN)[\alpha/\sigma] &= M[\alpha/\sigma]N[\alpha/\sigma],\\
    (\lambda y:\sigma.\,M)[\alpha/\sigma] &= \lambda y:\sigma.\,M[\alpha/\sigma],\\
    (M\rho)[\alpha/\sigma] &= M\rho[\alpha/\sigma],\\
    (\lambda \beta:*.\,M)[\alpha/\sigma] &= \lambda \beta:*.\,M[\alpha/\sigma],\ \text{gdzie}\ \beta\not\in\mathrm{FV}(\sigma)\cup\{\alpha\}.\\
  \end{align*}
  \end{definicja}

Odpowiednim modyfikacjom ulegają pojęcia wprowadzone w Definicji \ref{def:statement_simple} i Definicji \ref{def:context_simple}.
\begin{definicja}(Stwierdzenie, deklaracja)
    \begin{enumerate}
  \setlength\itemsep{0em}
    \item Stwierdzeniem nazywamy każdy napis postaci \(M:\sigma\), gdzie \(M\in\Lambda_\mathbb{T2}\) i \(\sigma\in \mathbb{T2}\) lub \(\sigma:*\), gdzie \(\sigma\in\mathbb{T2}\).
    \item  Deklaracją nazywamy każde stwierdzenie ze zmienna typowa lub zmienna termowa w miejscu podmiotu.
  \end{enumerate}

\end{definicja}
\begin{definicja}(\(\lambda 2\)-kontekst, dziedzina, zakres)\label{def:f_statement}
  \begin{enumerate}[label=(E\arabic*), ref=(E\arabic*)]
  \setlength\itemsep{0em}
  \item \(\emptyset\) jest \(\lambda 2\)-kontekstem; oznaczamy go parą nawiasów 
    \(()\).\label{def:f_context_1}
  \item Jeśli:\label{def:f_context_2}
    \begin{enumerate}
    \item \(\Gamma\) jest \(\lambda 2\)-kontekstem,    \item \(\alpha\in\mathbb{V}\) jest zmienną typową taką, że \(\alpha\not\in \mathrm{dom}(\Gamma)\),
    \end{enumerate}
    to \(\Gamma, \alpha:*\) jest \(\lambda 2\)-kontekstem, gdzie 
      \begin{align*} 
        \mathrm{dom}(\Gamma, \alpha:*)&=(\mathrm{dom}(\Gamma),\, \alpha),\\
        \mathrm{rg}(\Gamma, \alpha:*)&=\mathrm{rg}(\Gamma)\cup\{*\}.
      \end{align*}
  \item Jeśli:\label{def:f_context_3}
    \begin{enumerate}
     \setlength\itemsep{0em}
     \item \(\Gamma\) jest \(\lambda 2\)-kontekstem,
     \item \(\rho\in\mathbb{T}2\) jest typem takim, że \(\alpha\in\mathrm{dom}(\Gamma)\) dla wszystkich \(\alpha\in\mathrm{FV}(\rho)\),
     \item \(x\in V\) jest zmienną termową taką, że \(x\not\in\mathrm{dom}\,\Gamma\),
    \end{enumerate}
      to \(\Gamma, x:\rho\) jest \(\lambda 2\)-kontekstem, gdzie 
      \begin{align*} 
        \mathrm{dom}(\Gamma, x:\rho)&=(\mathrm{dom}(\Gamma), x),\\
      \mathrm{rg}(\Gamma, \alpha:*)&=\mathrm{rg}(\Gamma)\cup\{\rho\}.
      \end{align*}
      \(\mathrm{dom}(\Gamma)\) i \(\mathrm{rg}(\Gamma)\) nazywamy odpowiednio \emph{dziedziną} i \emph{zakresem} \(\lambda 2\)-kontekstu \(\Gamma\).
  \end{enumerate}
    Jesli \(\Gamma=(a_{11}: a_{12},\,\dots,\,a_{n1}:a_{n2})\) jest \(\lambda 2\)-kontekstem, to przez \(\Gamma[\alpha/\sigma]\) oznaczamy \(\lambda 2\)-kontekst, w którym jesli \(a_{i1}\in V\), to \(a_{i2}\) zamieniamy na \(x_{i2}[\alpha/\sigma]\)  dla \(1\leq i \leq n\).
\end{definicja}

\begin{przyklad}
  \begin{enumerate}[label=(\alph*), ref=(\alph*)]
    \setlength\itemsep{0em}
    \item \(\emptyset\) jest  \(\lambda 2\)-kontekstem na podstawie
      \ref{def:f_context_1}.\label{ex:f_context_a}
    \item \(\alpha:*\)  jest \(\lambda 2\)-kontekstem  na podstawie
\ref{def:f_context_2}.\label{ex:f_context_b}

    \item           \(\alpha:*,\,x:\alpha\to\alpha\)           jest
\(\lambda 2\)-kontekstem      na      podstawie      
\ref{def:f_context_3}.     Zauważmy,     że
deklaracja    \(\alpha:*\)    wysępuje   w    kontekście    przed
\(x:\alpha\to\alpha\).\label{ex:f_context_c}

    \item \(\alpha:*,\,x:\alpha\to\alpha,\,\beta:*\) jest \(\lambda 2\)-kontekstem na podstawie \ref{def:f_context_2}.\label{ex:f_context_d}

    \item \(\Gamma\equiv(\alpha:*,\,x:\alpha\to\alpha,\,\beta:*,\,y:(\alpha\to\alpha)\to\beta)\) jest \(\lambda 2\)-kontekstem na podstawie \ref{def:f_context_3}. Wówczas \(\mathrm{dom}(\Gamma)=(\alpha,\,x,\,\beta,y)\) i \(\mathrm{rg}(\Gamma)=\{*,\,\alpha\to\alpha\, \beta,\,(\alpha\to\alpha)\to\beta\}\).\label{ex:f_context_e}
  \end{enumerate}
\end{przyklad}

  \subsection{Typowanie}
  \begin{definicja}(Kontekst)
  \end{definicja}
  Typowanie: \(\Gamma \vdash M : A\)\\
  \begin{center}
  \begin{tabular}{r c c}

    \vspace{0.5cm}
    (var) &
      \(\Gamma \vdash x:\sigma\), & jeśli \(x:\sigma\in\Gamma\)\\
    \vspace{0.5cm}

    (app) &
    {\begin{prooftree}
      \Hypo{\Gamma \vdash M:\sigma \to \tau} \Hypo{ \Gamma \vdash N:\sigma}
      \Infer2[]{\Gamma \vdash MN:\tau}
    \end{prooftree}} & \\
    \vspace{0.5cm}

    (abs) &
    {\begin{prooftree}
      \Hypo{ \Gamma, x:\sigma \vdash M:\tau }
      \Infer1[]{\Gamma \vdash (\lambda\, x:\sigma.\, M):\sigma\to \tau}
    \end{prooftree}} & \\
    \vspace{0.5cm}

    (form) &
      \(\Gamma\vdash B:*\), & jeśli \(B\in\mathbb{T}2\) i  \(\mathrm{FV}(B)\subseteq \mathrm{rg}\,\Gamma\)\\
    \vspace{0.5cm}

    (\(\Pi\)-e) &
    {\begin{prooftree}
      \Hypo{ \Gamma \vdash M:(\Pi \alpha:*.\,A)}
      \Hypo{ \Gamma \vdash B:* }
      \Infer2[]{\Gamma \vdash M B : A[\alpha/B]}
    \end{prooftree}} &
     \\
    \vspace{0.5cm}

    (\(\Pi\)-i) &
    {\begin{prooftree}
      \Hypo{\Gamma, \alpha : * \vdash M:A } 
      \Infer1[]{\Gamma \vdash \lambda \alpha:*.\,M:\Pi \alpha:*.\,A}
    \end{prooftree}} & \\
  \end{tabular}
  \end{center}

  \begin{definicja}(Poprawność, typowalność)
    Powiemy, że term \(M\in\mathbf{\Lambda}_{\mathbb{T}2}\) jest \emph{poprawny} lub \emph{typowalny}, jeśli istnieje \(\lambda 2\)-kontekst \(\Gamma\) i typ \(\rho\in \mathbb{T}2\) taki, że \(\Gamma\vdash M:\rho\).
  \end{definicja}

\begin{przyklad}
  \begin{equation*}
  \begin{fitch}
    \fh \alpha : * & (form) \\
    \fa \fh f: \alpha \to \alpha & (var) \\
    \fa \fa \fh x : \alpha & (var) \\
    \fa\fa \fa f x : \alpha & (app) 2 3 \\
    \fa \fa \fa f(f x) : \alpha  & (app) 2 1 \\
    \fa \fa \lambda x : \alpha .\, f(fx) : \alpha \to \alpha & (abs) 5 \\
    \fa \lambda f : \alpha \to \alpha .\, \lambda x :\, \alpha .\, f (fx) : (\alpha \to \alpha) \to \alpha \to \alpha &  (abs) 6 \\
  \lambda \alpha : * .\, \lambda f : \alpha \to \alpha .\, \lambda x : \alpha .\, f (f x) : \Pi \alpha : * .\, (\alpha \to \alpha) \to \alpha \to \alpha & (\(\Pi\)-i) 7 \\
  \end{fitch}
  \end{equation*}
\end{przyklad}
  \
  \subsection{Redukcja}

  \begin{definicja}(\(\alpha\)-konwersja)

  \end{definicja}

  \begin{definicja}(\(\beta\)-redukcja)
    \(\beta\)-redukcją nazywamy najmniejszą (w sensie mnogościowym) zgodną na \(\mathbf{\Lambda}_{\mathbb{T}2}\) relację binarną \(\to_\beta\) taką, że
  \begin{align*}
    (\lambda x.\,M)N &\to\beta M[x/N].\\
    (\lambda \alpha:*.\,M) T &\to_\beta M[\alpha/T]
  \end{align*}
  \end{definicja}
  \begin{przyklad}
    \begin{align*}
    \lambda \alpha : *.\,\lambda f:\alpha\to\alpha.\,\lambda x:\alpha.\,f(f x))\,\mathrm{nat\  suc\  two} \to_\beta\\
      \lambda f : \mathrm{nat}\to\mathrm{nat}.\,\lambda x :\mathrm{nat} .\, f\,(f\,x))\, \mathrm{suc\  two} \to_\beta\\
      (\lambda x:\mathrm{nat}.\,\mathrm{suc}\,(\mathrm{suc}\ x))\,\mathrm{two} \to_\beta \\
      \mathrm{suc}\,(\mathrm{suc}\ \mathrm{two}).
    \end{align*}
  \end{przyklad}
\subsection{Własności}
\subsection{System Hindleya-Milnera}
\subsection{Podsumowanie}
Na kanwie zaproponowanej przez H. P. Barendregta w \cite[Rozdział 5]{Barendregt_1992} klasyfikacji rozszerzeń rachunku \(\lambda\) z typami prostymi (tzw. \emph{kostki \(\lambda\)}, Rysunek \ref{fig:lambda-cube}), rozdział ten poświęcimy omówieniu wzajemnych zależności jakie mogą łączyć \(\lambda\)-termy i typy. Zajmować będziemy się wyłącznie systemami w stylu Churcha.

\begin{figure}[!h]
  \centering
  \begin{tikzpicture}
  \matrix (m) [matrix of math nodes,
  row sep=3em, column sep=3em,
  text height=1.5ex,
  text depth=0.25ex]{
              & \lambda\omega             &              & \lambda P \omega             \\
  \lambda 2   &                           & \lambda P 2                                \\
              & \lambda\underline{\omega} &              & \lambda P \underline{\omega} \\
  \lambda{\to}&                           & \lambda P  \\
  };
  \path[-{Latex[length=2.5mm, width=1.5mm]}]
  (m-1-2) edge (m-1-4)
  (m-2-1) edge (m-2-3)
          edge (m-1-2)
  (m-3-2) edge (m-1-2)
          edge (m-3-4)
  (m-4-1) edge (m-2-1)
          edge (m-3-2)
          edge (m-4-3)
  (m-3-4) edge (m-1-4)
  (m-2-3) edge (m-1-4)
  (m-4-3) edge (m-3-4)
          edge (m-2-3);
  \end{tikzpicture}
  \caption{Poszczególne systemy klasyfikacji H. Barendregta; kierunek krawędzi \(\to\)  oznacza relację \(\subseteq\).}\label{fig:lambda-cube}
\end{figure}



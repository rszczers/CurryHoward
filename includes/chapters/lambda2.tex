\section{System F}\label{sec:system_f}
W rozdziale tym przedstawimy rachunek \(\lambda\) drugiego rzędu w stylu Churcha. System ten wprowadzony został przez J.-Y.  Girarda jako System F i w literaturze szerzej znany jest pod tą nazwą. 

\subsection{Wyrażenia \(\lambda\)}

\begin{definicja}(Typy \(\mathbb{T}2\))
  Niech \(\mathbb{V}\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych. Zmienne te będziemy nazywali \emph{zmiennymi typowymi} i oznaczali literami alfabetu greckiego (\(\alpha, \beta, \gamma, \dots\)). Zbiór typów \(\mathbb{T}2\) systemu \(\lambda 2\) okreslamy w notacji BNF następującym zapisem:
  \begin{align*}
    \mathbb{T2}\ &\leftarrow\ \mathbb{V}\ |\ (\mathbb{T2}\to\mathbb{T2})\ |\ (\Pi \mathbb{V}:*.\,\mathbb{T2})
  \end{align*}
\end{definicja}
\begin{definicja}(Pretermy \(\mathbf{\tilde\Lambda}_\mathbb{T2}\))
  Niech \(V\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych. Zmienne te będziemy nazywali \emph{zmiennymi termowymi} i oznaczali literami alfabetu łacińskiego (\(x,\, y,\, z,\,\dots\)). Zbiór pretermów \(\mathbf{\tilde\Lambda}_\mathbb{T2}\) systemu \(\lambda 2\) okreslamy w notacji BNF następującym zapisem:
  \begin{align*}
      \mathbf{\tilde\Lambda}_\mathbb{T2}\ &\leftarrow \ V\ |\ (\mathbf{\tilde\Lambda}_\mathbb{T2}\,\mathbf{\tilde\Lambda}_\mathbb{T2}) \ |\ (\mathbf{\tilde\Lambda}_\mathbb{T2}\,\mathbb{T2}) \ |\ (\lambda V:\mathbb{T2}.\, \mathbf{\tilde\Lambda}_\mathbb{T2})\ |\ (\lambda V:*.\, \mathbf{\tilde\Lambda}_\mathbb{T2})
  \end{align*}
  Wyrażenia postaci \((\lambda V:*.\, \mathbf{\tilde\Lambda}_\mathbb{T2})\) i \((\mathbf{\tilde\Lambda}_\mathbb{T2}\,\mathbb{T2})\) nazywamy \emph{polimorficzną abstrakcją} i \emph{polimorficzną aplikacją}, odpowiednio. O zmiennej (termowej lub typowej) występującej bezpośrednio po znaku \(\lambda\) powiemy, że jest związana.  
\end{definicja}

\begin{uwaga*}
  Zakładamy, że \(V\cap\mathbb{V}=\emptyset\).
\end{uwaga*}

\begin{konwencja*}
Stosujemy standardowe konwencje notacyjne:
\begin{easylist}
  & Opuszczamy najbardziej zewnętrzne nawiasy,
  & Aplikacja wiąże prawostronnie,
  & Aplikacja i \(\to\) wiążą mocniej niż \(\lambda-\) i \(\Pi\)-abstrakcja,
  & Kolejne \(\lambda\)- i \(\Pi\)-abstrakcje zmiennych tych samych typów mogą występować pod wspónym znakiem i wiążą prawostronnie,
  & Konstruktor typu \(\to\) wiaże prawostronnie.
\end{easylist}
  Przykładowo: \(\Pi\alpha\,\beta:*.\,\alpha\to\beta\to\alpha\ \equiv\ \Pi\alpha:*.(\Pi\beta:*.\,(\alpha\to(\beta\to\alpha))))\).
\end{konwencja*}

Wyrażenia \(\lambda\) (\(\lambda\)-termy) w Systemie F to klasy abstrakcji \(\alpha\)-konwersji. Konstrukcja ta jest analogiczna do zaprezentowanej w Rozdziale \ref{subsec:lambda_terms_untyped}. 

%, ale aby nie wchodzić w szczegóły, ustalmy, że utożsamiać będziemy wyrażenia, które różnią się między sobią wyłącznie zmiennymi związanymi. 

  \begin{definicja}(Zbiór \(\mathrm{FV}\) zmiennych wolnych)
    Przez \(\mathrm{FV}(M)\) oznaczamy zbiór wszystkich wolnych zmiennych termowych i typowych wystepujących w \(M\in\mathbf{\Lambda}_{\mathtt{T}2}\).
    \begin{align*}
      \mathrm{FV}(x) &= {x},\\
      \mathrm{FV}(\lambda x:\sigma.\,M) &= \mathrm{FV}(\sigma)\cup(\mathrm{FV}(M)\setminus \{x\}),\\
      \mathrm{FV}(MN) &= \mathrm{FV}(M) \cup \mathrm{FV}(N),\\
      \mathrm{FV}(\lambda \alpha : *.\,M) &= \mathrm{FV}(M)\setminus \{\alpha\},\\
      \mathrm{FV}(M\sigma) &= \mathrm{FV}(M)\cup \mathrm{FV}(\sigma).
    \end{align*}
  \end{definicja}

  \begin{definicja}(Podstawienie) Rozszerzamy definicję podstawienia o reguły obejmujące zmienne typowe.
  \begin{align*}
    x[x/P] &= P,\\
    y[x/P] &= y,\\
    (MN)[x/P] &= M[x/P]N[x/P],\\
    (\lambda y:\sigma.\,M)[x/P] &= \lambda y:\sigma.\,M[x/P],\ \text{gdzie}\, y\not\in FV(P)\cup\{x\},\\
    (M\sigma)[x/P] &= M[x/P]\sigma,\\
    (\lambda \beta:*.\,M)[x/P] &= \lambda \beta:*.\,M[x/P],\ \text{gdzie}\ p\not\in\mathrm{FV}(P),\\
    x[\alpha/\sigma]&=x,\\
    (MN)[\alpha/\sigma] &= M[\alpha/\sigma]N[\alpha/\sigma],\\
    (\lambda y:\sigma.\,M)[\alpha/\sigma] &= \lambda y:\sigma.\,M[\alpha/\sigma],\\
    (M\rho)[\alpha/\sigma] &= M\rho[\alpha/\sigma],\\
    (\lambda \beta:*.\,M)[\alpha/\sigma] &= \lambda \beta:*.\,M[\alpha/\sigma],\ \text{gdzie}\ \beta\not\in\mathrm{FV}(\sigma)\cup\{\alpha\}.\\
  \end{align*}
  \end{definicja}

  \begin{definicja}(\(\alpha\)-konwersja) 
    Relacją \(=_{\alpha}\) (\(\alpha\)-konwersji) nazywamy najmniejszą w sensie mnogościowym zgodną relację równowazności na \(\mathbf{\tilde\Lambda}_{\mathbb{T}2}\) taką, że
    \begin{enumerate}[label=(\(\alpha\)\arabic*), ref=(\(\alpha\)\arabic*)]
      \setlength\itemsep{0em}
      \item \(\lambda x:\sigma.\,M =_\alpha \lambda y:\sigma.\,M[x/y]\), jeśli \(M[x/y]\) jest określone i \(y\not\in \mathrm{FV}(M)\).
      \item \(\lambda \alpha:*.\,M =_\alpha \lambda \beta:*.\,M[\alpha/\beta]\), jeśli \(\beta\) nie występuje w \(M\).
      \item \(\Pi \alpha:*.\,M =_\alpha \Pi \beta:*.\,M[\alpha/\beta]\), jeśli \(\beta\) nie występuje w \(M\).
    \end{enumerate}
  \end{definicja}

\begin{przyklad} Rozważmy następujące przykłady \(\alpha\)-konwertów:
  \begin{align*}
    \text{a)}\quad &\lambda \alpha:*.\,\lambda x:\alpha.\,x=_\alpha 
              & \text{b)} \quad& \Pi \alpha:*.\,\alpha\to\alpha =_\alpha\\
    &\lambda \beta:*.\,\lambda x:\beta.\, x=_\alpha 
              & &\Pi\beta:*.\,\beta\to\beta  =_\alpha\\ 
    &\lambda \beta:*.\,\lambda y:\beta.\, y. 
              & &\Pi\beta:*.\,\beta\to\beta.
  \end{align*}
\end{przyklad}

Odpowiednim modyfikacjom ulegają również pojęcia wprowadzone w Definicji \ref{def:statement_simple} i Definicji \ref{def:context_simple}.
\begin{definicja}(Stwierdzenie, deklaracja)
    \begin{enumerate}
  \setlength\itemsep{0em}
    \item Stwierdzeniem nazywamy każdy napis postaci \(M:\sigma\), gdzie \(M\in\Lambda_\mathbb{T2}\) i \(\sigma\in \mathbb{T2}\) lub \(\sigma:*\), gdzie \(\sigma\in\mathbb{T2}\).
    \item  Deklaracją nazywamy każde stwierdzenie ze zmienną typową lub zmienną termową w miejscu podmiotu.
  \end{enumerate}

\end{definicja}
\begin{definicja}(\(\lambda 2\)-kontekst, dziedzina, zakres)\label{def:f_statement}
  \begin{enumerate}[label=(E\arabic*), ref=(E\arabic*)]
  \setlength\itemsep{0em}
  \item \(\emptyset\) jest \(\lambda 2\)-kontekstem; oznaczamy go parą nawiasów
    \(()\)  lub pomijamy, jeśli nie prowadzi to do niejednoznaczności.\label{def:f_context_1}
  \item Jeśli:\label{def:f_context_2}
    \begin{enumerate}
    \item \(\Gamma\) jest \(\lambda 2\)-kontekstem,    \item \(\alpha\in\mathbb{V}\) jest zmienną typową taką, że \(\alpha\not\in \mathrm{dom}(\Gamma)\),
    \end{enumerate}
    to \(\Gamma, \alpha:*\) jest \(\lambda 2\)-kontekstem, gdzie 
      \begin{align*} 
        \mathrm{dom}(\Gamma, \alpha:*)&=(\mathrm{dom}(\Gamma),\, \alpha),\\
        \mathrm{rg}(\Gamma, \alpha:*)&=\mathrm{rg}(\Gamma)\cup\{*\}.
      \end{align*}
  \item Jeśli:\label{def:f_context_3}
    \begin{enumerate}
     \setlength\itemsep{0em}
     \item \(\Gamma\) jest \(\lambda 2\)-kontekstem,
     \item \(\rho\in\mathbb{T}2\) jest typem takim, że \(\alpha\in\mathrm{dom}(\Gamma)\) dla wszystkich \(\alpha\in\mathrm{FV}(\rho)\),
     \item \(x\in V\) jest zmienną termową taką, że \(x\not\in\mathrm{dom}\,\Gamma\),
    \end{enumerate}
      to \(\Gamma, x:\rho\) jest \(\lambda 2\)-kontekstem, gdzie 
      \begin{align*} 
        \mathrm{dom}(\Gamma, x:\rho)&=(\mathrm{dom}(\Gamma), x),\\
      \mathrm{rg}(\Gamma, \alpha:*)&=\mathrm{rg}(\Gamma)\cup\{\rho\}.
      \end{align*}
      \(\mathrm{dom}(\Gamma)\) i \(\mathrm{rg}(\Gamma)\) nazywamy odpowiednio \emph{dziedziną} i \emph{zakresem} \(\lambda 2\)-kontekstu \(\Gamma\).
  \end{enumerate}
    Jesli \(\Gamma=(a_{11}: a_{12},\,\dots,\,a_{n1}:a_{n2})\) jest \(\lambda 2\)-kontekstem, to przez \(\Gamma[\alpha/\sigma]\) oznaczamy \(\lambda 2\)-kontekst, w którym jesli \(a_{i1}\in V\), to \(a_{i2}\) zamieniamy na \(x_{i2}[\alpha/\sigma]\)  dla \(1\leq i \leq n\).
\end{definicja}

 \begin{uwaga*}
   Zauważmy, że przy powyższych rozstrzygnięciach definicyjnych nie zachodzi odpowiednik Twierdzenia \ref{thm:permutation_simple} \ref{thm:permutation_3}: nie możemy rozpatrywać dowolnych permutacji kontekstów w sądach \(\Gamma\vdash M:T\), ponieważ w myśl Definicji \ref{def:f_statement} deklaracje zmiennych termowych w poprawnie zbudowanych \(\lambda 2\)-kontekstach są uzależnione od poprzedzających je deklaracji typowych.
 \end{uwaga*}

\begin{przyklad}
  \begin{enumerate}[label=(\alph*), ref=(\alph*)]
    \setlength\itemsep{0em}
    \item \(\emptyset\) jest  \(\lambda 2\)-kontekstem na podstawie
      \ref{def:f_context_1}.\label{ex:f_context_a}
    \item \(\alpha:*\)  jest \(\lambda 2\)-kontekstem  na podstawie
\ref{def:f_context_2}.\label{ex:f_context_b}

    \item           \(\alpha:*,\,x:\alpha\to\alpha\)           jest
\(\lambda 2\)-kontekstem      na      podstawie      
\ref{def:f_context_3}.     Zauważmy,     że
deklaracja    \(\alpha:*\)    wysępuje   w    kontekście    przed
\(x:\alpha\to\alpha\).\label{ex:f_context_c}

    \item \(\alpha:*,\,x:\alpha\to\alpha,\,\beta:*\) jest \(\lambda 2\)-kontekstem na podstawie \ref{def:f_context_2}.\label{ex:f_context_d}

    \item \(\Gamma\equiv(\alpha:*,\,x:\alpha\to\alpha,\,\beta:*,\,y:(\alpha\to\alpha)\to\beta)\) jest \(\lambda 2\)-kontekstem na podstawie \ref{def:f_context_3}. Wówczas \(\mathrm{dom}(\Gamma)=(\alpha,\,x,\,\beta,y)\) i \(\mathrm{rg}(\Gamma)=\{*,\,\alpha\to\alpha,\, \beta,\,(\alpha\to\alpha)\to\beta\}\).\label{ex:f_context_e}
  \end{enumerate}
\end{przyklad}

  \subsection{Typowanie}
  Wprowadzamy następujące reguły wyprowadzania typu:
  \begin{center}
  \begin{tabular}{r c c}

    \vspace{0.5cm}
    (var) &
      \(\Gamma \vdash x:\sigma\), & jeśli \(x:\sigma\in\Gamma\)\\
    \vspace{0.5cm}

    (app) &
    {\begin{prooftree}
      \Hypo{\Gamma \vdash M:\sigma \to \tau} \Hypo{ \Gamma \vdash N:\sigma}
      \Infer2[]{\Gamma \vdash MN:\tau}
    \end{prooftree}} & \\
    \vspace{0.5cm}

    (abs) &
    {\begin{prooftree}
      \Hypo{ \Gamma, x:\sigma \vdash M:\tau }
      \Infer1[]{\Gamma \vdash (\lambda\, x:\sigma.\, M):\sigma\to \tau}
    \end{prooftree}} & \\
    \vspace{0.5cm}

    (form) &
      \(\Gamma\vdash B:*\), & jeśli \(B\in\mathbb{T}2\) i  \(\mathrm{FV}(B)\subseteq \mathrm{rg}\,\Gamma\)\\
    \vspace{0.5cm}

    (\(\Pi\)-e) &
    {\begin{prooftree}
      \Hypo{ \Gamma \vdash M:(\Pi \alpha:*.\,A)}
      \Hypo{ \Gamma \vdash B:* }
      \Infer2[]{\Gamma \vdash M B : A[\alpha/B]}
    \end{prooftree}} &
     \\
    \vspace{0.5cm}

    (\(\Pi\)-i) &
    {\begin{prooftree}
      \Hypo{\Gamma, \alpha : * \vdash M:A } 
      \Infer1[]{\Gamma \vdash \lambda \alpha:*.\,M:\Pi \alpha:*.\,A}
    \end{prooftree}} & \\
  \end{tabular}
  \end{center}

  \begin{definicja}(Poprawność, typowalność)
    Powiemy, że term \(M\in\mathbf{\Lambda}_{\mathbb{T}2}\) jest \emph{poprawny} lub \emph{typowalny}, jeśli istnieje \(\lambda 2\)-kontekst \(\Gamma\) i typ \(\rho\in \mathbb{T}2\) taki, że \(\Gamma\vdash M:\rho\).
  \end{definicja}

\begin{przyklad}
  \begin{enumerate}[label=(\alph*), ref=(\alph*)]
    \setlength\itemsep{0em}
    \item Niech \(\perp\ \mathrel{\equiv}\ \Pi \sigma: *.\, \sigma\) i \(\Gamma=(\beta:*,x:\perp)\).
      % \begin{equation*}
      % \begin{fitch}
      %   \fh \beta : * & (form) \\
      %   \fa \fh x : \perp & (var) \\
      %   \fa \lambda x :\perp .\, x\ :\ \perp \to \perp & (abs) 2 \\
      %   \lambda \beta : *.\, \lambda x :\perp .\, x\ :\ \Pi \beta : *.\,\perp \to \perp & (\(\Pi\)-i) 3 \\
      % \end{fitch}
    % \end{equation*}

    % \item 
      \begin{equation*}
      \begin{fitch}
        \fh \beta : * & (form) \\
        \fa \fh x : \perp & (var) \\
        \fa x\beta\ :\ \beta & (\(\Pi\)-e) 2 1 \\
        \lambda \beta : *.\,x\beta\ :\ \underbrace{\Pi \beta:*.\,\beta}_{\perp} & (\(\Pi\)-i) 3
      \end{fitch}
    \end{equation*}
    % \item \(\Gamma=(x:\perp,\beta:*)\).
    %   \begin{equation*}
    %   \begin{fitch}
    %     \fh x : \perp & (var) \\
    %     \fa \fh \beta : * & (form) \\
    %     \fa \lambda \beta : * .\, x\ :\ \Pi \beta:*.\,\perp & (\(\Pi\)-i) 1 \\
    %     \lambda x:\perp.\,\lambda \beta:*.\, x\ :\ \perp \to \Pi \beta:*.\,\perp &  (abs) 3
    %   \end{fitch}
    % \end{equation*}

    \item \(\Gamma=(\beta:*,y:\beta, x:\perp)\).
      % \begin{equation*}
      % \begin{fitch}
      %   \fh x : \perp & (var)\\
      %   \fa \fh \beta: * & (form)\\
      %   \fa \fa x\beta\ :\ \beta & (\(\Pi\)-e) 1 2\\
      %   \fa \lambda \beta:*.\,x\beta\ :\ \Pi \beta:*.\,\beta\ (=_\alpha \perp) & (\(\Pi\)-i) 3\\
      %   \lambda x:\perp.\lambda \beta:*.\,x\beta\ :\ \perp \to \perp  & (abs) 4
      % \end{fitch}
    % \end{equation*}
      \begin{equation*}
      \begin{fitch}
        \fh \beta: * & (form)\\
        \fa \fh y : \beta & (var) \\
        \fa \fa \fh x : \perp & (var)\\
        \fa \fa \lambda x:\perp.\,y\ : \perp \to \beta & (abs) 2\\ 
        \fa \lambda y:\beta\ x:\perp.\, y\ :\ \perp \to \beta & (abs) 4 \\
        \lambda \beta :*.\,\lambda y:\beta\ x:\perp.\, y\ :\ \Pi \beta :*.\,\perp \to \beta & (\(\Pi\)-i) 1 \\
      \end{fitch}
    \end{equation*}
%      Zauważmy, że nie istnieje \(\lambda\)-term typu \(\perp\). Typ, który nie ma inhabitantów nazywamy typem \emph{początkowym} (ang. \emph{initial}), \emph{zerowym} albo typem \emph{bottom}.
    \item Polimorficzna funkcja identycznościowa.
      \begin{equation*}
      \begin{fitch}
        \fh \sigma : * & (form)\\
        \fa \fa x : \sigma & (var)\\
        \fa \lambda x:\sigma .\ x\ :\ \sigma\to\sigma & (abs) 2\\
        \lambda \sigma : *.\,\lambda x:\sigma.\ x\ :\ \Pi\sigma:*.\,\sigma\to\sigma & (\(\Pi\)-i) 3
      \end{fitch}
      \end{equation*}
    \item Polimorficzna iteracja.
      \begin{equation*}
      \begin{fitch}
        \fh \sigma : * & (form) \\
        \fa \fh f: \sigma \to \sigma & (var) \\
        \fa \fa \fh x : \sigma & (var) \\
        \fa\fa \fa f x\ :\ \sigma & (app) 2 3 \\
        \fa \fa \fa f(f x)\ :\ \sigma  & (app) 2 1 \\
        \fa \fa \lambda x : \sigma .\, f(fx)\ :\ \sigma \to \sigma & (abs) 5 \\
        \fa \lambda f : \sigma \to \sigma .\, \lambda x :\, \sigma .\, f (fx)\ :\ (\sigma \to \sigma) \to \sigma \to \sigma &  (abs) 6 \\
      \lambda \sigma : * .\, \lambda f : \sigma \to \sigma .\, \lambda x : \sigma .\, f (f x)\ :\ \Pi \sigma : * .\, (\sigma \to \sigma) \to \sigma \to \sigma & (\(\Pi\)-i) 7 
      \end{fitch}
      \end{equation*}
    \item Polimorficzne złożenie funkcji.
      \begin{equation*}
      \begin{fitch}
        \fh \rho: * & (form) \\
        \fa \fh \tau: * & (form) \\
        \fa \fa \fh \sigma : * & (form) \\
        \fa \fa \fa \fh g : \tau\to\rho & (var) \\
        \fa \fa \fa \fa \fh f : \sigma\to\tau & (var) \\
        \fa \fa \fa \fa \fa \fh x : \sigma & (var) \\
        \fa \fa \fa \fa \fa \fa f a\ :\ \tau & (app) 5 6 \\
        \fa \fa \fa \fa \fa \fa g (f a)\ :\ \rho & (app) 4 7 \\
        \fa \fa \fa \fa \fa \lambda x:\sigma.\,g(f a)\ :\ \sigma \to \rho & (abs) 8 \\
        \fa \fa \fa \fa \begin{gathered}
        \lambda f:\sigma\to\tau\ x:\sigma.\ g(f a)\ :\\ (\sigma\to\tau)\to\sigma\to\rho \end{gathered} & (abs) 9 \\ 
        \fa \fa \fa \begin{gathered}\lambda g: \tau \to \rho\  f:\sigma\to\tau\ x:\sigma.\ g(f a)\ :\\ (\tau\to\rho)\to(\sigma\to\tau)\to\sigma\to\rho\end{gathered} & (abs) 10\\ 
      \fa \fa \begin{gathered} \lambda \sigma:*.\,\lambda g: \tau \to \rho\  f:\sigma\to\tau\ x:\sigma.\ g(f a)\ :\\ \Pi\sigma:*.(\tau\to\rho)\to(\sigma\to\tau)\to\sigma\to\rho\end{gathered} & (abs) 11\\ 
      \fa \begin{gathered} \lambda \tau \sigma:*.\,\lambda g: \tau \to \rho\  f:\sigma\to\tau\ x:\sigma.\ g(f a)\ :\\ \Pi\sigma:*.(\tau\to\rho)\to(\sigma\to\tau)\to\sigma\to\rho\end{gathered} & (abs) 11\\ 
      \begin{gathered} \lambda \rho \tau \sigma:*.\,\lambda g: \tau \to \rho\  f:\sigma\to\tau\ x:\sigma.\ g(f a)\ :\\ \Pi\sigma:*.(\tau\to\rho)\to(\sigma\to\tau)\to\sigma\to\rho\end{gathered} & (abs) 11 
      \end{fitch}
      \end{equation*}
  \end{enumerate}
\end{przyklad}
 Jak widzimy procedura wyprowadzania typu odpowiada w istocie rekonstrukcji wyrażenia. Problem typowania w (ortodoksyjnym) stylu Churcha jest trywialny, gdyż zgodnie z Rozdziałem \ref{subsec:church_style} założyliśmy, że mamy pełną informację typową o wszystkich zmiennych przedmiotowych. 

  \subsection{Redukcja}

  \begin{definicja}(\(\beta\)-redukcja)
    \(\beta\)-redukcją nazywamy najmniejszą (w sensie mnogościowym) zgodną na \(\mathbf{\Lambda}_{\mathbb{T}2}\) relację binarną \(\to_\beta\) taką, że
  \begin{align*}
    (\lambda x.\,M)N &\to\beta M[x/N].\\
    (\lambda \alpha:*.\,M) T &\to_\beta M[\alpha/T]
  \end{align*}
  \end{definicja}
  \begin{przyklad}
    \begin{align*}
    \lambda \alpha : *.\,\lambda f:\alpha\to\alpha.\,\lambda x:\alpha.\,f(f x))\,\mathrm{nat\  suc\  two} \to_\beta\\
      \lambda f : \mathrm{nat}\to\mathrm{nat}.\,\lambda x :\mathrm{nat} .\, f\,(f\,x))\, \mathrm{suc\  two} \to_\beta\\
      (\lambda x:\mathrm{nat}.\,\mathrm{suc}\,(\mathrm{suc}\ x))\,\mathrm{two} \to_\beta \\
      \mathrm{suc}\,(\mathrm{suc}\ \mathrm{two}).
    \end{align*}
  \end{przyklad}

Twierdzenie \ref{thm:uniqueness_f} (podobnie jak Twierdzenie \ref{thm:type_uniqueness}) zapewnia nas, że typ termu zachowuje się przy \(\beta\)-redukcji. Praktyczny sens tego twierdzenia polega na tym, że relacja posiadania tego samego typu jest zamknięta na \(\beta\)-konwersję i aby rozstrzygnąć o typie danego termu wystarczy, że znamy typ któregokolwiek jego \(\beta\)-konwersa.

\begin{twierdzenie}(O jednoznaczności)\label{thm:uniqueness_f}
  Jeśli \(\Gamma\vdash M:\tau\) i \(M\to^{*}_\beta N\), to \(\Gamma\vdash N:\tau\).
\end{twierdzenie}
\begin{dowod}
  Dowód przeprowadzamy przez indukcję względem długości wyprowadzenia sądu \(\Gamma\vdash M;\tau\). Szczegóły pomijamy. \qed
\end{dowod}


\subsection{Własności}

O generowaniu
O podtermie
O zmiennych wolnych

\subsection{System Hindleya-Milnera}
\subsection{Podsumowanie}
Na kanwie zaproponowanej przez H. P. Barendregta w \cite[Rozdział 5]{Barendregt_1992} klasyfikacji rozszerzeń rachunku \(\lambda\) z typami prostymi (tzw. \emph{kostki \(\lambda\)}, Rysunek \ref{fig:lambda-cube}), rozdział ten poświęcimy omówieniu wzajemnych zależności jakie mogą łączyć \(\lambda\)-termy i typy. Zajmować będziemy się wyłącznie systemami w stylu Churcha.

\begin{figure}[!h]
  \centering
  \begin{tikzpicture}
  \matrix (m) [matrix of math nodes,
  row sep=3em, column sep=3em,
  text height=1.5ex,
  text depth=0.25ex]{
              & \lambda\omega             &              & \lambda P \omega             \\
  \lambda 2   &                           & \lambda P 2                                \\
              & \lambda\underline{\omega} &              & \lambda P \underline{\omega} \\
  \lambda{\to}&                           & \lambda P  \\
  };
  \path[-{Latex[length=2.5mm, width=1.5mm]}]
  (m-1-2) edge (m-1-4)
  (m-2-1) edge (m-2-3)
          edge (m-1-2)
  (m-3-2) edge (m-1-2)
          edge (m-3-4)
  (m-4-1) edge (m-2-1)
          edge (m-3-2)
          edge (m-4-3)
  (m-3-4) edge (m-1-4)
  (m-2-3) edge (m-1-4)
  (m-4-3) edge (m-3-4)
          edge (m-2-3);
  \end{tikzpicture}
  \caption{Poszczególne systemy klasyfikacji H. Barendregta; kierunek krawędzi \(\to\)  oznacza relację \(\subseteq\).}\label{fig:lambda-cube}
\end{figure}



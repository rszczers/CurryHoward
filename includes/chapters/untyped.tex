
\section{Rachunek \(\lambda\)}
Niech  \(V\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych \(x,\ y,\ \dots\) (indeksowanych być może liczbami naturalnymi). Elementy takiego zbioru będziemy nazywali \emph{\(\lambda\)-zmiennymi}. Ponieważ \(V\) jest potencjalnie nieskończony, zastrzegamy sobie możliwość wybierania w razie potrzeby wcześniej nie użytej zmiennej.

\begin{definicja}(Zbiór \(\mathbf{\tilde\Lambda}\) pretermów)\label{def:lambda-untyped}
Zbiorem pretermów będziemy nazywali najmniejszy (w sensie mnogościowym) zbiór wyrażeń \(\mathbf{\tilde\Lambda}\) taki, że:
  \begin{enumerate}[label={(P\arabic*)}, ref={(P\arabic*)}]
  \setlength\itemsep{0em}
  \item Jeśli \(x \in V\), to \(x\in\mathbf{\tilde\Lambda}\).\label{pret1}
  \item Jeśli \(M,\,N\in \mathbf{\tilde\Lambda}\), to \((M\,N)\in\mathbf{\tilde\Lambda}\).\label{pret2}
  \item Jeśli \(x\in V\) i \(M\in\mathbf{\tilde\Lambda}\), to \((\lambda x.\,M)\in\mathbf{\tilde\Lambda}\).\label{pret3}
  \end{enumerate}
\end{definicja}
Definicję \ref{def:lambda-untyped} można równoznacznie wyrazić przy pomocy notacji Backusa-Naura. Wówczas ma ona następującą, zwięzłą postać:
\begin{align*}
  \mathbf{\tilde\Lambda}\ \leftarrow \ V\ |\ (\mathbf{\tilde\Lambda}\,\mathbf{\tilde\Lambda}) \ |\ (\lambda V.\, \mathbf{\tilde\Lambda})
\end{align*}

Elementy \(\mathbf{\tilde\Lambda}\) będziemy oznaczali literami \(L,\ M,\ N,\ P,\ Q,\ R\) i ich wariantami z górnymi lub dolnymi indeksami. Wyrażenia postaci \ref{pret2} nazywamy \emph{aplikacjami} \(M\) do \(N\). Symbol \(\lambda\) występujący w \ref{pret3} nazywamy \emph{\(\lambda\)-abstraktorem}, zaś wyrażenia powstałe przez zastosowanie tej reguły to \emph{\(\lambda\)-abstrakcje}. W wyrażeniu postaci \((\lambda x.\,M)\) preterm \(M\) jest w \emph{zasięgu} \(\lambda\)-abstraktora, a zmienna \(x\) jest przez niego \emph{związana}. Ponadto, będziemy stosowali następujące konwencje notacyjne:
\begin{easylist}
  & \emph{najbardziej zewnętrzne nawiasy bedą pomijane,}
  & \emph{aplikacja wiąże lewostronnie; wyrażenia postaci \((PQ)R\) będą zapisywane w postaci \(PQR\),}
  & \emph{\(\lambda\)-abstrakcja wiaże prawostronnie: \(\lambda x_1.\, (\lambda x_2.\,P)\) zapisujemy  \(\lambda x_1.\, \lambda x_2.\,P\),}
  & \emph{następujące po sobie \(\lambda\)-abstrakcje postaci \(\lambda x_1 . \, \lambda x_2 . \, \dots  \lambda x_n .\, P\) zapisujemy pod wspólnym \(\lambda\)-abstraktorem: \(\lambda x_1 \, x_2 \, \dots \, x_n .\, P\).}
\end{easylist}

Powiemy, że dwa \(\lambda\)-termy są \emph{syntaktycznie równe}, jeśli rozumiane jako ciągi znaków są identyczne. Równość syntaktyczną będziemy oznaczali znakiem \(\equiv\).

\begin{przyklad}
  Podajmy kilka przykładów \(\lambda\)-pretermów pogrupowanych ze względu na ich konstrukcję.
  \begin{enumerate}[label={(P\arabic*):}, ref={(P\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x,\ y,\ z\).
    \item \(x\,x,\ y\,x,\ x\,(x\,z)\),\\
          \((\lambda x .\, (x z)) y,\
             y\, (\lambda x .\, (x\, z)),\ (\lambda x .\, x)\,(\lambda x .\, x)\).
    \item \( \lambda x .\, (x \, z),\
             \lambda y z .\, x,\
             \lambda x .\, (\lambda x .\, (x\, x))\).
  \end{enumerate}
\end{przyklad}

Podwyrażenia \(\lambda\)-pretermu mogą być wzajemnie identyczne i występować wielokrotnie. Obserwację tę ujmuje następująca definicja.
\begin{definicja}(Multizbiór \(\mathrm{Sub}\) podtermów pretermu)\label{def:untyped_subterm}
  \begin{enumerate}[label={(\arabic*)}, ref={(\arabic*)}]
    \setlength\itemsep{0em}
    \item \(\mathrm{Sub}(x)=\{x\}\)
    \item \(\mathrm{Sub}(MN)=\mathrm{Sub}(M)\cup\mathrm{Sub}(N)\cup\{M\,N\}\)
    \item \(\mathrm{Sub}(\lambda x.\, M) = \mathrm{Sub}(M)\cup \{\lambda x.\, M\}\)
  \end{enumerate}
  Elementy multizbioru \(\mathrm{Sub}(M)\) nazywamy \emph{podtermami} \(M\). Jeśli \(L\) jest podtermem \(M\), ale \(L\not\equiv M\), to \(L\) nazywamy podtermem \emph{właściwym}.
\end{definicja}
\begin{przyklad} Podtermy wybranych \(\lambda\)-pretermów.
  \begin{align*}
    \begin{split}
      \mathrm{(a)}\quad & \mathrm{Sub}\left(\lambda x.\,x\, x\right)=\left\{\left(\lambda x.\,x\, x\right)^1,\  \left(x\, x\right)^1,\ x^2\right\}\\
       \mathrm{(b)}\quad & \mathrm{Sub}\left(\left(\lambda x .\, x\, x\right)\,\left(\lambda x .\, x\, x\right)\right) = \\
    & = \left\{((\lambda x .\, x\, x)\,(\lambda x .\, x\, x))^{1}, \ (\lambda x .\, x\, x)^2,\ (x\,x)^{2},\ x^{4}\right\}\\
  \end{split}
  \end{align*}
  W powyższych przykładach użyliśmy standardowej notacji w górnym indeksie umieszczając krotność występowania elementu.
\end{przyklad}
\begin{definicja}(Zbiór \(\mathrm{FV}\) zmiennych wolnych)\label{def:untyped_fv}
  Dla dowolnego pretermu \(M\) określamy zbiór \(\mathrm{FV}(M)\) \emph{zmiennych wolnych} w \(M\) w następujący sposób:
\begin{align*}
    \mathrm{FV}(x) &= \{x\}\\
    \mathrm{FV}(\lambda x .\, P)  &= \mathrm{FV}(P)\setminus\{x\}\\
    \mathrm{FV}(P Q) &= \mathrm{FV}(P)\cup\mathrm{FV}(Q)
\end{align*}
  Jesli \(\mathrm{FV}(M)=\emptyset\), to mówimy, że \(M\) jest \emph{domknięty} lub nazywamy \(M\) \emph{kombinatorem}.
\end{definicja}
\begin{przyklad}
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item \(\mathrm{FV}(\lambda x.\,x\,y)=\left\{y\right\}\)
    \item \(\mathrm{FV}(x\,(\lambda x.\, x\,y)) = \left\{x,\ y\right\}\)
    \item \(\mathrm{FV}(\lambda x y z.\, x y) = \emptyset\)
  \end{enumerate}
\end{przyklad}

\begin{definicja}(Podstawienie)\label{def:substitution}
  Dla dowolnych \(\mathrm{M,\,N}\in\mathbf{\tilde\Lambda}\) i \(x\in V\) przez \(N[x/N]\) oznaczamy rezultat podstawienia termu \(N\) za wszystkie wolne wystąpienia zmiennej \(x\) w \(M\), o ile w rezultacie podstawienia nie zostaną związane żadne zmienne wolne występujące w \(N\). W takim wypadku \emph{podstawienie} jest przekształceniem pretermów określonym w następujący sposób:
  \begin{enumerate}[label={(S\arabic*)}, ref={(S\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x[x/N] = N\)
    \item \(y[x/N] = y,\ \text{o ile}\ x\not\equiv y\)
    \item \((PQ)[x/N] = P[x/N]\,Q[x/N]\)\label{def:substitution_c}
    \item \((\lambda y.\, P)[x/N] = \lambda y.\,P[x/N],\ \text{gdzie}\ x\not\equiv y\ \text{i}\ y\not\in \mathrm{FV}(N)\)
    \item \((\lambda x.\, P)[x/N] = \lambda x.\,P\)\label{def:substitution_e}
  \end{enumerate}
  Zauważmy, że jest to funkcja częściowa w zbiorze \(\mathbf{\tilde\Lambda}\times V \times \mathbf{\tilde\Lambda}\). Powiemy, że \(M[x/N]\) jest \emph{poprawnym podstawieniem}, jeśli podstawienie \(M[x/N]\) jest określone w myśl Definicji \ref{def:substitution}.
\end{definicja}

\begin{lemat}(O podstawieniu)\label{lem:substitution}
  Niech \(M,\,N,\,L\in \mathbf{\tilde\Lambda}\) i niech ponadto \(x\not\equiv y\) oraz \(x\not\in\mathrm{FV}(L)\). Wówczas
  \begin{align}\label{eq:substitution}
    M[x/N][y/L]\equiv M[y/L]\left[x/N\left[y/L\right]\right].
  \end{align}
  \begin{dowod}
    Dowód przebiega przez indukcję strukturalną względem \(M\). Rozważmy następujące przypadki:
    \begin{enumerate}[label={\roman*)}, ref={(\arabic*)}]
      \item \(M\) jest zmienną. Wówczas:
        \begin{enumerate}[label={\alph*.}]
        \item Jeśli \(M\equiv x\), to obie strony \eqref{eq:substitution} po podstawieniu są postaci \(N[y/L]\).
        \item Jeśli \(M\equiv y\), to ponieważ \(x\not\equiv y\) i \(x\not\in\mathrm{FV}(M)\), po wykonaniu podstawienia po lewej stronie \eqref{lem:substitution} otrzymujemy \(M[x/N][y/L]\equiv L\). Ponieważ \(x\not\in\mathrm{FV}(L)\), to po wykonaniu podstawienia po prawej stronie widzimy, że obydwie strony są identyczne.

        \item Jeśli \(M\equiv z\) i \(z\not\equiv x\)  oraz \(z\not\equiv y\), to obydwie strony \eqref{eq:substitution} sa identyczne.
        \end{enumerate}

      \item \(M\equiv P Q\) dla pewnych \(P,\,Q\in\mathbf{\tilde\Lambda}\). Wówczas korzystając z hipotezy indukcyjnej wnosimy, że
        \begin{align*}
          P[x/N][y/L]\equiv P[y/L]\left[x/N\left[y/L\right]\right],\\
          Q[x/N][y/L]\equiv Q[y/L]\left[x/N\left[y/L\right]\right].
        \end{align*}
        Mając na względzie \ref{def:substitution_c} widzimy, że twierdzenie zachodzi i w tym przypadku.
        \item Jeśli \(M\equiv \lambda z.\,P\) oraz \(z\equiv x\) lub \(z\equiv y\), to z \ref{def:substitution_e} widzimy, że obydwie strony \eqref{eq:substitution} sa identyczne. Przypuśćmy, że \(z\not\equiv x\) i \(z\not\equiv y\) i \(z\not\in\mathrm{FV}(L)\). Wówczas na podstawie hipotezy indukcyjnej mamy:
      \begin{align*}
        (\lambda z.\,P)[x/N][y/L] &= \lambda z.\,P[x/N][y/L] =\\
                                  &= \lambda z.\,P[y/L][x/N[y/L]] =\\
                                  &= (\lambda z.\,P)[y/L][x/N[y/L]].
      \end{align*}
    \qed
    \end{enumerate}
  \end{dowod}
\end{lemat}

\begin{wniosek}\label{thm:odwracalnosc_podstawienia}
Jesli \(M[x/y]\) jest poprawnym postawieniem i \(y\not\in\mathrm{FV}(M)\), to \(M[x/y][y/x]\) jest poprawnym podstawieniem oraz
  \(M[x/y][y/x]=M\).
  \begin{dowod}
    Mając na uwadze Lemat \ref{def:substitution} dowód przebiega przez indukcję strukturalną względem \(M\).
    \qed
  \end{dowod}
\end{wniosek}

\subsection{Wyrażenia \(\lambda\)}
Na ogół chcielibyśmy utożsamiać pretermy, które różnią się wyłącznie zmiennymi związanymi, tak jak w przypadku wyrażeń \(\lambda x. \,zx\) i \(\lambda y.zy\). W takim wypadku powiemy o nich, że są swoimi \emph{\(\alpha\)-wariantami} lub że są ze sobą w relacji \emph{\(\alpha\)-konwersji}.

\begin{definicja}(Relacja \(\alpha\)-konwersji)\label{def:untyped_alpha}
  Relacją \(=_{\alpha}\) (\(\alpha\)-konwersji) nazywamy najmniejszy w sensie mnogościowym praporządek na \(\mathbf{\tilde\Lambda}\) taki, że
  \begin{enumerate}[label={(\(\alpha\)\arabic*)}, ref={(\(\alpha\)\arabic*)}]
  \setlength\itemsep{0em}
  \item Jeśli \(y\not\in \mathrm{FV}(M)\) oraz \(M[x/y]\) jest poprawnym podstawieniem,\\ to \(\lambda x.\,M~=_{\alpha}~\lambda y.\,M[x/y]\)\label{def:alpha_1}
  \item Jeśli \(M=_{\alpha} N\), to dla dowolnego \(x\in V\) zachodzi \(\lambda x.\,M =_{\alpha} \lambda x.\,N\)\label{def:alpha_2}
  \item Jeśli \(M=_{\alpha} N\), to dla dowolnego \(Z\in\mathbf{\tilde\Lambda}\) zachodzi \(MZ =_{\alpha} NZ\)\label{def:alpha_3}
  \item Jeśli \(M=_{\alpha} N\), to dla dowolnego \(Z\in\mathbf{\tilde\Lambda}\) zachodzi \(ZM =_{\alpha} ZN\)\label{def:alpha_4}
  \end{enumerate}
\end{definicja}

\begin{wniosek}
  Relacja \(=_{\alpha}\) jest relacją równoważności.
  \begin{dowod}
    Wystarczy, że pokażemy, że relacja \(=_{\alpha}\) jest symetryczna. Dowód przebiega przez indukcję względem Definicji \ref{def:untyped_alpha}. Rozważmy następujące przypadki:
    %Fakt \ref{def:odwracalnosc_podstawienia}

    \begin{enumerate}[label={\roman*)}, ref={(\roman*)}]
      \item Jeśli \(M=_{\alpha} N\) w konsekwencji zwrotności \(=_{\alpha}\), to \(M\equiv N\), a zatem również \(N\equiv M\). Stąd \(N=_{\alpha} M\).
      \item Jeśli \(M=_{\alpha} N\) w konsekwencji przechodniości \(=_{\alpha}\), to istnieje \(L\in\mathbf{\tilde\Lambda}\) takie, że \(M=_{\alpha}L\) i \(L=_{\alpha}N\). Wówczas z hipotezy indukcyjnej \(N=_{\alpha}L\) i \(L=_{\alpha}M\). Z przechodniości relacji \(=_{\alpha}\) otrzymujemy spodziewaną tezę.
      \item Przypuśćmy, że \(M=_{\alpha} N\) w konsekwencji  \ref{def:alpha_1}  dla \(M\equiv\lambda x.\,M'\) i \(N\equiv\lambda y.\,M'[x/y]\). Ponieważ \(x\not\in\mathrm{FV}(M'[x/y])\), to ze względu na Wniosek \ref{thm:odwracalnosc_podstawienia} mamy, że \(M'[x/y][y/x]=M'\). Zatem, na podstawie \ref{def:alpha_1}:
  \begin{align*}
        \lambda y.\,M'[x/y] =_{\alpha} \lambda x.\,M'[x/y][y/x].
      \end{align*}
    \item  Jeśli \(M=_{\alpha} N\) w konsekwencji \ref{def:alpha_2}, gdzie \(M=\lambda x.\,M'\) i \(N=\lambda x.\,N'\) dla \(M'=_{\alpha} N'\), to z hipotezy indukcyjnej \(N' =_{\alpha} M'\) i w konsekwencji \ref{def:alpha_2} mamy, że \(N=_{\alpha} M\).
    \item  Jeśli \(M=_{\alpha} N\) w konsekwencji \ref{def:alpha_3} dla \(M\equiv M'Z\) i \(N\equiv N'Z\) takich, że \(M'=_{\alpha}N'\), to z hipotezy indukcyjnej oczywiście \(N'=_{\alpha}M'\), a zatem z \ref{def:alpha_3} \(N=_{\alpha} M\).\label{proof:alpha_cases_4}
    \item  Jeśli \(M=_{\alpha} N\) w konsekwencji \ref{def:alpha_3}, to postępujemy jak w przypadku \ref{proof:alpha_cases_4}.\qed
    \end{enumerate}
  \end{dowod}
\end{wniosek}

\begin{definicja}(Zbiór \(\mathbf{\Lambda}\) \(\lambda\)-termów)
  Każdą klasę abstrakcji relacji \(=_{\alpha}\) nazywamy \(\lambda\)-termem. Zbiór wszystkich \(\lambda\)-termów \(\mathbf{\Lambda}\) to zbiór ilorazowy relacji \(\alpha\)-konwersji:
  \begin{align*}
    \mathbf{\Lambda}=\left\{[M]_{=_\alpha}\ |\ M\in\mathbf{\tilde\Lambda}\right\}
  \end{align*}
\end{definicja}

\begin{konwencja*}
Wprowadzamy następujące konwencje notacyjne:
\begin{align*}
  &x = [x]_{=_\alpha},\\
  &PQ = [M'N']_{=_\alpha},\ \text{gdzie}\ M=[M']_{=_\alpha}\ \text{i}\ N=[N']_{=_\alpha},\\
  &\lambda x.\,M =  [\lambda x.\,M']_{=_\alpha},\  \text{gdzie}\ N=[N']_{=_\alpha}.
\end{align*}
\end{konwencja*}
%Nie prowadzą one do niejednoznaczności, w czym upewnia nas Lemat \ref{lem:uniqueness}.

%\begin{lemat}(O jednoznaczności)\label{lem:uniqueness}
%  Dla dowolnych \(M,\,N
%\end{lemat}

Na zbiór \(\mathbf{\Lambda}\) przenoszą się pojęcia podtermu, zmiennych wolnych i operacji podstawienia definiowane uprzednio dla pretermów.

\begin{definicja}(Multizbiór \(\mathrm{Sub}\) podtermów \(\lambda\)-termu)
  Dla dowolnego \(\lambda\)-termu \(M=[M']_{=_{\alpha}}\) okreslamy
  \[
    \mathrm{Sub}(M)=\mathrm{Sub}(M'),
  \]
  gdzie \(\mathrm{Sub}(M')\) jest multizbiorem podwyrażeń pretermu \(M'\) zdefiniowanym w myśl Definicji \ref{def:untyped_subterm}.
\end{definicja}

\begin{definicja}(Zbiór zmiennych wolnych \(\mathrm{FV}\))
  Dla dowolnego \(\lambda\)-termu \(M=[M']_{=_{\alpha}}\) określamy zbiór \(\mathrm{FV}(M)\) \emph{zmiennych wolnych} w \(M\) 
  \[
    \mathrm{FV}(M)=\mathrm{FV}(M'),
  \]
  gdzie \(\mathrm{FV}(M')\) jest zbiorem zmiennych wolnych pretermu \(M'\) zdefiniowanym w myśl Definicji \ref{def:untyped_fv}.
\end{definicja}

\begin{definicja}(Podstawienie)\label{def:untyped_lambda_substitution}
  Niech \(M=[M']_{=_\alpha}\) i \(N=[N']_{=_\alpha}\) i niech \(M'[x/N']\) będzie poprawnym podstawieniem w myśl Definicji \ref{def:substitution}. Wówczas
  \[
    M[x/N]= [M'[x/N']]_{=_\alpha}.
  \]
\end{definicja}

Operacja podstawienia wymaga jednak pewnej delikatności. Rozważmy następującą relację:
\[
  \lambda x.\,zx=_{\alpha}\lambda y.\,zy
\]
Zauważmy, że traktując operację podstawienia w sposób naiwny, otrzymujemy, że \((\lambda x.\,zx)[z/x]\neq_{\alpha}(\lambda y.\,zy)[z/x]\), a więc tracimy porządaną własność niezmienniczości \(\alpha\)-konwersji względem podstawienia. Stąd w Definicji \ref{def:substitution} wymóg, aby poprawne podstawienie nie prowadziło do uszczuplenia zbioru zmiennych wolnych. Precyzyjniejszym rozwiązaniem jest określenie podstawienia, które prowadziłoby do abstrachowania po wcześniej nie występujacych zmiennych, czyli
\[
  (\lambda x.\,M)[y/N] = \lambda x'.\,M[x/x'][y/N],
\]
w przypadku, gdy \(x\not\equiv y\), gdzie \(x'\not\in\mathrm{FV}(M)\) i \(x'\not\in\mathrm{FV}(N)\). Rozstrzygnięcie takie przytacza się w \cite{Hindley:2008:LCI:1388400,}. Precyzyjnie tę ideę ujmuje Definicja \ref{def:untyped_substitution_hindley}.
\begin{customdef}{4'}(Podstawienie')\label{def:untyped_substitution_hindley}
  \begin{enumerate}[label={(S'\arabic*)}, ref={(S'\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x[x/N] = N\)
    \item \(y[x/N] = y,\ \text{o ile}\ x\not\equiv y\)
    \item \((PQ)[x/N] = P[x/N]\,Q[x/N]\)
    \item \((\lambda x.\, P)[x/N] = \lambda x.\,P\)
    \item \((\lambda y.\, P)[x/N] = \lambda y.\,P\), jeśli \(x\not\in\mathrm{FV}(P)\)\label{def:substitution_e}\label{def:substitution_hindley_e}
    \item \((\lambda y.\, P)[x/N] = \lambda y.\,P[x/N],\ \text{gdzie}\ x\in\mathrm{FV}(P)\) i \(y\not\in\mathrm{FV}(N)\)\label{def:substitution_hindley_f}
    \item \((\lambda y.\, P)[x/N] = \lambda z.\,P[y/z][x/N],\ \text{gdzie}\ x\in\mathrm{FV}(P)\) i \(y\in\mathrm{FV}(N)\)\label{def:substitution_hindley_g}
  \end{enumerate}
  przy czym w \ref{def:substitution_hindley_g} wymagamy, aby zmienna \(z\) nie występowała wcześniej w termach \(N\) i \(P\) jako zmienna wolna, zaś dla \ref{def:substitution_hindley_e}-\ref{def:substitution_hindley_g} dodatkowo \(y\not\equiv x\). 
\end{customdef}
Pozornie błacha operacja podstawienie okazuje się centralnym pojęciem we wszystkich systemach rachunku \(\lambda\). To na niej opiera się sens obliczeniowy tych systemów, co jest naturalne, bo w istocie są to przecież systemy przepisujące. W literaturze znajdujemy mnogość propozycji, które w ten czy inny sposób starają się ułatwić rzeczywistą implementację tej operacji. Na szczególną uwagę zasługują tutaj tak zwane \emph{indeksy de Bruijna}. Zaproponowana przez de Brujina w \cite{deBruijnIndices}  notacja eliminuje bezpośrednie występowanie zmiennych w \(\lambda\)-termach i historycznie wiąże się z jego pracami nad systemem wspomaganego dowodzenia twierdzeń AUTOMATH.

Szerszy komentarz dotyczący dotychczasowych prób uchwycenia operacji podstawienia można prześledzić w \cite{DBLP:journals/corr/abs-1303-5039}. Nasze rozważania opierają się w tej materii przeważająco na \cite{Urzyczyn2006}. Samo podejście do definiowania \(\lambda\)-termow przez operację \(\alpha\)-konwersji nie jest powszechne w literaturze przedmiotu. Analogiczną konstrukcję należałoby powtarzać wprowadzając każdy kolejny system, dlatego w dalszej części tej pracy będziemy poprzestawali na nieformalnym traktowaniu wyrażeń danego systemu jako odpowiednich klas \(\alpha\)-konwersji.

Notowanie serii podstawień prędko staje się niezręczne, dlatego na gruncie Definicji \ref{def:untyped_lambda_substitution} potrzebujemy okreslić nieco więcej cukru syntaktycznego.

\begin{definicja}(Podstawienie jednoczesne)
Dla dowolnego \(M\in\mathbf{\Lambda}\), ciągu \(\lambda\)-zmiennych~\(\vec{x}\) i ciągu \(\lambda\)-termów \(\vec{N}\) określamy:
  \begin{enumerate}[label={(\(\vec{s}\)\arabic*)}, ref={(\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x_i[\vec{x}/\vec{N}]=N_i\) dla \(i\in\mathbb{N}\).
    \item \(y[\vec{x}/\vec{N}]=y\) o ile dla dowolnego \(i\in\mathbb{N},\ y\not\equiv x_i\).
    \item \((PQ)[\vec{x}/\vec{N}]=P[\vec{x}/\vec{N}]Q[\vec{x}/\vec{N}]\)
    \item \((\lambda y.\,P)[\vec{x}/\vec{N}]=\lambda y'.\,P[y/y'][\vec{x}/\vec{N}]\), gdzie \(y'\) jest wcześniej nie występującą zmienną, \(y\not\equiv x_i\)  dla wszystkich \(i\in\mathbb{N}\) i \(y\not\in\bigcup_{i\in\mathbb{N}}FV(N_i)\).
  \end{enumerate}
\end{definicja}
\begin{przyklad}
  Porównajmy następujące podstawienia:
  \begin{enumerate}[label={(\alph*)}, ref={(\alph*)}]
    \item Niech \(\vec{x}=id\) i niech \(\vec{N}\) będzie ciągiem stałym o wyrazie 
  \end{enumerate}
\end{przyklad}
\subsection{Redukcja}
Sens obliczeniowy \(\lambda\)-termom nadajemy przez określenie na \(\mathbf{\Lambda}\) operacji \(\beta\)- i \(\eta\)-redukcji. Pożądane jest, żeby operacje te wykonywane na podtermach pozostowały w \emph{zgodzie} ze strukturą całego \(\lambda\)-termu. 

\begin{definicja}(Relacja zgodna)
  Relację binarną \(\mathcal{R}\) na zbiorze \(\mathbf{\Lambda}\) nazywamy \emph{zgodną}, jeśli dla dowolnych \(M,\,N,\,P \in \mathbf{\Lambda}\) zachodzą następujące warunki:
  \begin{enumerate}[label={(c\arabic*)}, ref={(\arabic*)}]
    \setlength\itemsep{0em}
    \item Jeśli \(M \mathcal{R} N\), to \((\lambda x.\,M)\,\mathcal{R}\,(\lambda x.\,N)\) dla dowolnej \(\lambda\)-zmiennej \(x\).
    \item Jeśli \(M \mathcal{R} N\), to \((MP)\,\mathcal{R}\,(NP)\). 
    \item Jeśli \(M \mathcal{R} N\), to \((PM)\,\mathcal{R}\,(PN)\).
  \end{enumerate}
\end{definicja}
Przez \emph{domknięcie relacji} \(\mathcal{R}_1\) będziemy rozumieli najmniejszą (w sensie mnogościowym) relację \(\mathcal{R}_2\) taką, że \(\mathcal{R}_1\subset\mathcal{R}_2\). 
  Z pewnego rodzaju domknięciami, ze względu na ich szczególną rolę, wiążemy następującą notację:  
  \begin{enumerate}[label=(\alph*), ref={(\alph*)}]
    \setlength\itemsep{0em}
    \item Przez \(\mathcal{R}^{+}\) oznaczamy przechodnie domknięcie relacji \(\mathcal{R}\).\label{def:closure_a}
    \item Przez \(\mathcal{R}^{*}\) oznaczamy zwrotnie domknięcie relacji \(\mathcal{R}^{+}\).\label{def:closure_b}
    \item Przez \(=_{\mathcal{R}}\) oznaczamy symetryczne domknięcie relacji \(\mathcal{R}^{*}\).\label{def:closure_c}
\end{enumerate}
Dla lepszego zrozumienia powyższych operacji warto zauważyć, że \ref{def:closure_b} wyznacza praporzadek, który w odniesieniu do redukcji określonych na \(\mathbf{\Lambda}\) można rozumieć jako graf skierowany (w przypadku \(\mathbf{\Lambda}\) być może nieskończony) w którym krawędzie odpowiadają możliwym krokom obliczenia, zaś \ref{def:closure_c} -- kongruencję, która znów w szczególnym odniesieniu do \(\lambda\)-termów, będzie dokonywała podziału w \(\mathbf{\Lambda}\) ze względu na rezultat obliczenia.
\begin{definicja}(Redukcja)
\end{definicja}

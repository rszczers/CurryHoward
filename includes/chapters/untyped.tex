
\section{Rachunek \(\lambda\)}
Niech  \(V\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych \(x,\ y,\ \dots\) (indeksowanych być może liczbami naturalnymi). Elementy takiego zbioru będziemy nazywali \emph{\(\lambda\)-zmiennymi}. Ponieważ \(V\) jest potencjalnie nieskończony, zastrzegamy sobie możliwość wybierania w razie potrzeby wcześniej nie użytej zmiennej.

\begin{definicja}(Zbiór \(\mathbf{\tilde\Lambda}\) pretermów)\label{def:lambda-untyped}
Zbiorem pretermów będziemy nazywali najmniejszy (w sensie mnogościowym) zbiór wyrażeń \(\mathbf{\tilde\Lambda}\) taki, że:
  \begin{enumerate}[label={(P\arabic*)}, ref={(P\arabic*)}]
  \setlength\itemsep{0em}
  \item Jeśli \(x \in V\), to \(x\in\mathbf{\tilde\Lambda}\).\label{pret1}
  \item Jeśli \(M,\,N\in \mathbf{\tilde\Lambda}\), to \((M\,N)\in\mathbf{\tilde\Lambda}\).\label{pret2}
  \item Jeśli \(x\in V\) i \(M\in\mathbf{\tilde\Lambda}\), to \((\lambda x.\,M)\in\mathbf{\tilde\Lambda}\).\label{pret3}
  \end{enumerate}
\end{definicja}
Definicję \ref{def:lambda-untyped} można równoznacznie wyrazić przy pomocy notacji Backusa-Naura. Wówczas ma ona następującą, zwięzłą postać:
\begin{align*}
  \mathbf{\tilde\Lambda}\ \leftarrow \ V\ |\ (\mathbf{\tilde\Lambda}\,\mathbf{\tilde\Lambda}) \ |\ (\lambda V.\, \mathbf{\tilde\Lambda})
\end{align*}

Elementy \(\mathbf{\tilde\Lambda}\) będziemy oznaczali literami \(L,\ M,\ N,\ P,\ Q,\ R\) i ich wariantami z górnymi lub dolnymi indeksami. Wyrażenia postaci \ref{pret2} nazywamy \emph{aplikacjami} \(M\) do \(N\). Symbol \(\lambda\) występujący w \ref{pret3} nazywamy \emph{\(\lambda\)-abstraktorem}, zaś wyrażenia powstałe przez zastosowanie tej reguły to \emph{\(\lambda\)-abstrakcje}. W wyrażeniu postaci \((\lambda x.\,M)\) preterm \(M\) jest w \emph{zasięgu} \(\lambda\)-abstraktora, a zmienna \(x\) jest przez niego \emph{związana}. Ponadto, będziemy stosowali następujące konwencje notacyjne:
\begin{easylist}
  & \emph{najbardziej zewnętrzne nawiasy bedą pomijane,}
  & \emph{aplikacja wiąże lewostronnie; wyrażenia postaci \((PQ)R\) będą zapisywane w postaci \(PQR\),}
  & \emph{\(\lambda\)-abstrakcja wiaże prawostronnie: \(\lambda x_1.\, (\lambda x_2.\,P)\) zapisujemy  \(\lambda x_1.\, \lambda x_2.\,P\),}
  & \emph{następujące po sobie \(\lambda\)-abstrakcje postaci \(\lambda x_1 . \, \lambda x_2 . \, \dots  \lambda x_n .\, P\) zapisujemy pod wspólnym \(\lambda\)-abstraktorem: \(\lambda x_1 \, x_2 \, \dots \, x_n .\, P\).}
\end{easylist}

Powiemy, że dwa \(\lambda\)-termy są \emph{syntaktycznie równe}, jeśli rozumiane jako ciągi znaków są identyczne. Równość syntaktyczną będziemy oznaczali znakiem \(\equiv\).

\begin{przyklad}
  Podajmy kilka przykładów \(\lambda\)-pretermów pogrupowanych ze względu na ich konstrukcję.
  \begin{enumerate}[label={(P\arabic*):}, ref={(P\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x,\ y,\ z\).
    \item \(x\,x,\ y\,x,\ x\,(x\,z)\),\\
          \((\lambda x .\, (x z)) y,\
             y\, (\lambda x .\, (x\, z)),\ (\lambda x .\, x)\,(\lambda x .\, x)\).
    \item \( \lambda x .\, (x \, z),\
             \lambda y z .\, x,\
             \lambda x .\, (\lambda x .\, (x\, x))\).
  \end{enumerate}
\end{przyklad}

 % \begin{konwencja*}
% Przypomnijmy, że \emph{selektorem} w \(V\) nazywamy każdą funkcję \(s:\:\mathcal{P}(V)-\{\emptyset\}\rightarrow V\) taką, że \(s(X)\in X\) dla \(\emptyset\neq X\subseteq V\).


%   Niech \(f:D\to E\) będzie dowolną funkcją i niech \(d\in D,\ e\in E\). Funkcję \(f[x/N]:\:D\to E\) określamy w następujący sposób:
%   \[
%     f[d/e]d' = \begin{cases}
%       e, &\text{jeśli}\ d'\equiv d, \\
%       fd', &\text{w przeciwnym wypadku.}
%     \end{cases}
%   \]
 % \end{konwencja*}

Podwyrażenia \(\lambda\)-pretermu mogą być wzajemnie identyczne i występować wielokrotnie. Obserwację tę ujmuje następująca definicja.
\begin{definicja}(Multizbiór \(\mathrm{Sub}\) podtermów pretermu)\label{def:untyped_subterm}
  \begin{enumerate}[label={(\arabic*)}, ref={(\arabic*)}]
    \setlength\itemsep{0em}
    \item \(\mathrm{Sub}(x)=\{x\}\)
    \item \(\mathrm{Sub}(MN)=\mathrm{Sub}(M)\cup\mathrm{Sub}(N)\cup\{M\,N\}\)
    \item \(\mathrm{Sub}(\lambda x.\, M) = \mathrm{Sub}(M)\cup \{\lambda x.\, M\}\)
  \end{enumerate}
  Elementy multizbioru \(\mathrm{Sub}(M)\) nazywamy \emph{podtermami} \(M\). Jeśli \(L\) jest podtermem \(M\), ale \(L\not\equiv M\), to \(L\) nazywamy podtermem \emph{właściwym}.
\end{definicja}
\begin{przyklad} Podtermy wybranych \(\lambda\)-pretermów.
  \begin{align*}
    \begin{split}
      \mathrm{(a)}\quad & \mathrm{Sub}\left(\lambda x.\,x\, x\right)=\left\{\left(\lambda x.\,x\, x\right)^1,\  \left(x\, x\right)^1,\ x^2\right\}\\
       \mathrm{(b)}\quad & \mathrm{Sub}\left(\left(\lambda x .\, x\, x\right)\,\left(\lambda x .\, x\, x\right)\right) = \\
    & = \left\{((\lambda x .\, x\, x)\,(\lambda x .\, x\, x))^{1}, \ (\lambda x .\, x\, x)^2,\ (x\,x)^{2},\ x^{4}\right\}\\
  \end{split}
  \end{align*}
  W powyższych przykładach użyliśmy standardowej notacji w górnym indeksie umieszczając krotność występowania elementu.
\end{przyklad}
\begin{definicja}(Zbiór \(\mathrm{FV}\) zmiennych wolnych)\label{def:untyped_fv}
  Dla dowolnego pretermu \(M\) określamy zbiór \(\mathrm{FV}(M)\) \emph{zmiennych wolnych} w \(M\) w następujący sposób:
\begin{align*}
    \mathrm{FV}(x) &= \{x\}\\
    \mathrm{FV}(\lambda x .\, P)  &= \mathrm{FV}(P)\setminus\{x\}\\
    \mathrm{FV}(P Q) &= \mathrm{FV}(P)\cup\mathrm{FV}(Q)
\end{align*}
  Jesli \(\mathrm{FV}(M)=\emptyset\), to mówimy, że \(M\) jest \emph{domknięty} lub nazywamy \(M\) \emph{kombinatorem}.
\end{definicja}
\begin{przyklad}
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item \(\mathrm{FV}(\lambda x.\,x\,y)=\left\{y\right\}\)
    \item \(\mathrm{FV}(x\,(\lambda x.\, x\,y)) = \left\{x,\ y\right\}\)
    \item \(\mathrm{FV}(\lambda x y z.\, x y) = \emptyset\)
  \end{enumerate}
\end{przyklad}


\begin{definicja}(Podstawienie)\label{def:substitution}
  Dla dowolnych \(\mathrm{M,\,N}\in\mathbf{\tilde\Lambda}\) i \(x\in V\) przez \(N[x/N]\) oznaczamy rezultat podstawienia termu \(N\) za wszystkie wolne wystąpienia zmiennej \(x\) w \(M\), o ile w rezultacie podstawienia nie zostaną związane żadne zmienne wolne występujące w \(N\). W takim wypadku:
  \begin{enumerate}[label={(S\arabic*)}, ref={(S\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x[x/N] = N\)
    \item \(y[x/N] = y,\ \text{o ile}\ x\not\equiv y\)
    \item \((PQ)[x/N] = P[x/N]\,Q[x/N]\)\label{def:substitution_c}
    \item \((\lambda y.\, P)[x/N] = \lambda y.\,P[x/N],\ \text{gdzie}\ x\not\equiv y\ \text{i}\ y\not\in \mathrm{FV}(N)\)
    \item \((\lambda x.\, P)[x/N] = \lambda x.\,P\)\label{def:substitution_e}
  \end{enumerate}
\end{definicja}

\begin{lemat}(O podstawieniu)\label{lem:substitution}
  Niech \(M,\,N,\,L\in \mathbf{\tilde\Lambda}\) i niech ponadto \(x\not\equiv y\) oraz \(x\not\in\mathrm{FV}(L)\). Wówczas
  \begin{align}\label{eq:substitution}
    M[x/N][y/L]\equiv M[y/L]\left[x/N\left[y/L\right]\right].
  \end{align}
  \begin{dowod}
    Dowód przebiega przez indukcję strukturalną względem \(M\). Rozważmy następujące przypadki:
    \begin{enumerate}[label={\roman*)}, ref={(\arabic*)}]
      \item \(M\) jest zmienną. Wówczas:
        \begin{enumerate}[label={\alph*.}]
        \item Jeśli \(M\equiv x\), to obie strony \eqref{eq:substitution} po podstawieniu są postaci \(N[y/L]\).
        \item Jeśli \(M\equiv y\), to ponieważ \(x\not\equiv y\) i \(x\not\in\mathrm{FV}(M)\), po wykonaniu podstawienia po lewej stronie \eqref{lem:substitution} otrzymujemy \(M[x/N][y/L]\equiv L\). Ponieważ \(x\not\in\mathrm{FV}(L)\), to po wykonaniu podstawienia po prawej stronie widzimy, że obydwie strony są identyczne.

        \item Jeśli \(M\equiv z\) i \(z\not\equiv x\)  oraz \(z\not\equiv y\), to obydwie strony \eqref{eq:substitution} sa identyczne.
        \end{enumerate}

      \item \(M\equiv P Q\) dla pewnych \(P,\,Q\in\mathbf{\tilde\Lambda}\). Wówczas korzystając z hipotezy indukcyjnej wnosimy, że
        \begin{align*}
          P[x/N][y/L]\equiv P[y/L]\left[x/N\left[y/L\right]\right],\\
          Q[x/N][y/L]\equiv Q[y/L]\left[x/N\left[y/L\right]\right].
        \end{align*}
        Mając na względzie \ref{def:substitution_c} widzimy, że twierdzenie zachodzi i w tym przypadku.
        \item Jeśli \(M\equiv \lambda z.\,P\) oraz \(z\equiv x\) lub \(z\equiv y\), to z \ref{def:substitution_e} widzimy, że obydwie strony \eqref{eq:substitution} sa identyczne. Przypuśćmy, że \(z\not\equiv x\) i \(z\not\equiv y\) i \(z\not\in\mathrm{FV}(L)\). Wówczas na podstawie hipotezy indukcyjnej mamy:
      \begin{align*}
        (\lambda z.\,P)[x/N][y/L] &= \lambda z.\,P[x/N][y/L] =\\
                                  &= \lambda z.\,P[y/L][x/N[y/L]] =\\
                                  &= (\lambda z.\,P)[y/L][x/N[y/L]].
      \end{align*}
    \qed
    \end{enumerate}
  \end{dowod}
\end{lemat}

\begin{wniosek}\label{thm:odwracalnosc_podstawienia}
Jesli \(M[x/y]\) jest określone i \(y\not\in\mathrm{FV}(M)\), to \(M[x/y][y/x]\) jest określone oraz
  \(M[x/y][y/x]=M\).
  \begin{dowod}
    Mając na uwadze Lemat \ref{def:substitution} dowód przebiega przez indukcję strukturalną względem \(M\).
    \qed
  \end{dowod}
\end{wniosek}



\subsection{Wyrażenia \(\lambda\)}
Na ogół chcielibyśmy utożsamiać pretermy, które różnią się wyłącznie zmiennymi związanymi, tak jak w przypadku wyrażeń \(\lambda x. \,zx\) i \(\lambda y.zy\). W takim wypadku powiemy o nich, że są swoimi \emph{\(\alpha\)-wariantami} lub że są ze sobą w relacji \emph{\(\alpha\)-konwersji}.

\begin{definicja}(Relacja \(\alpha\)-konwersji)\label{def:untyped_alpha}
  Relacją \(=_{\alpha}\) (\(\alpha\)-konwersji) nazywamy najmniejszy w sensie mnogościowym praporządek na \(\mathbf{\tilde\Lambda}\) taki, że
  \begin{enumerate}[label={(\(\alpha\)\arabic*)}, ref={(\(\alpha\)\arabic*)}]
  \setlength\itemsep{0em}
  \item Jeśli \(y\not\in \mathrm{FV}(M)\) oraz \(M[x/y]\) jest określone,\\ to \(\lambda x.\,M~=_{\alpha}~\lambda y.\,M[x/y]\)\label{def:alpha_1}
  \item Jeśli \(M=_{\alpha} N\), to dla dowolnego \(x\in V\) zachodzi \(\lambda x.\,M =_{\alpha} \lambda x.\,N\)\label{def:alpha_2}
  \item Jeśli \(M=_{\alpha} N\), to dla dowolnego \(Z\in\mathbf{\tilde\Lambda}\) zachodzi \(MZ =_{\alpha} NZ\)\label{def:alpha_3}
  \item Jeśli \(M=_{\alpha} N\), to dla dowolnego \(Z\in\mathbf{\tilde\Lambda}\) zachodzi \(ZM =_{\alpha} ZN\)\label{def:alpha_4}
  \end{enumerate}
\end{definicja}

\begin{przyklad}
  \begin{align*}
    \lambda x y.\,x(xy) &\equiv \lambda x.\,(\lambda y.\,x(xy)) \\
                        &\equiv_\alpha \lambda x.\,(\lambda z.\,x(xz)) \\
                        &\equiv_\alpha \lambda v.\,(\lambda z.\,v(vz)) \\
                        &\equiv \lambda vz.\,v(vz).
  \end{align*}

\end{przyklad}

\begin{wniosek}
  Relacja \(=_{\alpha}\) jest relacją równoważności.
  \begin{dowod}
    Wystarczy, że pokażemy, że relacja \(=_{\alpha}\) jest symetryczna. Dowód przebiega przez indukcję względem Definicji \ref{def:untyped_alpha}. Rozważmy następujące przypadki:
    %Fakt \ref{def:odwracalnosc_podstawienia}

    \begin{enumerate}[label={\roman*)}, ref={(\roman*)}]
      \item Jeśli \(M=_{\alpha} N\) w konsekwencji zwrotności \(=_{\alpha}\), to \(M\equiv N\), a zatem również \(N\equiv M\). Stąd \(N=_{\alpha} M\).
      \item Jeśli \(M=_{\alpha} N\) w konsekwencji przechodniości \(=_{\alpha}\), to istnieje \(L\in\mathbf{\tilde\Lambda}\) takie, że \(M=_{\alpha}L\) i \(L=_{\alpha}N\). Wówczas z hipotezy indukcyjnej \(N=_{\alpha}L\) i \(L=_{\alpha}M\). Z przechodniości relacji \(=_{\alpha}\) otrzymujemy spodziewaną tezę.
      \item Przypuśćmy, że \(M=_{\alpha} N\) w konsekwencji  \ref{def:alpha_1}  dla \(M\equiv\lambda x.\,M'\) i \(N\equiv\lambda y.\,M'[x/y]\). Ponieważ \(x\not\in\mathrm{FV}(M'[x/y])\), to ze względu na Wniosek \ref{thm:odwracalnosc_podstawienia} mamy, że \(M'[x/y][y/x]=M'\). Zatem, na podstawie \ref{def:alpha_1}:
  \begin{align*}
        \lambda y.\,M'[x/y] =_{\alpha} \lambda x.\,M'[x/y][y/x].
      \end{align*}
    \item  Jeśli \(M=_{\alpha} N\) w konsekwencji \ref{def:alpha_2}, gdzie \(M=\lambda x.\,M'\) i \(N=\lambda x.\,N'\) dla \(M'=_{\alpha} N'\), to z hipotezy indukcyjnej \(N' =_{\alpha} M'\) i w konsekwencji \ref{def:alpha_2} mamy, że \(N=_{\alpha} M\).
    \item  Jeśli \(M=_{\alpha} N\) w konsekwencji \ref{def:alpha_3} dla \(M\equiv M'Z\) i \(N\equiv N'Z\) takich, że \(M'=_{\alpha}N'\), to z hipotezy indukcyjnej oczywiście \(N'=_{\alpha}M'\), a zatem z \ref{def:alpha_3} \(N=_{\alpha} M\).\label{proof:alpha_cases_4}
    \item  Jeśli \(M=_{\alpha} N\) w konsekwencji \ref{def:alpha_3}, to postępujemy jak w przypadku \ref{proof:alpha_cases_4}.\qed
    \end{enumerate}
  \end{dowod}
\end{wniosek}

\begin{definicja}(Zbiór \(\mathbf{\Lambda}\) \(\lambda\)-termów)
  Każdą klasę abstrakcji relacji \(=_{\alpha}\) nazywamy \(\lambda\)-termem. Zbiór wszystkich \(\lambda\)-termów \(\mathbf{\Lambda}\) to zbiór ilorazowy relacji \(\alpha\)-konwersji:
  \begin{align*}
    \mathbf{\Lambda}=\left\{[M]_{=_\alpha}\ |\ M\in\mathbf{\tilde\Lambda}\right\}
  \end{align*}
\end{definicja}

\begin{konwencja*}
Wprowadzamy następujące konwencje notacyjne:
\begin{align*}
  &x = [x]_{=_\alpha},\\
  &PQ = [M'N']_{=_\alpha},\ \text{gdzie}\ M=[M']_{=_\alpha}\ \text{i}\ N=[N']_{=_\alpha},\\
  &\lambda x.\,M =  [\lambda x.\,M']_{=_\alpha},\  \text{gdzie}\ N=[N']_{=_\alpha}.
\end{align*}
\end{konwencja*}
%Nie prowadzą one do niejednoznaczności, w czym upewnia nas Lemat \ref{lem:uniqueness}.

%\begin{lemat}(O jednoznaczności)\label{lem:uniqueness}
%  Dla dowolnych \(M,\,N
%\end{lemat}

Na zbiór \(\mathbf{\Lambda}\) przenoszą się pojęcia podtermu, zmiennych wolnych i operacji podstawienia definiowane uprzednio dla pretermów.

\begin{definicja}(Multizbiór \(\mathrm{Sub}\) podtermów \(\lambda\)-termu)
  Dla dowolnego \(\lambda\)-termu \(M=[M']_{=_{\alpha}}\) okreslamy
  \[
    \mathrm{Sub}(M)=\mathrm{Sub}(M'),
  \]
  gdzie \(\mathrm{Sub}(M')\) jest multizbiorem podwyrażeń pretermu \(M'\) zdefiniowanym w myśl Definicji \ref{def:untyped_subterm}.
\end{definicja}

\begin{definicja}(Zbiór zmiennych wolnych \(\mathrm{FV}\))
  Dla dowolnego \(\lambda\)-termu \(M=[M']_{=_{\alpha}}\) określamy zbiór \(\mathrm{FV}(M)\) \emph{zmiennych wolnych} w \(M\)
  \[
    \mathrm{FV}(M)=\mathrm{FV}(M'),
  \]
  gdzie \(\mathrm{FV}(M')\) jest zbiorem zmiennych wolnych pretermu \(M'\) zdefiniowanym w myśl Definicji \ref{def:untyped_fv}.
\end{definicja}

\begin{definicja}(Podstawienie)\label{def:untyped_lambda_substitution}
  Niech \(M=[M']_{=_\alpha}\) i \(N=[N']_{=_\alpha}\) i niech \(M'[x/N']\) będzie określone w myśl Definicji \ref{def:substitution}. Wówczas
  \[
    M[x/N]= [M'[x/N']]_{=_\alpha}.
  \]
\end{definicja}

Operacja podstawienia wymaga jednak pewnej delikatności. Rozważmy następującą relację:
\[
  \lambda x.\,zx=_{\alpha}\lambda y.\,zy
\]
Zauważmy, że traktując podstawienie w sposób naiwny, mamy, że \((\lambda x.\,zx)[z/x]\neq_{\alpha}(\lambda y.\,zy)[z/x]\), a więc tracimy pożądaną własność niezmienniczości \(\alpha\)-konwersji względem podstawienia. Stąd w Definicji \ref{def:substitution} wymóg, aby podstawienie nie prowadziło do uszczuplenia zbioru zmiennych wolnych. Alternatywnym rozwiązaniem jest określenie podstawienia, które wprowadzałoby do wyrażenia nową zmienną i prowadziło w konsekwencji do abstrahowania po wcześniej nie występujacych zmiennych:
\[
  (\lambda x.\,M)[y/N] = \lambda x'.\,M[x/x'][y/N],
\]
w przypadku, gdy \(x\not\equiv y\), gdzie \(x'\not\in\mathrm{FV}(M)\) i \(x'\not\in\mathrm{FV}(N)\). Rozstrzygnięcie takie przytacza się w \cite{Hindley:2008:LCI:1388400,}. Po uwzględneniu odpowiednich modyfikacji, Definicja \ref{def:substitution} przyjmuje następującą postać:
\begin{customdef}{4'}(Podstawienie')\label{def:untyped_substitution_hindley}
  \begin{enumerate}[label={(S'\arabic*)}, ref={(S'\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x[x/N] = N\)
    \item \(y[x/N] = y,\ \text{o ile}\ x\not\equiv y\)
    \item \((PQ)[x/N] = P[x/N]\,Q[x/N]\)
    \item \((\lambda x.\, P)[x/N] = \lambda x.\,P\)
    \item \((\lambda y.\, P)[x/N] = \lambda y.\,P\), jeśli \(x\not\in\mathrm{FV}(P)\)\label{def:substitution_e}\label{def:substitution_hindley_e}
    \item \((\lambda y.\, P)[x/N] = \lambda y.\,P[x/N],\ \text{gdzie}\ x\in\mathrm{FV}(P)\) i \(y\not\in\mathrm{FV}(N)\)\label{def:substitution_hindley_f}
    \item \((\lambda y.\, P)[x/N] = \lambda z.\,P[y/z][x/N],\ \text{gdzie}\ x\in\mathrm{FV}(P)\) i \(y\in\mathrm{FV}(N)\)\label{def:substitution_hindley_g}
  \end{enumerate}
  przy czym w \ref{def:substitution_hindley_g} wymagamy, aby zmienna \(z\) nie występowała wcześniej w termach \(N\) i \(P\) jako zmienna wolna, zaś dla \ref{def:substitution_hindley_e}-\ref{def:substitution_hindley_g} dodatkowo \(y\not\equiv x\).
\end{customdef}
\begin{uwaga}
Każde podstawienie \([x/N]\) jest funkcją z \(\mathbf{\Lambda}\to\mathbf{\Lambda}\), gdzie \(x\in V\) i \(N\in\mathbf{\Lambda}\) są dowolnymi parametrami. Zbiór \(S\) podstawień ma strukturę monoidu z działaniem składania
  \begin{align*}
    M([x_2/N_2]\circ[x_1/N_1]) = (M[x_1/N_1])[x_2/N_2] \equiv M[x_1/N_1][x_2/N_2]
  \end{align*}
  dla dowolnych \([x_1/N_1],\,[x_2/N_2]\in S\), o ile \(S\) posiada element neutralny \(\iota\) taki, że
  \begin{align*}
    M \iota = M,\ \text{gdzie}\ [x/x]=\iota\ \text{dla dowolnego}\ x\in V.
  \end{align*}
\end{uwaga}

W literaturze znajdujemy mnogość propozycji, które w ten czy inny sposób starają się ułatwić rzeczywistą implementację podstawienia. Na szczególną uwagę zasługują tutaj tak zwane \emph{indeksy de Bruijna}. Zaproponowana przez N. G. de Brujina w \cite{deBruijnIndices}  notacja eliminuje bezpośrednie występowanie symboli zmiennych w \(\lambda\)-termach, zastępując je liczbą naturalną wyrażającą głębokość zagnieżdżenia odpowiedniej \(\lambda\)-abstrakcji przez którą jest związana, przykładowo:
\[
  \lambda f.\,(\lambda x.\,(f(xx))\lambda x.\,(f(xx))) \equiv_{de Brujin} \lambda (\lambda 2 (1 1)) \lambda 2 (1 1)
\]
Historycznie wiąże się ta notacja z jego pracami nad systemem komputerowo wspomaganego dowodzenia twierdzeń AUTOMATH. Rozwiązanie takie, podobnie jak w przypadku tzw. logik kombinatorów, eliminuje konieczność utożsamiania termów przez \(\alpha\)-konwersję, ale istotnie zmniejsza ich czytelność.

Szerszy komentarz dotyczący dotychczasowych prób uchwycenia operacji podstawienia można prześledzić w \cite{txa:alpha-draft}. Nasze rozważania opierają się w tej materii przeważająco na \cite{Urzyczyn2006}. Samo podejście do definiowania \(\lambda\)-termow przez operację \(\alpha\)-konwersji nie jest powszechne w literaturze przedmiotu. Analogiczną konstrukcję należałoby powtarzać wprowadzając każdy kolejny system, dlatego w dalszej części tej pracy będziemy poprzestawali na nieformalnym traktowaniu wyrażeń danego systemu jako odpowiednich klas \(\alpha\)-konwersji.

% \subsection{Podstawienie jednoczesne}
% Biorąc pod uwagę sens obliczeniowy rachunku \(\lambda\) interesujące okazuje się modyfikacja Definicji \ref{def:untyped_substitution_hindley} w  taki sposób, aby podstawienie miało miejsce dla wielu zmiennych równolegle w całym \(\lambda\)-termie. Za przykładem \cite{STOUGHTON1988317} wprowadzimy \emph{podstawienie jednoczesne}. W tym celu jednak uściślenia wymagają pewne pojęcia.

\begin{definicja}(Podstawienie jednoczesne)\label{def:simult_substitution}
Dla dowolnego \(M\in\mathbf{\Lambda}\), ciągu \(\lambda\)-zmiennych~\(\vec{x}\) i ciągu \(\lambda\)-termów \(\vec{N}\) określamy:
  \begin{enumerate}[label={(\(\vec{s}\)\arabic*)}, ref={(\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x_i[\vec{x}/\vec{N}]=N_i\) dla \(i\in\mathbb{N}\).
    \item \(y[\vec{x}/\vec{N}]=y\) o ile dla dowolnego \(i\in\mathbb{N},\ y\not\equiv x_i\).
    \item \((PQ)[\vec{x}/\vec{N}]=P[\vec{x}/\vec{N}]Q[\vec{x}/\vec{N}]\)
%    \item \((\lambda y.\,P)[\vec{x}/\vec{N}]=\lambda y'.\,P[y/y'][\vec{x}/\vec{N}]\), gdzie \(y'\) jest wcześniej nie występującą zmienną, \(y\not\equiv x_i\)  dla wszystkich \(i\in\mathbb{N}\) i \(y\not\in\bigcup_{i\in\mathbb{N}}FV(N_i)\).
    \item \((\lambda y.\,P)[\vec{x}/\vec{N}]=\lambda y.\,P[\vec{x}/\vec{N}]\), jeśli \(y\neq x_i\) dla wszystkich \(i\in\mathbb{N}\) i \(y\not\in\bigcup_{i\in\mathbb{N}}FV(N_i)\)
 \end{enumerate}
\end{definicja}

\begin{konwencja*}
  Jeśli \(N_i\equiv x_i\) dla wszystkich poza skończenie wieloma \(i_1,\,i_2,\,\dots,\,i_n\in~\mathbb{N}\), to \([x_{i_1}/N_{i_1},\,x_{i_2}/N_{i_2},\,\dots,\,x_{i_n}/N_{i_n}]\equiv [\vec{x}/\vec{N}]\).
\end{konwencja*}

\begin{przyklad}
  Zauważmy, że podstawienia w myśl Definicji \ref{def:substitution} i Definicji \ref{def:simult_substitution} mogą, ale nie muszą, prowadzić do różnych rezultatów.
\begin{align*}
  \text{a)}\quad &  (xy)[y/x][x/u] = uu, &\quad\text{b)}\quad & (\lambda x.\,yx)[x/y][y/z]=\lambda x.\,zx, \\
                &  (xy)[y/x, x/u] = ux. & &(\lambda x.\,yx)[x/y,y/z]=\lambda x.\,zx.\\
\end{align*}

\end{przyklad}
\subsection{Redukcja}
Sens obliczeniowy \(\lambda\)-termom nadajemy przez określenie na \(\mathbf{\Lambda}\) operacji \(\beta\)- i \(\eta\)-redukcji. Pożądane jest, żeby operacje te wykonywane na podtermach pozostowały w \emph{zgodzie} ze strukturą całego \(\lambda\)-termu.

\begin{definicja}(Relacja zgodna)
  Relację binarną \(\mathcal{R}\) na zbiorze \(\mathbf{\Lambda}\) nazywamy \emph{zgodną}, jeśli dla dowolnych \(M,\,N,\,P \in \mathbf{\Lambda}\) zachodzą następujące warunki:
  \begin{enumerate}[label={(c\arabic*)}, ref={(\arabic*)}]
    \setlength\itemsep{0em}
    \item Jeśli \(M \mathcal{R} N\), to \((\lambda x.\,M)\,\mathcal{R}\,(\lambda x.\,N)\) dla dowolnej \(\lambda\)-zmiennej \(x\).
    \item Jeśli \(M \mathcal{R} N\), to \((MP)\,\mathcal{R}\,(NP)\).
    \item Jeśli \(M \mathcal{R} N\), to \((PM)\,\mathcal{R}\,(PN)\).
  \end{enumerate}
\end{definicja}
Przez \emph{domknięcie relacji} \(\mathcal{R}_1\) będziemy rozumieli najmniejszą (w sensie mnogościowym) relację \(\mathcal{R}_2\) taką, że \(\mathcal{R}_1\subset\mathcal{R}_2\).
  Z pewnego rodzaju domknięciami, ze względu na ich szczególną rolę, wiążemy następującą notację:
  \begin{enumerate}[label=(\alph*), ref={(\alph*)}]
    \setlength\itemsep{0em}
    \item Przez \(\mathcal{R}^{+}\) oznaczamy przechodnie domknięcie relacji \(\mathcal{R}\).\label{def:closure_a}
    \item Przez \(\mathcal{R}^{*}\) oznaczamy zwrotnie domknięcie relacji \(\mathcal{R}^{+}\).\label{def:closure_b}
    \item Przez \(=_{\mathcal{R}}\) oznaczamy symetryczne domknięcie relacji \(\mathcal{R}^{*}\).\label{def:closure_c}
\end{enumerate}
Dla lepszego zrozumienia powyższych operacji warto zauważyć, że \ref{def:closure_b} wyznacza praporzadek, który w odniesieniu do redukcji określonych na \(\mathbf{\Lambda}\) można rozumieć jako graf skierowany (w przypadku \(\mathbf{\Lambda}\) być może nieskończony) w którym krawędzie odpowiadają możliwym krokom obliczenia, zaś \ref{def:closure_c} -- kongruencję, która znów w szczególnym odniesieniu do \(\lambda\)-termów, będzie dokonywała podziału w \(\mathbf{\Lambda}\) ze względu na rezultat obliczenia.
\begin{definicja}(\(\beta\)-redukcja)
  \(\beta\)-redukcją nazywamy najmniejszą (w sensie mnogościowym) zgodną na \(\mathbf{\Lambda}\) relację binarną \(\to_\beta\) taką, że
  \[
    (\lambda x.\,M)N\rightarrow_\beta M[x/N].
  \]
\emph{\(\beta\)-redeksami} bedziemy nazywali wyrażenia postaci \((\lambda x.\, M)N\), zaś rezultat ich \(\beta\)-redukcji w postaci termu \(M[x/N]\) -- \emph{\(\beta\)-reduktem}. \emph{Ciągiem} \(\beta\)-redukcji nazywamy skończony lub nieskończony ciąg postaci
  \[
    M_0 \to_\beta M_1 \to_\beta \dots
  \]
\end{definicja}
  \begin{przyklad}Oznaczmy \(\mathrm{Y}=\lambda f.\,(\lambda x.\,(f(xx))\lambda x.\,(f(xx)))\) i niech \(F\) będzie dowolnym \(\lambda\)-termem. Wówczas otrzymujemy nieskończony ciąg redukcji postaci
    \begin{align*}
      \mathrm{Y}F &\equiv (\lambda f.\,(\lambda x.\,(f(xx))\lambda x.\,(f(xx))))F\\
                  &\to_\beta (\lambda x.\,F(xx))\lambda x.\,F(xx)\\
                  &\to_\beta F((\lambda x.\,F(xx))\lambda x.\,F(xx))\\
                  &\to_\beta F(F((\lambda x.\,F(xx))\lambda x.\,F(xx)))\\
                  &\to_\beta \dots
    \end{align*}
  \end{przyklad}
\begin{definicja}(\(\eta\)-redukcja)
  \(\eta\)-redukcją nazywamy najmniejszą (w sensie mnogościowym) zgodną na \(\mathbf{\Lambda}\) relację binarną \(\to_\eta\) taką, że
  \[
    \lambda x.\,Mx\to_\eta M,\ \text{o ile}\ x\not\in \mathrm{FV}(M).
  \]

  \(\eta\)-redukcja pozwala na pominięcie niczego nie wnoszącej \(\lambda\)-abstrakcji. Operację odwrotną nazywamy \emph{\(\eta\)-abstrakcją}, zaś \(\lambda\)-termy będące w którejkolwiek z tych relacji nazywamy \emph{\(\eta\)-konwersami}. Operacja ta nie ma wpływu na rezultat obliczenia, jedynie optymializuje zapis \(\lambda\)-termów i stąd ma duże znaczenie stylistyczne w programowaniu funkcyjnym.
  \end{definicja}

  \begin{przyklad}
    \(\lambda x. ((+1) x) =_\eta (+1) \).
  \end{przyklad}

  \subsection{Kodowanie typów danych}
Prosta składnia języka rachunku \(\lambda\) pozwala wyrazić zaskakująco wiele struktur danych reprezentując je i operacje na nich jako funkcje. Z tego powodu, stanowiąc inspirację dla wielu projektantów języków programowania, uchodzi za protoplastę rodziny języków funkcyjnych, chociaż bezpośrednio nie ma on praktycznego zastosowania w praktyce programistycznej. Rozwój tej legendy dobrze oddaje cykl klasycznych artykułów (tzw. \emph{Lambda Papers}) zapoczątkowany przez dokumentację języka Scheme \cite{Sussman:1975:IEL:889230}.

Najpopularniejszym sposobem reprezentacji danych przez funkcje w rachunku \(\lambda\) oparty jest na kodowaniu liczb Peano za pomocą tzw. liczebników Churcha. Metoda ta, ze względu na wynikające zeń problemy natury złożonościowej \cite{Koopman:2014:CED:2746325.2746330}, ma obecnie wyłącznie walory edukacyjne, dlatego w dalszej cześci pracy pokażemy tzw. kodowanie Scotta. Jest ona interesująca ze względu na praktyczną możliwość reprezentacji algebraicznych typów danych (ADT\footnote{Skrót od angielskojęzycznego \emph{Algebraic Data Types}; nie należy mylić z \emph{Abstract Data Types}.}) znanych ze współczesnych języków funkcyjnych \cite{Jansen:2013:P9C:2941698.2941710}, pozwalając tym samym zaimplementować te konstrukcje na przykład w paradygmacie imperatywnym. Fakt, że każdy typ danych można zastąpić tym sposobem odpowiadającą mu funkcją, wskazuje na metodę konstruowania prostych języków funkcyjnych, ale przede wszystkim na uniwersalność rachunku \(\lambda\) jako języka przejściowego dla kompilatorów języków wysokiego poziomu \cite[Rozdział 3]{PeytonJones:1992:IFL:129390}.

\subsubsection{Algebraiczne typy danych}
Algebraiczne typy danych są podstawowym środkiem współczesnych języków funkcyjnych do wyrażania struktur danych. Powstają one przy użyciu tzw. typów sumacyjnych i typów produktowych, jednak pojęcia te na gruncie formalnym będą szczegółowo omówione w późniejszej części pracy. Na potrzeby prezentacji poszczególnych kodowań wystarczą nam w tym rozdziale intuicje o ADT zbudowane na gruncie następujących definicji w języku Haskell:

\begin{minted}{haskell}
  data Boolean     = True
                   | False
  data Tuple a b   = Tuple a b
  data Temperature = Fahrenheit Int
                   | Celsius Int
  data Maybe a     = Nothing
                   | Just a
  data Nat         = Zero
                   | Suc Nat
  data List t      = Nil
                   | Cons t (List t)
\end{minted}
Definicja typu rozpoczynają się od słowa kluczowego \texttt{data}\footnote{Dyskusja ta ma na celu wyłącznie ustalenie uwagi; świadomi jesteśmy niuansów związanych z określaniem synonimów typów lub definiowaniem typów przy pomocy słowa kluczowego \texttt{newtype}.} po którym występuje \emph{konstruktor typu}. Na wzór notacji BNF, typy przyjmują jedną z \emph{wartości} odzielonych znakiem "|". Każda z wartości składa się z \emph{konstruktora wartości} i ewentualnie występujących po nim \emph{parametrów typowych}. Zauważmy, że umożliwia to rekurencyjnie konstruowanie typów, tak jak w wypadku \texttt{Nat} i \texttt{List}.

Pokażemy, że algebraiczne typy danych możemy reprezentować w zwięzły sposób w rachunku \(\lambda\) bez typów. Przedstawione tutaj koncepcje w zaskakujący sposób przenoszą się do bardziej złożonych typowanych systemów rachunku \(\lambda\).

\subsubsection{Proste typy wyliczeniowe}\label{ref:untyped_simple_enumeration}
Typy wyliczeniowe to typy, które reprezentują możliwe warianty przyjmowanej wartości. Najprostrzym nietrywialnym przykładem takiego typu jest \texttt{Boolean}. Ma on dwa konstruktory wartości: \texttt{True}, \texttt{False}. Praca z tego rodzaju typami wymaga mechanizmu dopasowywania wzorców (ang. \emph{pattern-matching}), który pozwala na wybór częściowej definicji funkcji w zależności od zadanego konstruktora wartości. Ponieważ w rachunku \(\lambda\) wyrażenia nie mają typów (lub, przyjmując perspektywę systemów z typami: wszystkie wyrażenia mają jeden, ten sam typ), interesowało nas będzie nie bezpośrednie kodowanie typu, ale kodowanie mechanizmu, który odpowiada za dopasowywanie wzorców. Posłużmy się znowu przykładem z języka Haskell i określmy funkcję odpowiadającą wykonaniu instrukcji warunkowej:
\begin{minted}{haskell}
if True  a b = a
if False a b = b
\end{minted}
gdzie \texttt{True} i \texttt{False} są wartościami typu \texttt{Boolean}. Właśnie ze względu na nie, mechanizm dopasowywania wzorca wybiera odpowiednią implementację instrukcji warunkowej. Ten sam efekt osiągnęlibyśmy kodując \texttt{True} i \texttt{False} w rachunku \(\lambda\) w następujący sposób:
\begin{align*}
  \mathrm{True} &\equiv \lambda a b.\,a\\
  \mathrm{False} &\equiv \lambda a b.\,b
\end{align*}
Wówczas funkcję \texttt{if} możemy reprezentować wyrażeniem \(\mathrm{if}\equiv\lambda c t e.\, cte\) lub jego \(\eta\)-reduktem: \(\lambda c.\,c\).
\subsubsection{Pary w rachunku \(\lambda\)}
Parą nazywamy każdy nierekurencyjny typ, który posiada jeden konstruktor wartości parametryzowany przez dwa typy. W takim wypadku potrzebujemy dwóch projekcji zwracających odpowiednio pierwszy i drugi element pary. Przykładem takiego typu jest \texttt{Tuple}. Mamy wówczas:
\begin{minted}{haskell}
  fst (Tuple a b) = a
  snd (Tuple a b) = b
\end{minted}
Tego rodzaju typy możemy reprezentować przez tak zwane \emph{domknięcie} (ang. \emph{closure}), czyli cześciową aplikację termu. Standardowym sposobem reprezentacji pary w rachunku \(\lambda\) jest:
\begin{align*}
  \mathrm{Tuple}\equiv\lambda a b f .\,f a b
\end{align*}
Aplikując \(\mathrm{Tuple}\) tylko do dwóch termów (\emph{domykając} term Tuple) otrzymujemy reprezentację pary. Pozostały, trzeci argument \(f\) nazywamy \emph{kontynuacją}, gdyż aplikując \((\mathrm{Tuple}\ x\ y)\) dla dowolnych \(x, y\in\mathbf{\Lambda}\) do pewnego \(f\in\mathbf{\Lambda}\), w konsekwencji \(x\) i \(y\) zostają zaaplikowane do \(f\).
Zauważmy, że wówczas reprezentacja \texttt{fst} i \texttt{snd} ma postać:
\begin{align*}
  \mathrm{fst} \equiv \lambda t.\,t(\lambda a b.\,a) \\
  \mathrm{snd} \equiv \lambda t.\,t(\lambda a b.\,b)
\end{align*}

\begin{przyklad}
  Wprowadzone konstrukcje pozwalają nam na definicję skończonych (w sensie liczby konstruktorów) typów. Rozważmy następujące przykłady:
  \begin{enumerate}[label=\alph*)]
    \setlength\itemsep{0em}
    \item Konstruktory wartości typu \texttt{Maybe} możemy reprezentować przez
      \begin{align*}
        \mathrm{Nothing}&\equiv \lambda nj.\,n\\
        \mathrm{Just}&\equiv \lambda anj.\,j a
      \end{align*}
      Rozważmy następującą funkcję:
      \begin{minted}{haskell}
        maybe :: b -> (a -> b) -> Maybe a -> b
        maybe n _ Nothing  = n
        maybe _ f (Just x) = f x
      \end{minted}
      Odpowiadająca jej reprezentacja to
      \begin{align*}
        \mathrm{maybe} \equiv \lambda b f t.\, tb(\lambda a.\,fa)
      \end{align*}
    \item Rozważmy następującą funkcję
      \begin{minted}{haskell}
        fromTemperature :: Temperature -> Int
        fromTemperature (Fahrenheit a) = a
        fromTemperature (Celsius a) = a
      \end{minted}
      Ustalając reprezentację konstruktorów \texttt{Fahrenheit} i \texttt{Celsius}:
      \begin{align*}
        \mathrm{Fahrenheit}\equiv \lambda tfc.\,ft\\
        \mathrm{Celsius}\equiv \lambda tfc.\,ct
      \end{align*}
      otrzymujemy reprezentację funkcji \texttt{formTemperature} postaci:
      \begin{align*}
        \mathrm{fromTemperature}\equiv\lambda t.\,t(\lambda f.\,f)(\lambda c.\,c)
      \end{align*}
  \end{enumerate}
\end{przyklad}

\subsubsection{Kodowanie rekurencji}
 Rozważmy następującą funkcję dodawania liczb Peano w języku Haskell:
\begin{minted}{haskell}
  add Zero     m = m
  add (Succ n) m = Succ (add n m)
\end{minted}
Funkcję tę możemy wyrazić w rachunku \(\lambda\) przy pomocy kodowania Scotta w następujący sposób:
\begin{align*}
  \mathrm{add_0} \equiv \lambda n m.\:n\,m\,(\lambda n.\:\mathrm{Succ}(\mathrm{add_0}\,n\,m))
\end{align*}
Formalizm rachunku \(\lambda\) nie pozwala na okreslanie nowych nazw i rekurencyjne odnoszenie się przez nie do nich samych. Standardową techniką w rachunku \(\lambda\) do określania funkcji w ten sposób jest użycie operatora punktu stałego Y. Przypomnijmy:
\begin{align*}
  \mathrm{Y}\equiv\lambda f.\,(\lambda x.\,(f(xx))\lambda x.\,(f(xx)))
\end{align*}
Wówczas określamy
\begin{align*}
  \mathrm{add_Y}\equiv \mathrm{Y}\,(\lambda a\,n\, m .\ n m\,(\lambda n.\ \mathrm{Succ} (a\,n\,m)))
\end{align*}
Mając na uwadze możliwość przeprowadzenia powyższej konstrukcji przy użyciu rekurencji, będziemy dopuszczali w notacji odnoszenie się wprowadzanych \(\lambda\)-termów do nich samych.

\subsubsection{Kodowanie Scotta typów rekursywnych}
Stosując metody kodowania prostych typów wyliczeniowych i par, łatwo odnajdujemy reprezentację konstruktorów wartości dla typów \texttt{Nat} i \texttt{List}:
\begin{align*}
  \mathrm{Zero} &\equiv \lambda z s .\, z     & \mathrm{Nil} &\equiv \lambda n c.\,n\\
  \mathrm{Succ} &\equiv \lambda n z s.\,sn    & \mathrm{Cons} &\equiv \lambda x \, x_s \, n\, c.\ c \, x \, x_s
\end{align*}
  Zwróćmy uwagę, że konstruktory Nat i Maybe są swoimi \(\alpha\)-konwersami. Podobieństwo nie jest przypadkowe: na poziomie typów konstrukcja Maybe jest odpowiednikiem brania następnika. Określając dodatkowo \(\mathrm{Void}=\lambda x.x\) jako element neutralny działania łącznego, otrzymujemy na poziomie typów strukturę półpierścienia z działaniem mnożenia okresloną przez konstrukcję par i dzałaniem dodawania określonego przez konstrukcję typów wyliczeniowych. Stąd algebraicze typy danych biorą swoją nazwę.

Z łatwością możemy określić teraz operacje brania poprzednika, głowy i ogona listy, odpowiednio:

\begin{align*}
  \mathrm{pred}&\equiv \lambda n .\, n\, \mathrm{undef}\, (\lambda m.\,m)\\
  \mathrm{head}&\equiv \lambda x_s .\, x_s\, \mathrm{undef}\, (\lambda x_s . x)\\
  \mathrm{tail}&\equiv \lambda x_s.\, \mathrm{undef}\, (\lambda x_s.\,x_s)
\end{align*}
gdzie undef jest stałą o którą rozszerzamy rachunek \(\lambda\) celem sygnalizowania błędnej aplikacji.


\subsubsection{Kodowanie Churcha typów rekursywnych}
Przedstawimy teraz klasyczny sposób kodowania typów przypisywany A. Churchowi. Różni się on od kodowania Scotta tylko w przypadku typów rekursywnych, w pozostałych przypadkach obydwa kodowania dają te same rezultaty. Rozpocznijmy od typu odpowiadającego liczbom naturalnym. W kodowaniu Churcha w następujący sposób reprezentujemy typ \texttt{Nat}:
\begin{align*}
  \mathrm{Zero} &\equiv \lambda f x.\,x\\
  \mathrm{Succ} &\equiv \lambda n f x.\,f\,(n\,f\,x)
\end{align*}
Wyrażenia będące skutkiem konsekwentnej aplikacji Succ do Zero w literaturze popularnie nazywa się \emph{liczebnikami Churcha}. Porównując je do kodowania Scotta widzimy, że zamiast aplikować

  Celem lepszego porównania kodowania Churcha i Scotta podamy reprezentacje funkcji \texttt{foldl}\footnote{Przedstawione definicje mają jedyne charakter ilustracji. Staramy się używać jak najmniejszego podzbioru języka Haskell. Dla porządku należy zaznaczyć, że poprawne określenie klasy funkcji fold polegałoby na zdefiniuwaniu instancji klasy \texttt{Foldable} dla typów \texttt{Nat} i \texttt{List}} dla typów \texttt{Nat} i \texttt{List}. Określmy:
\begin{minted}{haskell}
  foldlNat f x Zero    = x
  foldlNat f x (Suc n) = f (foldlNat f x n)
\end{minted}

\subsubsection{Ogólny przypadek typów wyliczeniowych}
W ogólnym przypadku, mając nastepującą definicję ADT:
\begin{minted}{haskell}
  data type_constructor t1 t2 ... tk = C1 t11 ... t1n1
                                     | C2 t21 ... t2n2
                                     ...
                                     | Cm tm1 ... tmnm
\end{minted}
dla \(m, n \in \mathbb{N}\), wiążemy z nią następującą reprezentację w rachunku \(\lambda\):
\begin{gather*}
  \mathrm{C_1} \equiv \lambda t_{11}\, t_{12}\, \dots t_{1n_1}\, f_1\, f_2 \dots f_m.\ f_1 t_{11} t_{12} \dots t_{1n_1}\\
  \mathrm{C_2} \equiv \lambda t_{21}\, t_{22}\, \dots t_{2n_2}\, f_1\, f_2 \dots f_m.\ f_2 t_{21} t_{22} \dots t_{2n_2}\\
 \vdots\\
  \mathrm{C_m} \equiv \lambda t_{m1}\, t_{m2}\, \dots t_{mn_m}\, f_1\, f_m \dots f_m.\ f_1 t_{m1} t_{m2} \dots t_{mn_m}\\
\end{gather*}

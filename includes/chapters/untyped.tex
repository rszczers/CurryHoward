
\section{Rachunek \(\lambda\)}
Niech  \(V\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych \(x,\ y,\ \dots\) (indeksowanych być może liczbami naturalnymi). Elementy takiego zbioru będziemy nazywali \emph{\(\lambda\)-zmiennymi}. Ponieważ \(V\) jest potencjalnie nieskończony, zastrzegamy sobie możliwość wybierania w razie potrzeby wcześniej nie użytej zmiennej.

\begin{definicja}(Zbiór \(\mathbf{\tilde\Lambda}\) pretermów)\label{def:lambda-untyped}
Zbiorem pretermów będziemy nazywali najmniejszy (w sensie mnogościowym) zbiór wyrażeń \(\mathbf{\tilde\Lambda}\) taki, że:
  \begin{enumerate}[label={(P\arabic*)}, ref={(P\arabic*)}]
  \setlength\itemsep{0em}
  \item Jeśli \(x \in V\), to \(x\in\mathbf{\tilde\Lambda}\).\label{pret1}
  \item Jeśli \(M,\,N\in \mathbf{\tilde\Lambda}\), to \((M\,N)\in\mathbf{\tilde\Lambda}\).\label{pret2}
  \item Jeśli \(x\in V\) i \(M\in\mathbf{\tilde\Lambda}\), to \((\lambda x.\,M)\in\mathbf{\tilde\Lambda}\).\label{pret3}
  \end{enumerate}
\end{definicja}
Definicję \ref{def:lambda-untyped} można równoznacznie wyrazić przy pomocy notacji Backusa-Naura. Wówczas ma ona następującą, zwięzłą postać:
\begin{align*}
  \mathbf{\tilde\Lambda}\ \leftarrow \ V\ |\ (\mathbf{\tilde\Lambda}\,\mathbf{\tilde\Lambda}) \ |\ (\lambda V.\, \mathbf{\tilde\Lambda})
\end{align*}

Elementy \(\mathbf{\tilde\Lambda}\) będziemy oznaczali literami \(L,\ M,\ N,\ P,\ Q,\ R\) i ich wariantami z górnymi lub dolnymi indeksami. Wyrażenia postaci \ref{pret2} nazywamy \emph{aplikacjami} \(M\) do \(N\). Symbol \(\lambda\) występujący w \ref{pret3} nazywamy \emph{\(\lambda\)-abstraktorem}, zaś wyrażenia powstałe przez zastosowanie tej reguły to \emph{\(\lambda\)-abstrakcje}. W wyrażeniu postaci \((\lambda x.\,M)\) preterm \(M\) jest w \emph{zasięgu} \(\lambda\)-abstraktora, a zmienna \(x\) jest przez niego \emph{związana}. Ponadto, będziemy stosowali następujące konwencje notacyjne:
\begin{easylist}
  & \emph{najbardziej zewnętrzne nawiasy bedą pomijane,}
  & \emph{aplikacja wiąże lewostronnie; wyrażenia postaci \((PQ)R\) będą zapisywane w postaci \(PQR\),}
  & \emph{\(\lambda\)-abstrakcja wiaże prawostronnie: \(\lambda x_1.\, (\lambda x_2.\,P)\) zapisujemy  \(\lambda x_1.\, \lambda x_2.\,P\),}
  & \emph{następujące po sobie \(\lambda\)-abstrakcje postaci \(\lambda x_1 . \, \lambda x_2 . \, \dots  \lambda x_n .\, P\) zapisujemy pod wspólnym \(\lambda\)-abstraktorem: \(\lambda x_1 \, x_2 \, \dots \, x_n .\, P\).}
\end{easylist}

Powiemy, że dwa \(\lambda\)-termy są \emph{syntaktycznie równe}, jeśli rozumiane jako ciągi znaków są identyczne. Równość syntaktyczną będziemy oznaczali znakiem \(\equiv\).

\begin{przyklad}
  Podajmy kilka przykładów \(\lambda\)-pretermów pogrupowanych ze względu na ich konstrukcję.
  \begin{enumerate}[label={(P\arabic*):}, ref={(P\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x,\ y,\ z\).
    \item \(x\,x,\ y\,x,\ x\,(x\,z)\),\\
          \((\lambda x .\, (x z)) y,\
             y\, (\lambda x .\, (x\, z)),\ (\lambda x .\, x)\,(\lambda x .\, x)\).
    \item \( \lambda x .\, (x \, z),\
             \lambda y z .\, x,\
             \lambda x .\, (\lambda x .\, (x\, x))\).
  \end{enumerate}
\end{przyklad}

 % \begin{konwencja*}
% Przypomnijmy, że \emph{selektorem} w \(V\) nazywamy każdą funkcję \(s:\:\mathcal{P}(V)-\{\emptyset\}\rightarrow V\) taką, że \(s(X)\in X\) dla \(\emptyset\neq X\subseteq V\).


%   Niech \(f:D\to E\) będzie dowolną funkcją i niech \(d\in D,\ e\in E\). Funkcję \(f[x/N]:\:D\to E\) określamy w następujący sposób:
%   \[
%     f[d/e]d' = \begin{cases}
%       e, &\text{jeśli}\ d'\equiv d, \\
%       fd', &\text{w przeciwnym wypadku.}
%     \end{cases}
%   \]
 % \end{konwencja*}

Podwyrażenia \(\lambda\)-pretermu mogą być wzajemnie identyczne i występować wielokrotnie. Obserwację tę ujmuje następująca definicja.
\begin{definicja}(Multizbiór \(\mathrm{Sub}\) podtermów pretermu)\label{def:untyped_subterm}
  \begin{enumerate}[label={(\arabic*)}, ref={(\arabic*)}]
    \setlength\itemsep{0em}
    \item \(\mathrm{Sub}(x)=\{x\}\)
    \item \(\mathrm{Sub}(MN)=\mathrm{Sub}(M)\cup\mathrm{Sub}(N)\cup\{M\,N\}\)
    \item \(\mathrm{Sub}(\lambda x.\, M) = \mathrm{Sub}(M)\cup \{\lambda x.\, M\}\)
  \end{enumerate}
  Elementy multizbioru \(\mathrm{Sub}(M)\) nazywamy \emph{podtermami} \(M\). Jeśli \(L\) jest podtermem \(M\), ale \(L\not\equiv M\), to \(L\) nazywamy podtermem \emph{właściwym}.
\end{definicja}
\begin{przyklad} Podtermy wybranych \(\lambda\)-pretermów.
  \begin{align*}
    \begin{split}
      \mathrm{(a)}\quad & \mathrm{Sub}\left(\lambda x.\,x\, x\right)=\left\{\left(\lambda x.\,x\, x\right)^1,\  \left(x\, x\right)^1,\ x^2\right\}\\
       \mathrm{(b)}\quad & \mathrm{Sub}\left(\left(\lambda x .\, x\, x\right)\,\left(\lambda x .\, x\, x\right)\right) = \\
    & = \left\{((\lambda x .\, x\, x)\,(\lambda x .\, x\, x))^{1}, \ (\lambda x .\, x\, x)^2,\ (x\,x)^{2},\ x^{4}\right\}\\
  \end{split}
  \end{align*}
  W powyższych przykładach użyliśmy standardowej notacji w górnym indeksie umieszczając krotność występowania elementu.
\end{przyklad}
\begin{definicja}(Zbiór \(\mathrm{FV}\) zmiennych wolnych)\label{def:untyped_fv}
  Dla dowolnego pretermu \(M\) określamy zbiór \(\mathrm{FV}(M)\) \emph{zmiennych wolnych} w \(M\) w następujący sposób:
\begin{align*}
    \mathrm{FV}(x) &= \{x\}\\
    \mathrm{FV}(\lambda x .\, P)  &= \mathrm{FV}(P)\setminus\{x\}\\
    \mathrm{FV}(P Q) &= \mathrm{FV}(P)\cup\mathrm{FV}(Q)
\end{align*}
  Jesli \(\mathrm{FV}(M)=\emptyset\), to mówimy, że \(M\) jest \emph{domknięty} lub nazywamy \(M\) \emph{kombinatorem}.
\end{definicja}
\begin{przyklad}
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item \(\mathrm{FV}(\lambda x.\,x\,y)=\left\{y\right\}\)
    \item \(\mathrm{FV}(x\,(\lambda x.\, x\,y)) = \left\{x,\ y\right\}\)
    \item \(\mathrm{FV}(\lambda x y z.\, x y) = \emptyset\)
  \end{enumerate}
\end{przyklad}


\begin{definicja}(Podstawienie)\label{def:substitution}
  Dla dowolnych \(\mathrm{M,\,N}\in\mathbf{\tilde\Lambda}\) i \(x\in V\) przez \(N[x/N]\) oznaczamy rezultat podstawienia termu \(N\) za wszystkie wolne wystąpienia zmiennej \(x\) w \(M\), o ile w rezultacie podstawienia nie zostaną związane żadne zmienne wolne występujące w \(N\). W takim wypadku:
  \begin{enumerate}[label={(S\arabic*)}, ref={(S\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x[x/N] = N\)
    \item \(y[x/N] = y,\ \text{o ile}\ x\not\equiv y\)
    \item \((PQ)[x/N] = P[x/N]\,Q[x/N]\)\label{def:substitution_c}
    \item \((\lambda y.\, P)[x/N] = \lambda y.\,P[x/N],\ \text{gdzie}\ x\not\equiv y\ \text{i}\ y\not\in \mathrm{FV}(N)\)
    \item \((\lambda x.\, P)[x/N] = \lambda x.\,P\)\label{def:substitution_e}
  \end{enumerate}
\end{definicja}

\begin{lemat}(O podstawieniu)\label{lem:substitution}
  Niech \(M,\,N,\,L\in \mathbf{\tilde\Lambda}\) i niech ponadto \(x\not\equiv y\) oraz \(x\not\in\mathrm{FV}(L)\). Wówczas
  \begin{align}\label{eq:substitution}
    M[x/N][y/L]\equiv M[y/L]\left[x/N\left[y/L\right]\right].
  \end{align}
  \begin{dowod}
    Dowód przebiega przez indukcję strukturalną względem \(M\). Rozważmy następujące przypadki:
    \begin{enumerate}[label={\roman*)}, ref={(\arabic*)}]
      \item \(M\) jest zmienną. Wówczas:
        \begin{enumerate}[label={\alph*.}]
        \item Jeśli \(M\equiv x\), to obie strony \eqref{eq:substitution} po podstawieniu są postaci \(N[y/L]\).
        \item Jeśli \(M\equiv y\), to ponieważ \(x\not\equiv y\) i \(x\not\in\mathrm{FV}(M)\), po wykonaniu podstawienia po lewej stronie \eqref{lem:substitution} otrzymujemy \(M[x/N][y/L]\equiv L\). Ponieważ \(x\not\in\mathrm{FV}(L)\), to po wykonaniu podstawienia po prawej stronie widzimy, że obydwie strony są identyczne.

        \item Jeśli \(M\equiv z\) i \(z\not\equiv x\)  oraz \(z\not\equiv y\), to obydwie strony \eqref{eq:substitution} sa identyczne.
        \end{enumerate}

      \item \(M\equiv P Q\) dla pewnych \(P,\,Q\in\mathbf{\tilde\Lambda}\). Wówczas korzystając z hipotezy indukcyjnej wnosimy, że
        \begin{align*}
          P[x/N][y/L]\equiv P[y/L]\left[x/N\left[y/L\right]\right],\\
          Q[x/N][y/L]\equiv Q[y/L]\left[x/N\left[y/L\right]\right].
        \end{align*}
        Mając na względzie \ref{def:substitution_c} widzimy, że twierdzenie zachodzi i w tym przypadku.
        \item Jeśli \(M\equiv \lambda z.\,P\) oraz \(z\equiv x\) lub \(z\equiv y\), to z \ref{def:substitution_e} widzimy, że obydwie strony \eqref{eq:substitution} sa identyczne. Przypuśćmy, że \(z\not\equiv x\) i \(z\not\equiv y\) i \(z\not\in\mathrm{FV}(L)\). Wówczas na podstawie hipotezy indukcyjnej mamy:
      \begin{align*}
        (\lambda z.\,P)[x/N][y/L] &= \lambda z.\,P[x/N][y/L] =\\
                                  &= \lambda z.\,P[y/L][x/N[y/L]] =\\
                                  &= (\lambda z.\,P)[y/L][x/N[y/L]].
      \end{align*}
    \qed
    \end{enumerate}
  \end{dowod}
\end{lemat}

\begin{wniosek}\label{thm:odwracalnosc_podstawienia}
Jesli \(M[x/y]\) jest określone i \(y\not\in\mathrm{FV}(M)\), to \(M[x/y][y/x]\) jest określone oraz
  \(M[x/y][y/x]=M\).
  \begin{dowod}
    Mając na uwadze Lemat \ref{def:substitution} dowód przebiega przez indukcję strukturalną względem \(M\).
    \qed
  \end{dowod}
\end{wniosek}



\subsection{Wyrażenia \(\lambda\)}
Na ogół chcielibyśmy utożsamiać pretermy, które różnią się wyłącznie zmiennymi związanymi, tak jak w przypadku wyrażeń \(\lambda x. \,zx\) i \(\lambda y.zy\). W takim wypadku powiemy o nich, że są swoimi \emph{\(\alpha\)-wariantami} lub że są ze sobą w relacji \emph{\(\alpha\)-konwersji}.

\begin{definicja}(Relacja \(\alpha\)-konwersji)\label{def:untyped_alpha}
  Relacją \(=_{\alpha}\) (\(\alpha\)-konwersji) nazywamy najmniejszy w sensie mnogościowym praporządek na \(\mathbf{\tilde\Lambda}\) taki, że
  \begin{enumerate}[label={(\(\alpha\)\arabic*)}, ref={(\(\alpha\)\arabic*)}]
  \setlength\itemsep{0em}
  \item Jeśli \(y\not\in \mathrm{FV}(M)\) oraz \(M[x/y]\) jest określone,\\ to \(\lambda x.\,M~=_{\alpha}~\lambda y.\,M[x/y]\)\label{def:alpha_1}
  \item Jeśli \(M=_{\alpha} N\), to dla dowolnego \(x\in V\) zachodzi \(\lambda x.\,M =_{\alpha} \lambda x.\,N\)\label{def:alpha_2}
  \item Jeśli \(M=_{\alpha} N\), to dla dowolnego \(Z\in\mathbf{\tilde\Lambda}\) zachodzi \(MZ =_{\alpha} NZ\)\label{def:alpha_3}
  \item Jeśli \(M=_{\alpha} N\), to dla dowolnego \(Z\in\mathbf{\tilde\Lambda}\) zachodzi \(ZM =_{\alpha} ZN\)\label{def:alpha_4}
  \end{enumerate}
\end{definicja}

\begin{przyklad}
  \begin{align*}
    \lambda x y.\,x(xy) &\equiv \lambda x.\,(\lambda y.\,x(xy)) \\
                        &\equiv_\alpha \lambda x.\,(\lambda z.\,x(xz)) \\
                        &\equiv_\alpha \lambda v.\,(\lambda z.\,v(vz)) \\
                        &\equiv \lambda vz.\,v(vz).
  \end{align*}

\end{przyklad}

\begin{wniosek}
  Relacja \(=_{\alpha}\) jest relacją równoważności.
  \begin{dowod}
    Wystarczy, że pokażemy, że relacja \(=_{\alpha}\) jest symetryczna. Dowód przebiega przez indukcję względem Definicji \ref{def:untyped_alpha}. Rozważmy następujące przypadki:
    %Fakt \ref{def:odwracalnosc_podstawienia}

    \begin{enumerate}[label={\roman*)}, ref={(\roman*)}]
      \item Jeśli \(M=_{\alpha} N\) w konsekwencji zwrotności \(=_{\alpha}\), to \(M\equiv N\), a zatem również \(N\equiv M\). Stąd \(N=_{\alpha} M\).
      \item Jeśli \(M=_{\alpha} N\) w konsekwencji przechodniości \(=_{\alpha}\), to istnieje \(L\in\mathbf{\tilde\Lambda}\) takie, że \(M=_{\alpha}L\) i \(L=_{\alpha}N\). Wówczas z hipotezy indukcyjnej \(N=_{\alpha}L\) i \(L=_{\alpha}M\). Z przechodniości relacji \(=_{\alpha}\) otrzymujemy spodziewaną tezę.
      \item Przypuśćmy, że \(M=_{\alpha} N\) w konsekwencji  \ref{def:alpha_1}  dla \(M\equiv\lambda x.\,M'\) i \(N\equiv\lambda y.\,M'[x/y]\). Ponieważ \(x\not\in\mathrm{FV}(M'[x/y])\), to ze względu na Wniosek \ref{thm:odwracalnosc_podstawienia} mamy, że \(M'[x/y][y/x]=M'\). Zatem, na podstawie \ref{def:alpha_1}:
  \begin{align*}
        \lambda y.\,M'[x/y] =_{\alpha} \lambda x.\,M'[x/y][y/x].
      \end{align*}
    \item  Jeśli \(M=_{\alpha} N\) w konsekwencji \ref{def:alpha_2}, gdzie \(M=\lambda x.\,M'\) i \(N=\lambda x.\,N'\) dla \(M'=_{\alpha} N'\), to z hipotezy indukcyjnej \(N' =_{\alpha} M'\) i w konsekwencji \ref{def:alpha_2} mamy, że \(N=_{\alpha} M\).
    \item  Jeśli \(M=_{\alpha} N\) w konsekwencji \ref{def:alpha_3} dla \(M\equiv M'Z\) i \(N\equiv N'Z\) takich, że \(M'=_{\alpha}N'\), to z hipotezy indukcyjnej oczywiście \(N'=_{\alpha}M'\), a zatem z \ref{def:alpha_3} \(N=_{\alpha} M\).\label{proof:alpha_cases_4}
    \item  Jeśli \(M=_{\alpha} N\) w konsekwencji \ref{def:alpha_3}, to postępujemy jak w przypadku \ref{proof:alpha_cases_4}.\qed
    \end{enumerate}
  \end{dowod}
\end{wniosek}

\begin{definicja}(Zbiór \(\mathbf{\Lambda}\) \(\lambda\)-termów)
  Każdą klasę abstrakcji relacji \(=_{\alpha}\) nazywamy \(\lambda\)-termem. Zbiór wszystkich \(\lambda\)-termów \(\mathbf{\Lambda}\) to zbiór ilorazowy relacji \(\alpha\)-konwersji:
  \begin{align*}
    \mathbf{\Lambda}=\left\{[M]_{=_\alpha}\ |\ M\in\mathbf{\tilde\Lambda}\right\}
  \end{align*}
\end{definicja}

\begin{konwencja*}
Wprowadzamy następujące konwencje notacyjne:
\begin{align*}
  &x = [x]_{=_\alpha},\\
  &PQ = [M'N']_{=_\alpha},\ \text{gdzie}\ M=[M']_{=_\alpha}\ \text{i}\ N=[N']_{=_\alpha},\\
  &\lambda x.\,M =  [\lambda x.\,M']_{=_\alpha},\  \text{gdzie}\ N=[N']_{=_\alpha}.
\end{align*}
\end{konwencja*}
%Nie prowadzą one do niejednoznaczności, w czym upewnia nas Lemat \ref{lem:uniqueness}.

%\begin{lemat}(O jednoznaczności)\label{lem:uniqueness}
%  Dla dowolnych \(M,\,N
%\end{lemat}

Na zbiór \(\mathbf{\Lambda}\) przenoszą się pojęcia podtermu, zmiennych wolnych i operacji podstawienia definiowane uprzednio dla pretermów.

\begin{definicja}(Multizbiór \(\mathrm{Sub}\) podtermów \(\lambda\)-termu)
  Dla dowolnego \(\lambda\)-termu \(M=[M']_{=_{\alpha}}\) okreslamy
  \[
    \mathrm{Sub}(M)=\mathrm{Sub}(M'),
  \]
  gdzie \(\mathrm{Sub}(M')\) jest multizbiorem podwyrażeń pretermu \(M'\) zdefiniowanym w myśl Definicji \ref{def:untyped_subterm}.
\end{definicja}

\begin{definicja}(Zbiór zmiennych wolnych \(\mathrm{FV}\))
  Dla dowolnego \(\lambda\)-termu \(M=[M']_{=_{\alpha}}\) określamy zbiór \(\mathrm{FV}(M)\) \emph{zmiennych wolnych} w \(M\)
  \[
    \mathrm{FV}(M)=\mathrm{FV}(M'),
  \]
  gdzie \(\mathrm{FV}(M')\) jest zbiorem zmiennych wolnych pretermu \(M'\) zdefiniowanym w myśl Definicji \ref{def:untyped_fv}.
\end{definicja}

\begin{definicja}(Podstawienie)\label{def:untyped_lambda_substitution}
  Niech \(M=[M']_{=_\alpha}\) i \(N=[N']_{=_\alpha}\) i niech \(M'[x/N']\) będzie określone w myśl Definicji \ref{def:substitution}. Wówczas
  \[
    M[x/N]= [M'[x/N']]_{=_\alpha}.
  \]
\end{definicja}

Operacja podstawienia wymaga jednak pewnej delikatności. Rozważmy następującą relację:
\[
  \lambda x.\,zx=_{\alpha}\lambda y.\,zy
\]
Zauważmy, że traktując podstawienie w sposób naiwny, mamy, że \((\lambda x.\,zx)[z/x]\neq_{\alpha}(\lambda y.\,zy)[z/x]\), a więc tracimy porządaną własność niezmienniczości \(\alpha\)-konwersji względem podstawienia. Stąd w Definicji \ref{def:substitution} wymóg, aby podstawienie nie prowadziło do uszczuplenia zbioru zmiennych wolnych. Alternatywnym rozwiązaniem jest określenie podstawienia, które wprowadzałoby do wyrażenia nową zmienną i prowadziło w konsekwencji do abstrahowania po wcześniej nie występujacych zmiennych:
\[
  (\lambda x.\,M)[y/N] = \lambda x'.\,M[x/x'][y/N],
\]
w przypadku, gdy \(x\not\equiv y\), gdzie \(x'\not\in\mathrm{FV}(M)\) i \(x'\not\in\mathrm{FV}(N)\). Rozstrzygnięcie takie przytacza się w \cite{Hindley:2008:LCI:1388400,}. Po uwzględneniu odpowiednich modyfikacji, Definicja \ref{def:substitution} przyjmuje następującą postać:
\begin{customdef}{4'}(Podstawienie')\label{def:untyped_substitution_hindley}
  \begin{enumerate}[label={(S'\arabic*)}, ref={(S'\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x[x/N] = N\)
    \item \(y[x/N] = y,\ \text{o ile}\ x\not\equiv y\)
    \item \((PQ)[x/N] = P[x/N]\,Q[x/N]\)
    \item \((\lambda x.\, P)[x/N] = \lambda x.\,P\)
    \item \((\lambda y.\, P)[x/N] = \lambda y.\,P\), jeśli \(x\not\in\mathrm{FV}(P)\)\label{def:substitution_e}\label{def:substitution_hindley_e}
    \item \((\lambda y.\, P)[x/N] = \lambda y.\,P[x/N],\ \text{gdzie}\ x\in\mathrm{FV}(P)\) i \(y\not\in\mathrm{FV}(N)\)\label{def:substitution_hindley_f}
    \item \((\lambda y.\, P)[x/N] = \lambda z.\,P[y/z][x/N],\ \text{gdzie}\ x\in\mathrm{FV}(P)\) i \(y\in\mathrm{FV}(N)\)\label{def:substitution_hindley_g}
  \end{enumerate}
  przy czym w \ref{def:substitution_hindley_g} wymagamy, aby zmienna \(z\) nie występowała wcześniej w termach \(N\) i \(P\) jako zmienna wolna, zaś dla \ref{def:substitution_hindley_e}-\ref{def:substitution_hindley_g} dodatkowo \(y\not\equiv x\).
\end{customdef}
\begin{uwaga}
Każde podstawienie \([x/N]\) jest funkcją z \(\mathbf{\Lambda}\to\mathbf{\Lambda}\), gdzie \(x\in V\) i \(N\in\mathbf{\Lambda}\) są dowolnymi parametrami. Zbiór \(S\) podstawień ma strukturę monoidu z działaniem składania
  \begin{align*}
    M([x_2/N_2]\circ[x_1/N_1]) = (M[x_1/N_1])[x_2/N_2] \equiv M[x_1/N_1][x_2/N_2]
  \end{align*}
  dla dowolnych \([x_1/N_1],\,[x_2/N_2]\in S\), o ile \(S\) posiada element neutralny \(\iota\) taki, że
  \begin{align*}
    M \iota = M,\ \text{gdzie}\ [x/x]=\iota\ \text{dla dowolnego}\ x\in V.
  \end{align*}
\end{uwaga}

W literaturze znajdujemy mnogość propozycji, które w ten czy inny sposób starają się ułatwić rzeczywistą implementację podstawienia. Na szczególną uwagę zasługują tutaj tak zwane \emph{indeksy de Bruijna}. Zaproponowana przez N. G. de Brujina w \cite{deBruijnIndices}  notacja eliminuje bezpośrednie występowanie symboli zmiennych w \(\lambda\)-termach, zastępując je liczbą naturalną wyrażającą głębokość zagnieżdżenia odpowiedniej \(\lambda\)-abstrakcji przez którą jest związana, przykładowo:
\[
  \lambda f.\,(\lambda x.\,(f(xx))\lambda x.\,(f(xx))) \equiv_{de Brujin} \lambda (\lambda 2 (1 1)) \lambda 2 (1 1)
\]
Historycznie wiąże się ta notacja z jego pracami nad systemem komputerowo wspomaganego dowodzenia twierdzeń AUTOMATH. Rozwiązanie takie, podobnie jak w przypadku tzw. logik kombinatorów, eliminuje konieczność utożsamiania termów przez \(\alpha\)-konwersję, ale istotnie zmniejsza ich czytelność.

Szerszy komentarz dotyczący dotychczasowych prób uchwycenia operacji podstawienia można prześledzić w \cite{txa:alpha-draft}. Nasze rozważania opierają się w tej materii przeważająco na \cite{Urzyczyn2006}. Samo podejście do definiowania \(\lambda\)-termow przez operację \(\alpha\)-konwersji nie jest powszechne w literaturze przedmiotu. Analogiczną konstrukcję należałoby powtarzać wprowadzając każdy kolejny system, dlatego w dalszej części tej pracy będziemy poprzestawali na nieformalnym traktowaniu wyrażeń danego systemu jako odpowiednich klas \(\alpha\)-konwersji.

% \subsection{Podstawienie jednoczesne}
% Biorąc pod uwagę sens obliczeniowy rachunku \(\lambda\) interesujące okazuje się modyfikacja Definicji \ref{def:untyped_substitution_hindley} w  taki sposób, aby podstawienie miało miejsce dla wielu zmiennych równolegle w całym \(\lambda\)-termie. Za przykładem \cite{STOUGHTON1988317} wprowadzimy \emph{podstawienie jednoczesne}. W tym celu jednak uściślenia wymagają pewne pojęcia.

\begin{definicja}(Podstawienie jednoczesne)\label{def:simult_substitution}
Dla dowolnego \(M\in\mathbf{\Lambda}\), ciągu \(\lambda\)-zmiennych~\(\vec{x}\) i ciągu \(\lambda\)-termów \(\vec{N}\) określamy:
  \begin{enumerate}[label={(\(\vec{s}\)\arabic*)}, ref={(\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x_i[\vec{x}/\vec{N}]=N_i\) dla \(i\in\mathbb{N}\).
    \item \(y[\vec{x}/\vec{N}]=y\) o ile dla dowolnego \(i\in\mathbb{N},\ y\not\equiv x_i\).
    \item \((PQ)[\vec{x}/\vec{N}]=P[\vec{x}/\vec{N}]Q[\vec{x}/\vec{N}]\)
%    \item \((\lambda y.\,P)[\vec{x}/\vec{N}]=\lambda y'.\,P[y/y'][\vec{x}/\vec{N}]\), gdzie \(y'\) jest wcześniej nie występującą zmienną, \(y\not\equiv x_i\)  dla wszystkich \(i\in\mathbb{N}\) i \(y\not\in\bigcup_{i\in\mathbb{N}}FV(N_i)\).
    \item \((\lambda y.\,P)[\vec{x}/\vec{N}]=\lambda y.\,P[\vec{x}/\vec{N}]\), jeśli \(y\neq x_i\) dla wszystkich \(i\in\mathbb{N}\) i \(y\not\in\bigcup_{i\in\mathbb{N}}FV(N_i)\)
 \end{enumerate}
\end{definicja}

\begin{konwencja*}
  Jeśli \(N_i\equiv x_i\) dla wszystkich poza skończenie wieloma \(i_1,\,i_2,\,\dots,\,i_n\in~\mathbb{N}\), to \([x_{i_1}/N_{i_1},\,x_{i_2}/N_{i_2},\,\dots,\,x_{i_n}/N_{i_n}]\equiv [\vec{x}/\vec{N}]\).
\end{konwencja*}

\begin{przyklad}
  Zauważmy, że podstawienia w myśl Definicji \ref{def:substitution} i Definicji \ref{def:simult_substitution} mogą, ale nie muszą, prowadzić do różnych rezultatów.
\begin{align*}
  \text{a)}\quad &  (xy)[y/x][x/u] = uu, &\quad\text{b)}\quad & (\lambda x.\,yx)[x/y][y/z]=\lambda x.\,zx, \\
                &  (xy)[y/x, x/u] = ux. & &(\lambda x.\,yx)[x/y,y/z]=\lambda x.\,zx.\\
\end{align*}

\end{przyklad}
\subsection{Redukcja}
Sens obliczeniowy \(\lambda\)-termom nadajemy przez określenie na \(\mathbf{\Lambda}\) operacji \(\beta\)- i \(\eta\)-redukcji. Pożądane jest, żeby operacje te wykonywane na podtermach pozostowały w \emph{zgodzie} ze strukturą całego \(\lambda\)-termu.

\begin{definicja}(Relacja zgodna)
  Relację binarną \(\mathcal{R}\) na zbiorze \(\mathbf{\Lambda}\) nazywamy \emph{zgodną}, jeśli dla dowolnych \(M,\,N,\,P \in \mathbf{\Lambda}\) zachodzą następujące warunki:
  \begin{enumerate}[label={(c\arabic*)}, ref={(\arabic*)}]
    \setlength\itemsep{0em}
    \item Jeśli \(M \mathcal{R} N\), to \((\lambda x.\,M)\,\mathcal{R}\,(\lambda x.\,N)\) dla dowolnej \(\lambda\)-zmiennej \(x\).
    \item Jeśli \(M \mathcal{R} N\), to \((MP)\,\mathcal{R}\,(NP)\).
    \item Jeśli \(M \mathcal{R} N\), to \((PM)\,\mathcal{R}\,(PN)\).
  \end{enumerate}
\end{definicja}
Przez \emph{domknięcie relacji} \(\mathcal{R}_1\) będziemy rozumieli najmniejszą (w sensie mnogościowym) relację \(\mathcal{R}_2\) taką, że \(\mathcal{R}_1\subset\mathcal{R}_2\).
  Z pewnego rodzaju domknięciami, ze względu na ich szczególną rolę, wiążemy następującą notację:
  \begin{enumerate}[label=(\alph*), ref={(\alph*)}]
    \setlength\itemsep{0em}
    \item Przez \(\mathcal{R}^{+}\) oznaczamy przechodnie domknięcie relacji \(\mathcal{R}\).\label{def:closure_a}
    \item Przez \(\mathcal{R}^{*}\) oznaczamy zwrotnie domknięcie relacji \(\mathcal{R}^{+}\).\label{def:closure_b}
    \item Przez \(=_{\mathcal{R}}\) oznaczamy symetryczne domknięcie relacji \(\mathcal{R}^{*}\).\label{def:closure_c}
\end{enumerate}
Dla lepszego zrozumienia powyższych operacji warto zauważyć, że \ref{def:closure_b} wyznacza praporzadek, który w odniesieniu do redukcji określonych na \(\mathbf{\Lambda}\) można rozumieć jako graf skierowany (w przypadku \(\mathbf{\Lambda}\) być może nieskończony) w którym krawędzie odpowiadają możliwym krokom obliczenia, zaś \ref{def:closure_c} -- kongruencję, która znów w szczególnym odniesieniu do \(\lambda\)-termów, będzie dokonywała podziału w \(\mathbf{\Lambda}\) ze względu na rezultat obliczenia.
\begin{definicja}(\(\beta\)-redukcja)
  \(\beta\)-redukcją nazywamy najmniejszą (w sensie mnogościowym) zgodną na \(\mathbf{\Lambda}\) relację binarną \(\to_\beta\) taką, że
  \[
    (\lambda x.\,M)N\rightarrow_\beta M[x/N].
  \]
\emph{\(\beta\)-redeksami} bedziemy nazywali wyrażenia postaci \((\lambda x.\, M)N\), zaś rezultat ich \(\beta\)-redukcji w postaci termu \(M[x/N]\) -- \emph{\(\beta\)-reduktem}. \emph{Ciągiem} \(\beta\)-redukcji nazywamy skończony lub nieskończony ciąg postaci
  \[
    M_0 \to_\beta M_1 \to_\beta \dots 
  \]
\end{definicja}
  \begin{przyklad}Oznaczmy \(\mathrm{Y}=\lambda f.\,(\lambda x.\,(f(xx))\lambda x.\,(f(xx)))\) i niech \(F\) będzie dowolnym \(\lambda\)-termem. Wówczas otrzymujemy nieskończony ciąg redukcji postaci
    \begin{align*}
      \mathrm{Y}F &\equiv (\lambda f.\,(\lambda x.\,(f(xx))\lambda x.\,(f(xx))))F\\
                  &\to_\beta (\lambda x.\,F(xx))\lambda x.\,F(xx)\\
                  &\to_\beta F((\lambda x.\,F(xx))\lambda x.\,F(xx))\\
                  &\to_\beta F(F((\lambda x.\,F(xx))\lambda x.\,F(xx)))\\
                  &\to_\beta \dots
    \end{align*}
  \end{przyklad}
\begin{definicja}(\(\eta\)-redukcja)
  \(\eta\)-redukcją nazywamy najmniejszą (w sensie mnogościowym) zgodną na \(\mathbf{\Lambda}\) relację binarną \(\to_\eta\) taką, że
  \[
    \lambda x.\,Mx\to_\eta M,\ \text{o ile}\ x\not\in \mathrm{FV}(M).
  \]

  \(\eta\)-redukcja pozwala na pominięcie niczego nie wnoszącej \(\lambda\)-abstrakcji. Operację odwrotną nazywamy \emph{\(\eta\)-abstrakcją}, zaś \(\lambda\)-termy będące w którejkolwiek z tych relacji nazywamy \emph{\(\eta\)-konwersami}. Operacja ta nie ma wpływu na rezultat obliczenia, jedynie optymializuje zapis \(\lambda\)-termów i stąd ma duże znaczenie stylistyczne w programowaniu funkcyjnym.
  \end{definicja}

  \begin{przyklad}
    \(\lambda x. ((+1) x) =_\eta (+1) \).
  \end{przyklad}

  \subsection{Kodowanie typów danych}
Prosta składnia języka rachunku \(\lambda\) pozwala wyrazić zaskakująco wiele struktur danych reprezentując je i operacje na nich jako funkcje. Z tego powodu, stanowiąc inspirację dla wielu projektantów języków, uchodzi za protoplastę rodziny funkcyjnych języków programowania, chociaż bezpośrednio nie ma on praktycznego zastosowania w praktyce programistycznej. Rozwój tej legendy dobrze oddaje cykl klasycznych artykułów (tzw. \emph{Lambda Papers}) zapoczątkowany przez dokumentację języka Scheme \cite{Sussman:1975:IEL:889230}.

Najpopularniejszym sposobem reprezentacji danch przez funkcje w rachunku \(\lambda\) oparty jest na kodowaniu liczb Peano za pomocą tzw. liczebników Churcha. Metoda ta, ze względu na wynikające zeń problemy natury złożonościowej \cite{Koopman:2014:CED:2746325.2746330}, ma obecnie wyłącznie walory edukacyjne, dlatego w dalszej cześci pracy pokażemy tzw. kodowanie Scotta. Jest ona interesująca ze względu na praktyczną możliwość reprezentacji algebraicznych typów danych (ADT) znanych ze współczesnych języków funkcyjnych \cite{Jansen:2013:P9C:2941698.2941710}, pozwalając tym samym zaimplementować te konstrukcje w paradygmacie imperatywnym. Fakt, że każdy typ danych można zastąpić tym sposobem odpowiadającą mu funkcją wskazuje na metodę konstruowania prostych języków funkcyjnych, ale przede wszystkim na uniwersalność rachunku \(\lambda\) jako języka przejściowego dla kompilatorów języków wysokiego poziomu \cite[Rozdział 3]{PeytonJones:1992:IFL:129390}.

 \subsubsection{Kodowanie Churcha}

 \subsubsection{Kodowanie Scotta}

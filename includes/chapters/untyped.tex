
\section{Rachunek \(\lambda\)}
Niech  \(V\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych \(x,\ y,\ \dots\) (indeksowanych być może liczbami naturalnymi). Elementy takiego zbioru będziemy nazywali \emph{\(\lambda\)-zmiennymi}. Ponieważ \(V\) jest potencjalnie nieskończony, zastrzegamy sobie możliwość wybierania w razie potrzeby wcześniej nie użytej zmiennej.

\begin{definicja}(Zbiór \(\mathbf{\tilde\Lambda}\) pretermów)\label{def:lambda-untyped}
Zbiorem pretermów będziemy nazywali najmniejszy (w sensie mnogościowym) zbiór wyrażeń \(\mathbf{\tilde\Lambda}\) taki, że:
  \begin{enumerate}[label={(P\arabic*)}, ref={(P\arabic*)}]
  \setlength\itemsep{0em}
  \item Jeśli \(x \in V\), to \(x\in\mathbf{\tilde\Lambda}\).\label{pret1}
  \item Jeśli \(M,\,N\in \mathbf{\tilde\Lambda}\), to \((M\,N)\in\mathbf{\tilde\Lambda}\).\label{pret2}
  \item Jeśli \(x\in V\) i \(M\in\mathbf{\tilde\Lambda}\), to \((\lambda x.\,M)\in\mathbf{\tilde\Lambda}\).\label{pret3}
  \end{enumerate}
\end{definicja}
Definicję \ref{def:lambda-untyped} można równoznacznie wyrazić przy pomocy notacji Backusa-Naura. Wówczas ma ona następującą, zwięzłą postać:
\begin{align*}
  \mathbf{\tilde\Lambda}\ \leftarrow \ V\ |\ (\mathbf{\tilde\Lambda}\,\mathbf{\tilde\Lambda}) \ |\ (\lambda V.\, \mathbf{\tilde\Lambda})
\end{align*}

Powiemy, że dwa \(\lambda\)-termy są \emph{syntaktycznie równe}, jeśli rozumiane jako ciągi znaków są identyczne. Równość syntaktyczną będziemy oznaczali znakiem \(\equiv\).

Elementy \(\mathbf{\tilde\Lambda}\) będziemy oznaczali literami \(L,\ M,\ N,\ P,\ Q,\ R\) i ich wariantami z górnymi lub dolnymi indeksami. Wyrażenia postaci \ref{pret2} nazywamy \emph{aplikacjami} \(M\) do \(N\). Symbol \(\lambda\) występujący w \ref{pret3} nazywamy \emph{\(\lambda\)-abstraktorem}, zaś wyrażenia powstałe przez zastosowanie tej reguły to \emph{\(\lambda\)-abstrakcje}. W wyrażeniu postaci \((\lambda x.\,M)\) preterm \(M\) jest w \emph{zasięgu} \(\lambda\)-abstraktora, a zmienna \(x\) jest przez niego \emph{związana}. Ponadto, będziemy stosowali następujące konwencje notacyjne:
\begin{easylist}
  & \emph{najbardziej zewnętrzne nawiasy bedą pomijane,}
  & \emph{aplikacja wiąże lewostronnie; wyrażenia postaci \((PQ)R\) będą zapisywane w postaci \(PQR\),}
  & \emph{\(\lambda\)-abstrakcja wiaże prawostronnie: \(\lambda x_1.\, (\lambda x_2.\,P)\) zapisujemy  \(\lambda x_1.\, \lambda x_2.\,P\),}
  & \emph{następujące po sobie \(\lambda\)-abstrakcje postaci \(\lambda x_1 . \, \lambda x_2 . \, \dots  \lambda x_n .\, P\) zapisujemy pod wspólnym \(\lambda\)-abstraktorem: \(\lambda x_1 \, x_2 \, \dots \, x_n .\, P\).}
  & \emph{n-krotną aplikację \(P\in\mathbf{\tilde\Lambda}\) do siebie zapisujemy skrótowo: \(P^n\equiv \underbrace{P\,P\ \dots\ P}_{\text{n-razy}}\)}


\end{easylist}

\begin{przyklad}
  Podajmy kilka przykładów \(\lambda\)-pretermów pogrupowanych ze względu na ich konstrukcję.
  \begin{enumerate}[label={(P\arabic*):}, ref={(P\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x,\ y,\ z\).
    \item \(x\,x,\ y\,x,\ x\,(x\,z)\),\\
          \((\lambda x .\, (x z)) y,\
             y\, (\lambda x .\, (x\, z)),\ (\lambda x .\, x)\,(\lambda x .\, x)\).
    \item \( \lambda x .\, (x \, z),\
             \lambda y z .\, x,\
             \lambda x .\, (\lambda x .\, (x\, x))\).
  \end{enumerate}
\end{przyklad}

 % \begin{konwencja*}
% Przypomnijmy, że \emph{selektorem} w \(V\) nazywamy każdą funkcję \(s:\:\mathcal{P}(V)-\{\emptyset\}\rightarrow V\) taką, że \(s(X)\in X\) dla \(\emptyset\neq X\subseteq V\).


%   Niech \(f:D\to E\) będzie dowolną funkcją i niech \(d\in D,\ e\in E\). Funkcję \(f[x/N]:\:D\to E\) określamy w następujący sposób:
%   \[
%     f[d/e]d' = \begin{cases}
%       e, &\text{jeśli}\ d'\equiv d, \\
%       fd', &\text{w przeciwnym wypadku.}
%     \end{cases}
%   \]
 % \end{konwencja*}

Podwyrażenia \(\lambda\)-pretermu mogą być wzajemnie identyczne i występować wielokrotnie. Obserwację tę ujmuje następująca definicja.
\begin{definicja}(Multizbiór \(\mathrm{Sub}\) podtermów pretermu)\label{def:untyped_subterm}
  \begin{enumerate}[label={(\arabic*)}, ref={(\arabic*)}]
    \setlength\itemsep{0em}
    \item \(\mathrm{Sub}(x)=\{x\}\)
    \item \(\mathrm{Sub}(MN)=\mathrm{Sub}(M)\cup\mathrm{Sub}(N)\cup\{M\,N\}\)
    \item \(\mathrm{Sub}(\lambda x.\, M) = \mathrm{Sub}(M)\cup \{\lambda x.\, M\}\)
  \end{enumerate}
  Elementy multizbioru \(\mathrm{Sub}(M)\) nazywamy \emph{podtermami} \(M\). Jeśli \(L\) jest podtermem \(M\), ale \(L\not\equiv M\), to \(L\) nazywamy podtermem \emph{właściwym}.
\end{definicja}
\begin{przyklad} Podtermy wybranych \(\lambda\)-pretermów.
  \begin{align*}
    \begin{split}
      \mathrm{(a)}\quad & \mathrm{Sub}\left(\lambda x.\,x\, x\right)=\left\{\left(\lambda x.\,x\, x\right)^1,\  \left(x\, x\right)^1,\ x^2\right\}\\
       \mathrm{(b)}\quad & \mathrm{Sub}\left(\left(\lambda x .\, x\, x\right)\,\left(\lambda x .\, x\, x\right)\right) = \\
    & = \left\{((\lambda x .\, x\, x)\,(\lambda x .\, x\, x))^{1}, \ (\lambda x .\, x\, x)^2,\ (x\,x)^{2},\ x^{4}\right\}\\
  \end{split}
  \end{align*}
  W powyższych przykładach użyliśmy standardowej notacji w górnym indeksie umieszczając krotność występowania elementu.
\end{przyklad}
\begin{definicja}(Zbiór \(\mathrm{FV}\) zmiennych wolnych)\label{def:untyped_fv}
  Dla dowolnego pretermu \(M\) określamy zbiór \(\mathrm{FV}(M)\) \emph{zmiennych wolnych} w \(M\) w następujący sposób:
\begin{align*}
    \mathrm{FV}(x) &= \{x\}\\
    \mathrm{FV}(\lambda x .\, P)  &= \mathrm{FV}(P)\setminus\{x\}\\
    \mathrm{FV}(P Q) &= \mathrm{FV}(P)\cup\mathrm{FV}(Q)
\end{align*}
  Jesli \(\mathrm{FV}(M)=\emptyset\), to mówimy, że \(M\) jest \emph{domknięty} lub nazywamy \(M\) \emph{kombinatorem}.
\end{definicja}
\begin{przyklad}
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item \(\mathrm{FV}(\lambda x.\,x\,y)=\left\{y\right\}\)
    \item \(\mathrm{FV}(x\,(\lambda x.\, x\,y)) = \left\{x,\ y\right\}\)
    \item \(\mathrm{FV}(\lambda x y z.\, x y) = \emptyset\)
  \end{enumerate}
\end{przyklad}


\begin{definicja}(Podstawienie)\label{def:substitution}
  Dla dowolnych \(\mathrm{M,\,N}\in\mathbf{\tilde\Lambda}\) i \(x\in V\) przez \(N[x/N]\) oznaczamy rezultat podstawienia termu \(N\) za wszystkie wolne wystąpienia zmiennej \(x\) w \(M\), o ile w rezultacie podstawienia nie zostaną związane żadne zmienne wolne występujące w \(N\). W takim wypadku:
  \begin{enumerate}[label={(S\arabic*)}, ref={(S\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x[x/N] = N\)
    \item \(y[x/N] = y,\ \text{o ile}\ x\not\equiv y\)
    \item \((PQ)[x/N] = P[x/N]\,Q[x/N]\)\label{def:substitution_c}
    \item \((\lambda y.\, P)[x/N] = \lambda y.\,P[x/N],\ \text{gdzie}\ x\not\equiv y\ \text{i}\ y\not\in \mathrm{FV}(N)\)
    \item \((\lambda x.\, P)[x/N] = \lambda x.\,P\)\label{def:substitution_e}
  \end{enumerate}
\end{definicja}

\begin{lemat}(O podstawieniu)\label{lem:substitution}
  Niech \(M,\,N,\,L\in \mathbf{\tilde\Lambda}\) i niech ponadto \(x\not\equiv y\) oraz \(x\not\in\mathrm{FV}(L)\). Wówczas
  \begin{align}\label{eq:substitution}
    M[x/N][y/L]\equiv M[y/L]\left[x/N\left[y/L\right]\right].
  \end{align}
  \begin{dowod}
    Dowód przebiega przez indukcję strukturalną względem \(M\). Rozważmy następujące przypadki:
    \begin{enumerate}[label={\roman*)}, ref={(\arabic*)}]
      \item \(M\) jest zmienną. Wówczas:
        \begin{enumerate}[label={\alph*.}]
        \item Jeśli \(M\equiv x\), to obie strony \eqref{eq:substitution} po podstawieniu są eostaci \(N[y/L]\).
        \item Jeśli \(M\equiv y\), to ponieważ \(x\not\equiv y\) i \(x\not\in\mathrm{FV}(M)\), po wykonaniu podstawienia po lewej stronie \eqref{lem:substitution} otrzymujemy \(M[x/N][y/L]\equiv L\). Ponieważ \(x\not\in\mathrm{FV}(L)\), to po wykonaniu podstawienia po prawej stronie widzimy, że obydwie strony są identyczne.

        \item Jeśli \(M\equiv z\) i \(z\not\equiv x\)  oraz \(z\not\equiv y\), to obydwie strony \eqref{eq:substitution} sa identyczne.
        \end{enumerate}

      \item \(M\equiv P Q\) dla pewnych \(P,\,Q\in\mathbf{\tilde\Lambda}\). Wówczas korzystając z hipotezy indukcyjnej wnosimy, że
        \begin{align*}
          P[x/N][y/L]\equiv P[y/L]\left[x/N\left[y/L\right]\right],\\
          Q[x/N][y/L]\equiv Q[y/L]\left[x/N\left[y/L\right]\right].
        \end{align*}
        Mając na względzie \ref{def:substitution_c} widzimy, że twierdzenie zachodzi i w tym przypadku.
        \item Jeśli \(M\equiv \lambda z.\,P\) oraz \(z\equiv x\) lub \(z\equiv y\), to z \ref{def:substitution_e} widzimy, że obydwie strony \eqref{eq:substitution} sa identyczne. Przypuśćmy, że \(z\not\equiv x\) i \(z\not\equiv y\) i \(z\not\in\mathrm{FV}(L)\). Wówczas na podstawie hipotezy indukcyjnej mamy:
      \begin{align*}
        (\lambda z.\,P)[x/N][y/L] &= \lambda z.\,P[x/N][y/L] =\\
                                  &= \lambda z.\,P[y/L][x/N[y/L]] =\\
                                  &= (\lambda z.\,P)[y/L][x/N[y/L]].
      \end{align*}
    \qed
    \end{enumerate}
  \end{dowod}
\end{lemat}

\begin{wniosek}\label{thm:odwracalnosc_podstawienia}
Jesli \(M[x/y]\) jest określone i \(y\not\in\mathrm{FV}(M)\), to \(M[x/y][y/x]\) jest określone oraz
  \(M[x/y][y/x]=M\).
  \begin{dowod}
    Mając na uwadze Lemat \ref{def:substitution} dowód przebiega przez indukcję strukturalną względem \(M\).
    \qed
  \end{dowod}
\end{wniosek}



\subsection{Wyrażenia \(\lambda\)}
Na ogół chcielibyśmy utożsamiać pretermy, które różnią się wyłącznie zmiennymi związanymi, tak jak w przypadku wyrażeń \(\lambda x. \,zx\) i \(\lambda y.zy\). W takim wypadku powiemy o nich, że są swoimi \emph{\(\alpha\)-wariantami} lub że są ze sobą w relacji \emph{\(\alpha\)-konwersji}.

\begin{definicja}(Relacja \(\alpha\)-konwersji)\label{def:untyped_alpha}
  Relacją \(=_{\alpha}\) (\(\alpha\)-konwersji) nazywamy najmniejszy w sensie mnogościowym praporządek na \(\mathbf{\tilde\Lambda}\) taki, że
  \begin{enumerate}[label={(\(\alpha\)\arabic*)}, ref={(\(\alpha\)\arabic*)}]
  \setlength\itemsep{0em}
  \item Jeśli \(y\not\in \mathrm{FV}(M)\) oraz \(M[x/y]\) jest określone,\\ to \(\lambda x.\,M~=_{\alpha}~\lambda y.\,M[x/y]\)\label{def:alpha_1}
  \item Jeśli \(M=_{\alpha} N\), to dla dowolnego \(x\in V\) zachodzi \(\lambda x.\,M =_{\alpha} \lambda x.\,N\)\label{def:alpha_2}
  \item Jeśli \(M=_{\alpha} N\), to dla dowolnego \(Z\in\mathbf{\tilde\Lambda}\) zachodzi \(MZ =_{\alpha} NZ\)\label{def:alpha_3}
  \item Jeśli \(M=_{\alpha} N\), to dla dowolnego \(Z\in\mathbf{\tilde\Lambda}\) zachodzi \(ZM =_{\alpha} ZN\)\label{def:alpha_4}
  \end{enumerate}
\end{definicja}

\begin{przyklad}
  \begin{align*}
    \lambda x y.\,x(xy) &\equiv \lambda x.\,(\lambda y.\,x(xy)) \\
                        &\equiv_\alpha \lambda x.\,(\lambda z.\,x(xz)) \\
                        &\equiv_\alpha \lambda v.\,(\lambda z.\,v(vz)) \\
                        &\equiv \lambda vz.\,v(vz).
  \end{align*}

\end{przyklad}

\begin{wniosek}
  Relacja \(=_{\alpha}\) jest relacją równoważności.
  \begin{dowod}
    Wystarczy, że pokażemy, że relacja \(=_{\alpha}\) jest symetryczna. Dowód przebiega przez indukcję względem Definicji \ref{def:untyped_alpha}. Rozważmy następujące przypadki:
    %Fakt \ref{def:odwracalnosc_podstawienia}

    \begin{enumerate}[label={\roman*)}, ref={(\roman*)}]
      \item Jeśli \(M=_{\alpha} N\) w konsekwencji zwrotności \(=_{\alpha}\), to \(M\equiv N\), a zatem również \(N\equiv M\). Stąd \(N=_{\alpha} M\).
      \item Jeśli \(M=_{\alpha} N\) w konsekwencji przechodniości \(=_{\alpha}\), to istnieje \(L\in\mathbf{\tilde\Lambda}\) takie, że \(M=_{\alpha}L\) i \(L=_{\alpha}N\). Wówczas z hipotezy indukcyjnej \(N=_{\alpha}L\) i \(L=_{\alpha}M\). Z przechodniości relacji \(=_{\alpha}\) otrzymujemy spodziewaną tezę.
      \item Przypuśćmy, że \(M=_{\alpha} N\) w konsekwencji  \ref{def:alpha_1}  dla \(M\equiv\lambda x.\,M'\) i \(N\equiv\lambda y.\,M'[x/y]\). Ponieważ \(x\not\in\mathrm{FV}(M'[x/y])\), to ze względu na Wniosek \ref{thm:odwracalnosc_podstawienia} mamy, że \(M'[x/y][y/x]=M'\). Zatem, na podstawie \ref{def:alpha_1}:
  \begin{align*}
        \lambda y.\,M'[x/y] =_{\alpha} \lambda x.\,M'[x/y][y/x].
      \end{align*}
    \item  Jeśli \(M=_{\alpha} N\) w konsekwencji \ref{def:alpha_2}, gdzie \(M=\lambda x.\,M'\) i \(N=\lambda x.\,N'\) dla \(M'=_{\alpha} N'\), to z hipotezy indukcyjnej \(N' =_{\alpha} M'\) i w konsekwencji \ref{def:alpha_2} mamy, że \(N=_{\alpha} M\).
    \item  Jeśli \(M=_{\alpha} N\) w konsekwencji \ref{def:alpha_3} dla \(M\equiv M'Z\) i \(N\equiv N'Z\) takich, że \(M'=_{\alpha}N'\), to z hipotezy indukcyjnej oczywiście \(N'=_{\alpha}M'\), a zatem z \ref{def:alpha_3} \(N=_{\alpha} M\).\label{proof:alpha_cases_4}
    \item  Jeśli \(M=_{\alpha} N\) w konsekwencji \ref{def:alpha_3}, to postępujemy jak w przypadku \ref{proof:alpha_cases_4}.\qed
    \end{enumerate}
  \end{dowod}
\end{wniosek}

\begin{definicja}(Zbiór \(\mathbf{\Lambda}\) \(\lambda\)-termów)
  Każdą klasę abstrakcji relacji \(=_{\alpha}\) nazywamy \(\lambda\)-termem. Zbiór wszystkich \(\lambda\)-termów \(\mathbf{\Lambda}\) to zbiór ilorazowy relacji \(\alpha\)-konwersji:
  \begin{align*}
    \mathbf{\Lambda}=\left\{[M]_{=_\alpha}\ |\ M\in\mathbf{\tilde\Lambda}\right\}
  \end{align*}
\end{definicja}

\begin{konwencja*}
Wprowadzamy następujące konwencje notacyjne:
\begin{align*}
  &x = [x]_{=_\alpha},\\
  &PQ = [M'N']_{=_\alpha},\ \text{gdzie}\ M=[M']_{=_\alpha}\ \text{i}\ N=[N']_{=_\alpha},\\
  &\lambda x.\,M =  [\lambda x.\,M']_{=_\alpha},\  \text{gdzie}\ N=[N']_{=_\alpha}.
\end{align*}
\end{konwencja*}
%Nie prowadzą one do niejednoznaczności, w czym upewnia nas Lemat \ref{lem:uniqueness}.

%\begin{lemat}(O jednoznaczności)\label{lem:uniqueness}
%  Dla dowolnych \(M,\,N
%\end{lemat}

Na zbiór \(\mathbf{\Lambda}\) przenoszą się pojęcia podtermu, zmiennych wolnych i operacji podstawienia definiowane uprzednio dla pretermów.

\begin{definicja}(Multizbiór \(\mathrm{Sub}\) podtermów \(\lambda\)-termu)
  Dla dowolnego \(\lambda\)-termu \(M=[M']_{=_{\alpha}}\) okreslamy
  \[
    \mathrm{Sub}(M)=\mathrm{Sub}(M'),
  \]
  gdzie \(\mathrm{Sub}(M')\) jest multizbiorem podwyrażeń pretermu \(M'\) zdefiniowanym w myśl Definicji \ref{def:untyped_subterm}.
\end{definicja}

\begin{definicja}(Zbiór zmiennych wolnych \(\mathrm{FV}\))
  Dla dowolnego \(\lambda\)-termu \(M=[M']_{=_{\alpha}}\) określamy zbiór \(\mathrm{FV}(M)\) \emph{zmiennych wolnych} w \(M\)
  \[
    \mathrm{FV}(M)=\mathrm{FV}(M'),
  \]
  gdzie \(\mathrm{FV}(M')\) jest zbiorem zmiennych wolnych pretermu \(M'\) zdefiniowanym w myśl Definicji \ref{def:untyped_fv}.
\end{definicja}

\begin{definicja}(Podstawienie)\label{def:untyped_lambda_substitution}
  Niech \(M=[M']_{=_\alpha}\) i \(N=[N']_{=_\alpha}\) i niech \(M'[x/N']\) będzie określone w myśl Definicji \ref{def:substitution}. Wówczas
  \[
    M[x/N]= [M'[x/N']]_{=_\alpha}.
  \]
\end{definicja}

Operacja podstawienia wymaga jednak pewnej delikatności. Rozważmy następującą relację:
\[
  \lambda x.\,zx=_{\alpha}\lambda y.\,zy
\]
Zauważmy, że traktując podstawienie w sposób naiwny, mamy, że \((\lambda x.\,zx)[z/x]\neq_{\alpha}(\lambda y.\,zy)[z/x]\), a więc tracimy pożądaną własność niezmienniczości \(\alpha\)-konwersji względem podstawienia. Stąd w Definicji \ref{def:substitution} wymóg, aby podstawienie nie prowadziło do uszczuplenia zbioru zmiennych wolnych. Alternatywnym rozwiązaniem jest określenie podstawienia, które wprowadzałoby do wyrażenia nową zmienną i prowadziło w konsekwencji do abstrahowania po wcześniej nie występujacych zmiennych:
\[
  (\lambda x.\,M)[y/N] = \lambda x'.\,M[x/x'][y/N],
\]
w przypadku, gdy \(x\not\equiv y\), gdzie \(x'\not\in\mathrm{FV}(M)\) i \(x'\not\in\mathrm{FV}(N)\). Rozstrzygnięcie takie przytacza się w \cite{Hindley:2008:LCI:1388400,}. Po uwzględneniu odpowiednich modyfikacji, Definicja \ref{def:substitution} przyjmuje następującą postać:
\begin{customdef}{4'}(Podstawienie')\label{def:untyped_substitution_hindley}
  \begin{enumerate}[label={(S'\arabic*)}, ref={(S'\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x[x/N] = N\)
    \item \(y[x/N] = y,\ \text{o ile}\ x\not\equiv y\)
    \item \((PQ)[x/N] = P[x/N]\,Q[x/N]\)
    \item \((\lambda x.\, P)[x/N] = \lambda x.\,P\)
    \item \((\lambda y.\, P)[x/N] = \lambda y.\,P\), jeśli \(x\not\in\mathrm{FV}(P)\)\label{def:substitution_e}\label{def:substitution_hindley_e}
    \item \((\lambda y.\, P)[x/N] = \lambda y.\,P[x/N],\ \text{gdzie}\ x\in\mathrm{FV}(P)\) i \(y\not\in\mathrm{FV}(N)\)\label{def:substitution_hindley_f}
    \item \((\lambda y.\, P)[x/N] = \lambda z.\,P[y/z][x/N],\ \text{gdzie}\ x\in\mathrm{FV}(P)\) i \(y\in\mathrm{FV}(N)\)\label{def:substitution_hindley_g}
  \end{enumerate}
  przy czym w \ref{def:substitution_hindley_g} wymagamy, aby zmienna \(z\) nie występowała wcześniej w termach \(N\) i \(P\) jako zmienna wolna, zaś dla \ref{def:substitution_hindley_e}-\ref{def:substitution_hindley_g} dodatkowo \(y\not\equiv x\).
\end{customdef}
\begin{uwaga}
Każde podstawienie \([x/N]\) jest funkcją z \(\mathbf{\Lambda}\to\mathbf{\Lambda}\), gdzie \(x\in V\) i \(N\in\mathbf{\Lambda}\) są dowolnymi parametrami. Zbiór \(S\) podstawień ma strukturę monoidu z działaniem składania
  \begin{align*}
    M([x_2/N_2]\circ[x_1/N_1]) = (M[x_1/N_1])[x_2/N_2] \equiv M[x_1/N_1][x_2/N_2]
  \end{align*}
  dla dowolnych \([x_1/N_1],\,[x_2/N_2]\in S\), o ile \(S\) posiada element neutralny \(\iota\) taki, że
  \begin{align*}
    M \iota = M,\ \text{gdzie}\ [x/x]=\iota\ \text{dla dowolnego}\ x\in V.
  \end{align*}
\end{uwaga}

W literaturze znajdujemy mnogość propozycji, które w ten czy inny sposób starają się ułatwić rzeczywistą implementację podstawienia. Na szczególną uwagę zasługują tutaj tak zwane \emph{indeksy de Bruijna}. Zaproponowana przez N. G. de Brujina w \cite{deBruijnIndices}  notacja eliminuje bezpośrednie występowanie symboli zmiennych w \(\lambda\)-termach, zastępując je liczbą naturalną wyrażającą głębokość zagnieżdżenia odpowiedniej \(\lambda\)-abstrakcji przez którą jest związana, przykładowo:
\[
  \lambda f.\,(\lambda x.\,(f(xx))\lambda x.\,(f(xx))) \equiv_{de Brujin} \lambda (\lambda 2 (1 1)) \lambda 2 (1 1)
\]
Historycznie wiąże się ta notacja z jego pracami nad systemem komputerowo wspomaganego dowodzenia twierdzeń AUTOMATH. Rozwiązanie takie, podobnie jak w przypadku tzw. logik kombinatorów, eliminuje konieczność utożsamiania termów przez \(\alpha\)-konwersję, ale istotnie zmniejsza ich czytelność.

Szerszy komentarz dotyczący dotychczasowych prób uchwycenia operacji podstawienia można prześledzić w \cite{txa:alpha-draft}. Nasze rozważania opierają się w tej materii przeważająco na \cite{Urzyczyn2006}. Samo podejście do definiowania \(\lambda\)-termow przez operację \(\alpha\)-konwersji nie jest powszechne w literaturze przedmiotu. Analogiczną konstrukcję należałoby powtarzać wprowadzając każdy kolejny system, dlatego w dalszej części tej pracy będziemy poprzestawali na nieformalnym traktowaniu wyrażeń danego systemu jako odpowiednich klas \(\alpha\)-konwersji.

% \subsection{Podstawienie jednoczesne}
% Biorąc pod uwagę sens obliczeniowy rachunku \(\lambda\) interesujące okazuje się modyfikacja Definicji \ref{def:untyped_substitution_hindley} w  taki sposób, aby podstawienie miało miejsce dla wielu zmiennych równolegle w całym \(\lambda\)-termie. Za przykładem \cite{STOUGHTON1988317} wprowadzimy \emph{podstawienie jednoczesne}. W tym celu jednak uściślenia wymagają pewne pojęcia.

\begin{definicja}(Podstawienie jednoczesne)\label{def:simult_substitution}
Dla dowolnego \(M\in\mathbf{\Lambda}\), ciągu \(\lambda\)-zmiennych~\(\vec{x}\) i ciągu \(\lambda\)-termów \(\vec{N}\) określamy:
  \begin{enumerate}[label={(\(\vec{s}\)\arabic*)}, ref={(\arabic*)}]
    \setlength\itemsep{0em}
    \item \(x_i[\vec{x}/\vec{N}]=N_i\) dla \(i\in\mathbb{N}\).
    \item \(y[\vec{x}/\vec{N}]=y\) o ile dla dowolnego \(i\in\mathbb{N},\ y\not\equiv x_i\).
    \item \((PQ)[\vec{x}/\vec{N}]=P[\vec{x}/\vec{N}]Q[\vec{x}/\vec{N}]\)
%    \item \((\lambda y.\,P)[\vec{x}/\vec{N}]=\lambda y'.\,P[y/y'][\vec{x}/\vec{N}]\), gdzie \(y'\) jest wcześniej nie występującą zmienną, \(y\not\equiv x_i\)  dla wszystkich \(i\in\mathbb{N}\) i \(y\not\in\bigcup_{i\in\mathbb{N}}FV(N_i)\).
    \item \((\lambda y.\,P)[\vec{x}/\vec{N}]=\lambda y.\,P[\vec{x}/\vec{N}]\), jeśli \(y\neq x_i\) dla wszystkich \(i\in\mathbb{N}\) i \(y\not\in\bigcup_{i\in\mathbb{N}}FV(N_i)\)
 \end{enumerate}
\end{definicja}

\begin{konwencja*}
  Jeśli \(N_i\equiv x_i\) dla wszystkich poza skończenie wieloma \(i_1,\,i_2,\,\dots,\,i_n\in~\mathbb{N}\), to \([x_{i_1}/N_{i_1},\,x_{i_2}/N_{i_2},\,\dots,\,x_{i_n}/N_{i_n}]\equiv [\vec{x}/\vec{N}]\).
\end{konwencja*}

\begin{przyklad}
  Zauważmy, że podstawienia w myśl Definicji \ref{def:substitution} i Definicji \ref{def:simult_substitution} mogą, ale nie muszą, prowadzić do różnych rezultatów.
\begin{align*}
  \text{a)}\quad &  (xy)[y/x][x/u] = uu, &\quad\text{b)}\quad & (\lambda x.\,yx)[x/y][y/z]=\lambda x.\,zx, \\
                &  (xy)[y/x, x/u] = ux. & &(\lambda x.\,yx)[x/y,y/z]=\lambda x.\,zx.\\
\end{align*}

\end{przyklad}
\subsection{Redukcja}
Sens obliczeniowy \(\lambda\)-termom nadajemy przez określenie na \(\mathbf{\Lambda}\) operacji \(\beta\)- i \(\eta\)-redukcji. Pożądane jest, żeby operacje te wykonywane na podtermach pozostowały w \emph{zgodzie} ze strukturą całego \(\lambda\)-termu.

\begin{definicja}(Relacja zgodna)
  Relację binarną \(\mathcal{R}\) na zbiorze \(\mathbf{\Lambda}\) nazywamy \emph{zgodną}, jeśli dla dowolnych \(M,\,N,\,P \in \mathbf{\Lambda}\) zachodzą następujące warunki:
  \begin{enumerate}[label={(c\arabic*)}, ref={(\arabic*)}]
    \setlength\itemsep{0em}
    \item Jeśli \(M \mathcal{R} N\), to \((\lambda x.\,M)\,\mathcal{R}\,(\lambda x.\,N)\) dla dowolnej \(\lambda\)-zmiennej \(x\).
    \item Jeśli \(M \mathcal{R} N\), to \((MP)\,\mathcal{R}\,(NP)\).
    \item Jeśli \(M \mathcal{R} N\), to \((PM)\,\mathcal{R}\,(PN)\).
  \end{enumerate}
\end{definicja}
Przez \emph{domknięcie relacji} \(\mathcal{R}_1\) będziemy rozumieli najmniejszą (w sensie mnogościowym) relację \(\mathcal{R}_2\) taką, że \(\mathcal{R}_1\subset\mathcal{R}_2\).
  Z pewnego rodzaju domknięciami, ze względu na ich szczególną rolę, wiążemy następującą notację:
  \begin{enumerate}[label=(\alph*), ref={(\alph*)}]
    \setlength\itemsep{0em}
    \item Przez \(\mathcal{R}^{+}\) oznaczamy przechodnie domknięcie relacji \(\mathcal{R}\).\label{def:closure_a}
    \item Przez \(\mathcal{R}^{*}\) oznaczamy zwrotnie domknięcie relacji \(\mathcal{R}^{+}\).\label{def:closure_b}
    \item Przez \(=_{\mathcal{R}}\) oznaczamy symetryczne domknięcie relacji \(\mathcal{R}^{*}\).\label{def:closure_c}
\end{enumerate}
Dla lepszego zrozumienia powyższych operacji warto zauważyć, że \ref{def:closure_b} wyznacza praporzadek, który w odniesieniu do redukcji określonych na \(\mathbf{\Lambda}\) można rozumieć jako graf skierowany (w przypadku \(\mathbf{\Lambda}\) być może nieskończony) w którym krawędzie odpowiadają możliwym krokom obliczenia, zaś \ref{def:closure_c} -- kongruencję, która znów w szczególnym odniesieniu do \(\lambda\)-termów, będzie dokonywała podziału w \(\mathbf{\Lambda}\) ze względu na rezultat obliczenia.
\begin{definicja}(\(\beta\)-redukcja)
  \(\beta\)-redukcją nazywamy najmniejszą (w sensie mnogościowym) zgodną na \(\mathbf{\Lambda}\) relację binarną \(\to_\beta\) taką, że
  \[
    (\lambda x.\,M)N\rightarrow_\beta M[x/N].
  \]
\emph{\(\beta\)-redeksami} bedziemy nazywali wyrażenia postaci \((\lambda x.\, M)N\), zaś rezultat ich \(\beta\)-redukcji w postaci termu \(M[x/N]\) -- \emph{\(\beta\)-reduktem}. \emph{Ciągiem} \(\beta\)-redukcji nazywamy skończony lub nieskończony ciąg postaci
  \[
    M_0 \to_\beta M_1 \to_\beta \dots
  \]
\end{definicja}
  \begin{przyklad}Oznaczmy \(\mathrm{Y}=\lambda f.\,(\lambda x.\,(f(xx))\lambda x.\,(f(xx)))\) i niech \(F\) będzie dowolnym \(\lambda\)-termem. Wówczas otrzymujemy nieskończony ciąg redukcji postaci
    \begin{align*}
      \mathrm{Y}F &\equiv (\lambda f.\,(\lambda x.\,(f(xx))\lambda x.\,(f(xx))))F\\
                  &\to_\beta (\lambda x.\,F(xx))\lambda x.\,F(xx)\\
                  &\to_\beta F((\lambda x.\,F(xx))\lambda x.\,F(xx))\\
                  &\to_\beta F(F((\lambda x.\,F(xx))\lambda x.\,F(xx)))\\
                  &\to_\beta \dots
    \end{align*}
  \end{przyklad}
\begin{definicja}(\(\eta\)-redukcja)
  \(\eta\)-redukcją nazywamy najmniejszą (w sensie mnogościowym) zgodną na \(\mathbf{\Lambda}\) relację binarną \(\to_\eta\) taką, że
  \[
    \lambda x.\,Mx\to_\eta M,\ \text{o ile}\ x\not\in \mathrm{FV}(M).
  \]

  \(\eta\)-redukcja pozwala na pominięcie niczego nie wnoszącej \(\lambda\)-abstrakcji. Operację odwrotną nazywamy \emph{\(\eta\)-abstrakcją}, zaś \(\lambda\)-termy będące w którejkolwiek z tych relacji nazywamy \emph{\(\eta\)-konwersami}. Operacja ta nie ma wpływu na rezultat obliczenia, jedynie optymializuje zapis \(\lambda\)-termów i stąd ma duże znaczenie stylistyczne w programowaniu funkcyjnym.
  \end{definicja}

  \begin{przyklad}
    \(\lambda x. ((+1) x) =_\eta (+1) \).
  \end{przyklad}

  \subsection{Kodowanie typów danych}
Prosta składnia języka rachunku \(\lambda\) pozwala wyrazić zaskakująco wiele struktur danych reprezentując je i operacje na nich jako funkcje. Z tego powodu, stanowiąc inspirację dla wielu projektantów języków programowania, uchodzi za protoplastę rodziny języków funkcyjnych, chociaż bezpośrednio nie ma on praktycznego zastosowania w praktyce programistycznej. Rozwój tej legendy dobrze oddaje cykl klasycznych artykułów (tzw. \emph{Lambda Papers}) zapoczątkowany przez dokumentację języka Scheme \cite{Sussman:1975:IEL:889230}.

Najpopularniejszym sposobem reprezentacji danych przez funkcje w rachunku \(\lambda\) oparty jest na kodowaniu liczb Peano za pomocą tzw. liczebników Churcha. Metoda ta, ze względu na wynikające zeń problemy natury złożonościowej \cite{Koopman:2014:CED:2746325.2746330}, ma obecnie wyłącznie walory edukacyjne, dlatego w dalszej cześci pracy pokażemy tzw. kodowanie Scotta. Jest ona interesująca ze względu na praktyczną możliwość reprezentacji algebraicznych typów danych (ADT\footnote{Skrót od angielskojęzycznego \emph{Algebraic Data Types}; nie należy mylić z \emph{Abstract Data Types}.}) znanych ze współczesnych języków funkcyjnych \cite{Jansen:2013:P9C:2941698.2941710}, pozwalając tym samym zaimplementować te konstrukcje na przykład w paradygmacie imperatywnym. Fakt, że każdy typ danych można zastąpić tym sposobem odpowiadającą mu funkcją, wskazuje na metodę konstruowania prostych języków funkcyjnych \cite{Jensen_2006} oraz na uniwersalność rachunku \(\lambda\) jako języka przejściowego dla kompilatorów języków funkcyjnych \cite[Rozdział 3]{PeytonJones:1992:IFL:129390}.

\subsubsection{Algebraiczne typy danych}
Algebraiczne typy danych są podstawowym środkiem współczesnych języków funkcyjnych do wyrażania struktur danych. Powstają one przy użyciu tzw. typów sumacyjnych i typów produktowych, jednak pojęcia te na gruncie formalnym będą szczegółowo omówione w późniejszej części pracy. Na potrzeby prezentacji poszczególnych kodowań wystarczą nam w tym rozdziale intuicje o ADT zbudowane na gruncie następujących definicji w języku Haskell:

\begin{minted}{haskell}
  data Boolean     = True
                   | False
  data Tuple a b   = Tuple a b
  data Temperature = Fahrenheit Int
                   | Celsius Int
  data Maybe a     = Nothing
                   | Just a
  data Nat         = Zero
                   | Succ Nat
  data List t      = Nil
                   | Cons t (List t)
\end{minted}
Definicja typu rozpoczynają się od słowa kluczowego \texttt{data}\footnote{Dyskusja ta ma na celu wyłącznie ustalenie uwagi; świadomi jesteśmy niuansów związanych z określaniem synonimów typów lub definiowaniem typów przy pomocy słowa kluczowego \texttt{newtype}.} po którym występuje \emph{konstruktor typu}. Na wzór notacji BNF, typy przyjmują jedną z \emph{wartości} odzielonych znakiem "|". Każda z wartości składa się z \emph{konstruktora wartości} i ewentualnie występujących po nim \emph{parametrów typowych}. Zauważmy, że umożliwia to rekurencyjnie konstruowanie typów, tak jak w wypadku \texttt{Nat} i \texttt{List}.

Pokażemy, że algebraiczne typy danych możemy reprezentować w zwięzły sposób w rachunku \(\lambda\) bez typów. Przedstawione tutaj koncepcje w zaskakujący sposób przenoszą się do bardziej złożonych typowanych systemów rachunku \(\lambda\).

\subsubsection{Proste typy wyliczeniowe}\label{ref:untyped_simple_enumeration}
Typy wyliczeniowe to typy, które reprezentują możliwe warianty przyjmowanej wartości. Najprostrzym nietrywialnym przykładem takiego typu jest \texttt{Boolean}. Ma on dwa konstruktory wartości: \texttt{True}, \texttt{False}. Praca z tego rodzaju typami wymaga mechanizmu dopasowywania wzorców (ang. \emph{pattern-matching}) \cite[Rozdział IV]{PeytonJones:1992:IFL:129390}, który pozwala na wybór częściowej definicji funkcji w zależności od zadanego konstruktora wartości. Ponieważ w rachunku \(\lambda\) wyrażenia nie mają typów (lub, przyjmując perspektywę systemów z typami: wszystkie wyrażenia mają jeden, ten sam typ), interesowało nas będzie nie bezpośrednie kodowanie typu, ale kodowanie mechanizmu, który odpowiada za dopasowywanie wzorców. Posłużmy się znowu przykładem z języka Haskell i określmy funkcję odpowiadającą wykonaniu instrukcji warunkowej:
\begin{minted}{haskell}
if True  a b = a
if False a b = b
\end{minted}
gdzie \texttt{True} i \texttt{False} są wartościami typu \texttt{Boolean}. Właśnie ze względu na nie, mechanizm dopasowywania wzorca wybiera odpowiednią implementację instrukcji warunkowej. Ten sam efekt osiągnęlibyśmy kodując \texttt{True} i \texttt{False} w rachunku \(\lambda\) w następujący sposób:
\begin{align*}
  \mathrm{True} &\equiv \lambda a b.\,a\\
  \mathrm{False} &\equiv \lambda a b.\,b
\end{align*}
Wówczas funkcję \texttt{if} możemy reprezentować wyrażeniem \(\mathrm{if}\equiv\lambda c t e.\, cte\) lub jego \(\eta\)-reduktem: \(\lambda c.\,c\).

\subsubsection{Pary w rachunku \(\lambda\)}
Parą nazywamy każdy nierekurencyjny typ, który posiada jeden konstruktor wartości parametryzowany przez dwa typy. W takim wypadku potrzebujemy dwóch projekcji zwracających odpowiednio pierwszy i drugi element pary. Przykładem takiego typu jest \texttt{Tuple}. Mamy wówczas:
\begin{minted}{haskell}
  fst (Tuple a b) = a
  snd (Tuple a b) = b
\end{minted}
Tego rodzaju typy możemy reprezentować przez tak zwane \emph{domknięcie} (ang. \emph{closure}), czyli cześciową aplikację termu. Standardowym sposobem reprezentacji pary w rachunku \(\lambda\) jest:
\begin{align*}
  \mathrm{Tuple}\equiv\lambda a b f .\,f a b
\end{align*}
Aplikując \(\mathrm{Tuple}\) tylko do dwóch termów (\emph{domykając} term Tuple) otrzymujemy reprezentację pary. Pozostały, trzeci argument \(f\) nazywamy \emph{kontynuacją}, gdyż aplikując \((\mathrm{Tuple}\ x\ y)\) dla dowolnych \(x, y\in\mathbf{\Lambda}\) do pewnego \(f\in\mathbf{\Lambda}\), w konsekwencji \(x\) i \(y\) zostają zaaplikowane do \(f\).
Zauważmy, że wówczas reprezentacja \texttt{fst} i \texttt{snd} ma postać:
\begin{align*}
  \mathrm{fst} \equiv \lambda t.\,t(\lambda a b.\,a) \\
  \mathrm{snd} \equiv \lambda t.\,t(\lambda a b.\,b)
\end{align*}

\begin{przyklad}
  Wprowadzone konstrukcje pozwalają nam na definicję skończonych (w sensie liczby konstruktorów) typów. Rozważmy następujące przykłady:
  \begin{enumerate}[label=\alph*)]
    \setlength\itemsep{0em}
    \item Konstruktory wartości typu \texttt{Maybe} możemy reprezentować przez
      \begin{align*}
        \mathrm{Nothing}&\equiv \lambda nj.\,n\\
        \mathrm{Just}&\equiv \lambda anj.\,j a
      \end{align*}
      Rozważmy następującą funkcję:
      \begin{minted}{haskell}
        maybe :: b -> (a -> b) -> Maybe a -> b
        maybe n _ Nothing  = n
        maybe _ f (Just x) = f x
      \end{minted}
      Odpowiadająca jej reprezentacja to
      \begin{align*}
        \mathrm{maybe} \equiv \lambda b f t.\, tb(\lambda a.\,fa)
      \end{align*}
    \item Rozważmy następującą funkcję
      \begin{minted}{haskell}
        fromTemperature :: Temperature -> Int
        fromTemperature (Fahrenheit a) = a
        fromTemperature (Celsius a) = a
      \end{minted}
      Ustalając reprezentację konstruktorów \texttt{Fahrenheit} i \texttt{Celsius}:
      \begin{align*}
        \mathrm{Fahrenheit}\equiv \lambda tfc.\,ft\\
        \mathrm{Celsius}\equiv \lambda tfc.\,ct
      \end{align*}
      otrzymujemy reprezentację funkcji \texttt{formTemperature} postaci:
      \begin{align*}
        \mathrm{fromTemperature}\equiv\lambda t.\,t(\lambda f.\,f)(\lambda c.\,c)
      \end{align*}
  \end{enumerate}
\end{przyklad}

\subsubsection{Kodowanie rekurencji}
 Rozważmy następującą funkcję dodawania liczb Peano w języku Haskell:
\begin{minted}{haskell}
  add Zero     m = m
  add (Succ n) m = Succ (add n m)
\end{minted}
Funkcję tę możemy wyrazić w rachunku \(\lambda\) przy pomocy kodowania Scotta w następujący sposób:
\begin{align*}
  \mathrm{add_0} \equiv \lambda n m.\:n\,m\,(\lambda n.\:\mathrm{Succ}(\mathrm{add_0}\,n\,m))
\end{align*}
Formalizm rachunku \(\lambda\) nie pozwala na okreslanie nowych nazw i rekurencyjne odnoszenie się przez nie do nich samych. Standardową techniką w rachunku \(\lambda\) do określania funkcji w ten sposób jest użycie operatora punktu stałego Y. Przypomnijmy:
\begin{align*}
  \mathrm{Y}\equiv\lambda f.\,(\lambda x.\,(f(xx))\lambda x.\,(f(xx)))
\end{align*}
Wówczas określamy
\begin{align*}
  \mathrm{add_Y}\equiv \mathrm{Y}\,(\lambda a\,n\, m .\ n m\,(\lambda n.\ \mathrm{Succ} (a\,n\,m)))
\end{align*}
Mając na uwadze możliwość przeprowadzenia powyższej konstrukcji przy użyciu rekurencji, będziemy dopuszczali w notacji odnoszenie się wprowadzanych \(\lambda\)-termów do nich samych.

\subsubsection{Kodowanie Scotta typów rekursywnych}
Stosując metody kodowania prostych typów wyliczeniowych i par, łatwo odnajdujemy reprezentację konstruktorów wartości dla typów \texttt{Nat} i \texttt{List}:
\begin{align*}
  \mathrm{Zero} &\equiv \lambda z s .\, z     & \mathrm{Nil} &\equiv \lambda n c.\,n\\
  \mathrm{Succ} &\equiv \lambda n z s.\,sn    & \mathrm{Cons} &\equiv \lambda x \, x_s \, n\, c.\ c \, x \, x_s
\end{align*}
  Zwróćmy uwagę, że konstruktory Nat i Maybe są swoimi \(\alpha\)-konwersami. Podobieństwo nie jest przypadkowe: na poziomie typów konstrukcja Maybe jest odpowiednikiem brania następnika. Określając dodatkowo \(\mathrm{Void}\equiv\lambda x.x\) jako element neutralny działania łącznego, otrzymujemy na poziomie typów strukturę półpierścienia z działaniem mnożenia okresloną przez konstrukcję par i dzałaniem dodawania określonego przez konstrukcję typów wyliczeniowych. Stąd algebraicze typy danych biorą swoją nazwę.

Z łatwością możemy określić teraz operacje brania poprzednika, głowy i ogona listy, odpowiednio:
\begin{align*}
  \mathrm{pred}&\equiv \lambda n .\, n\, \mathrm{undef}\, (\lambda m.\,m)\\
  \mathrm{head}&\equiv \lambda x_s .\, x_s\, \mathrm{undef}\, (\lambda x_s . x)\\
  \mathrm{tail}&\equiv \lambda x_s.\, \mathrm{undef}\, (\lambda x_s.\,x_s)
\end{align*}
gdzie undef jest stałą o którą rozszerzamy rachunek \(\lambda\) celem sygnalizowania błędnej aplikacji.

  Celem lepszego porównania kodowania Churcha i Scotta podamy reprezentacje funkcji \texttt{foldl} dla typu \texttt{Nat}. Określmy:
\begin{minted}{haskell}
  foldl f x Zero     = x
  foldl f x (Succ n) = f (foldl f x n)
\end{minted}
\texttt{foldl} może być przy pomocy kodowania Scotta zapisane jako
\begin{align*}
  \mathrm{foldl}  &\equiv \lambda f\,x\,n.\ n\,x\,(\lambda n.\ (\mathrm{foldl}\ f\ x\ n))
\end{align*}
Ogólnie, przy pomocy \texttt{foldl} wyabstrahowujemy pojęcie tzw. rekursji od strony ogona (ang. \emph{tail recrusion}), w teorii obliczalności nazywane rekursją prostą lub, popularnie, zwijaniem od lewej. Operator foldl spełnia następującą własność \cite{Hutton:1999:TUE:968578.968579}
  \begin{align}\label{def:foldl} 
     f = \mathrm{foldl}\ \varphi\  a \iff \begin{cases}
       f\ \mathrm{Zero}\ =\ a\\
       f\ (\mathrm{Succ}\ n) = \varphi\ (f\ n)
     \end{cases}
  \end{align}
% Zauważmy, że w myśl \eqref{def:foldl} mamy:
% \begin{align*}
%   \mathrm{foldl}\ \mathrm{Succ}\ \mathrm{Zero}\ \mathrm{Zero}\ &= \mathrm{Zero}\\
%   \mathrm{foldl}\  \mathrm{Succ}\ \mathrm{Zero}\ (\mathrm{Succ}\ \mathrm{Zero}) &= \mathrm{Succ}\ (\mathrm{foldl}\ \mathrm{Succ\ Zero\ Zero}) \\
%   &= \mathrm{Succ\ Zero} 
% \end{align*}
% oraz jesli \(\mathrm{foldl\ Succ_{Ch}\ Zero_{Ch}}\ n = m\), to wówczas


\subsubsection{Kodowanie Churcha typów rekursywnych}
Przedstawimy teraz klasyczny sposób kodowania typów po raz pierwszy zaprezentowany dla liczb naturalnych przez A. Churcha w \cite{Church1941-CHUTCO-7}. Różni się on od kodowania Scotta tylko w przypadku typów rekursywnych, w pozostałych przypadkach obydwa kodowania dają te same rezultaty. Typ \texttt{Nat} ma dwa konstruktory: \texttt{Zero} i \texttt{Succ}. W kodowaniu Churcha reprezentujemy je w następujący sposób:
\begin{align*}
  \mathrm{Zero}_{Ch} &\equiv \lambda f x.\,x\\
  \mathrm{Succ}_{Ch} &\equiv \lambda n f x.\,f\,(n\,f\,x)
\end{align*}
Wyrażenia będące skutkiem konsekwentnej aplikacji Succ do Zero w literaturze popularnie nazywa się \emph{liczebnikami Churcha} i oznacza następująco:
\begin{align*}
  \bar{1} &\equiv \mathrm{Succ}_{Ch}\ \mathrm{Zero}_{Ch} \ =_\beta\ \lambda f x.\, fx\\
  \bar{2} &\equiv \mathrm{Succ}_{Ch}\ \mathrm{Succ}_{Ch}\ \mathrm{Zero}_{Ch}\ =_\beta\ \lambda f x.\, f\,f\,x\\
    &\vdots \\
  \bar{n} &\equiv \mathrm{Succ}_{Ch}^n\ \mathrm{Zero}_{Ch}\  =_\beta\  \lambda f x.\, f^n\,x
\end{align*}

Liczba naturalna \(n\) jest kodowana przez funkcję w której jej pierwszy argument jest aplikowany \(n\) razy do drugiego argumentu.
Porównując je do kodowania Scotta widzimy, że różnica polega na aplikowaniu do kontynuacji termu \((n\,f\,x)\) w przypadku brania następnika. Da się pokazać \cite{hinze_2005}, że liczebniki Churcha są w istocie operacją \texttt{foldl} na argumentach \texttt{Succ} i {Zero}. Istotnie, niech \(\mathrm{nat} \equiv \lambda c.\ c\ \mathrm{Succ}\ \mathrm{Zero}\). Wówczas \(\mathrm{nat}\ \bar{n} =_\beta \bar{n}\). Z tego powodu kodowanie operacji na liczebnikach Churcha, lub ogólnie – funkcji opartych na rekursji prostej po zbiorze liczb naturalnych – jest wyjątkowo proste przy użyciu tej metody. Przykładowo, używając metody Churcha, operację dodawania kodujemy w następujący sposób:
\begin{align*}
  \mathrm{add}_{Ch} \equiv \lambda n\, m.\ n\ \mathrm{Succ}_{Ch}\ m
\end{align*}
Dla porównania, używając kodowania Scotta:
\begin{align*}
  \mathrm{add}_{S} \equiv \lambda n\,m.\ \mathrm{foldl}\ \mathrm{Succ}\ n\ m
\end{align*}
\subsubsection{Ogólny schemat kodowania Scotta typów ADT}
W ogólnym przypadku, mając nastepującą definicję ADT:
\begin{minted}{haskell}
  data type_constructor t1 t2 ... tk = C1 t11 ... t1n1
                                     | C2 t21 ... t2n2
                                     ...
                                     | Cm tm1 ... tmnm
\end{minted}
dla \(m, n \in \mathbb{N}\), wiążemy z nią reprezentację każdego z konstruktorów:
\begin{gather*}
  \mathrm{C_1} \equiv \lambda t_{11}\, t_{12}\, \dots t_{1n_1}\, f_1\, f_2 \dots f_m.\ f_1 t_{11} t_{12} \dots t_{1n_1}\\
  \mathrm{C_2} \equiv \lambda t_{21}\, t_{22}\, \dots t_{2n_2}\, f_1\, f_2 \dots f_m.\ f_2 t_{21} t_{22} \dots t_{2n_2}\\
 \vdots\\
  \mathrm{C_m} \equiv \lambda t_{m1}\, t_{m2}\, \dots t_{mn_m}\, f_1\, f_m \dots f_m.\ f_1 t_{m1} t_{m2} \dots t_{mn_m}
\end{gather*}
Wówczas następującą definicję cześciową funkcji \texttt{f}:
\begin{minted}{haskell}
  f (C1 v11 ... v1n1) = y1
  ...
  f (Cm vm1 ... vmnm) = ym
\end{minted}
kodujemy przy za pomocą następujego \(\lambda\)-termu:
\begin{align*}
  \lambda x.\ x\,&(\lambda v_{11}\dots v_{1n_1}.\ y_1)\\
                 &\vdots\\
                 &(\lambda v_{m1}\dots v_{mn_m}.\ y_m)
\end{align*}
gdzie \(y_1\) są kodowaniami Scotta \texttt{yi} dla \(i\in\mathbb{N}\). 

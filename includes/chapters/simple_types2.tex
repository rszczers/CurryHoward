\section{Rachunek \(\lambda\) z typami prostymi}\label{sec:simple_types}
\subsection{Typy proste}\label{ssec:typy-proste}
Niech \(U\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych \(p,\ q,\ \dots\ \) (być może indeksowanych liczbami naturalnymi), które będziemy nazywali \emph{zmiennymi typowymi}.

\begin{definicja}\label{def:typy-proste}(Typy proste)
\emph{Typami prostymi} będziemy określali najmniejszy w sensie mnogościowym zbiór wyrażeń taki, że:
\begin{enumerate}[label=(S\arabic*)]
  \setlength\itemsep{0em}
  \item Jeśli \(p\) jest zmienną typową, to \(p\) jest typem prostym.\label{def:t-1}
  \item Jeśli \(\sigma\) i \(\tau\) są typami prostymi, to \(\left(\sigma\to\tau\right)\) jest typem prostym.\label{def:t-2}
\end{enumerate}
\end{definicja}

Zmienne typowe nazywa się w literaturze niekiedy \emph{stałymi typowymi}\footnote{Podkreśla się w ten sposób ograniczenie typów prostych: abstrakcja po zmiennych typowych jest w tym systemie niemożliwa.}. Typy proste zbudowane tylko wedle reguły \ref{def:t-1} nazywamy typami \emph{atomowymi}, zaś wyrażenia zbudowane wedle reguły \ref{def:t-2} -- typami \emph{funkcyjnymi}. Zbiór typów prostych określony w myśl powyższej definicji będziemy oznaczali przez \(\mathbb{T}\). Definicję \ref{def:typy-proste} można równoznacznie wyrazić przy pomocy notacji Backusa-Naura. Wówczas ma ona następującą, zwięzłą postać:
\begin{align*}
  \mathbb{T}\ \leftarrow \ U\ |\ (\mathbb{T}\to\mathbb{T})
\end{align*}

Późniejsze litery alfabetu greckiego (\(\sigma,\, \tau,\, \rho,\,\dots\)), być może z indeksami, będą służyły nam za zmienne metasyntaktyczne do oznaczania typów prostych. Dla lepszej czytelności będziemy pomijali najbardziej zewnętrzne nawiasy. Konstruktor typu \(\to\) wiąże prawostronnie; oznacza to, że typy \(\sigma\to\tau\to\rho\) oraz \(\sigma\to(\tau\to\rho)\) będziemy uznawali za tożsame.

% Zauważmy, że obiekty skonstruowane w myśl Definicji \ref{def:typy-proste} mają strukturę drzewa binarnego. Wysokość takiego drzewa będziemy nazywali \emph{stopniem} typu. 
% \begin{definicja}\label{def:stopien-typu}(Stopień typu)
%   Stopniem typu nazywamy następująco określoną funkcję \(\delta :\: \mathbb{T} \to \mathbb{N}\)
%   \begin{align*}
%     \delta(p) &= 0,\ \text{gdzie \(p\) jest typem atomowym},\\
%     \delta(\sigma\to\sigma)&=1 + \max\left(\delta(\sigma),\ \delta(\sigma)\right).
%   \end{align*}
% \end{definicja}

% \subsection{Pseudotermy}
%   Niech \(\mathrm{V}\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych \(x,\ y,\ \dots\ \) (indeksowanych być może liczbami naturalnymi). Elementy takiego zbioru będziemy nazywali \emph{\(\lambda\)-zmiennymi}.
% \begin{definicja}\label{def:pseudopreterm-simple}(Pseudo-pretermy)\\
%   \emph{Pseudo-pretermami} będziemy nazywali najmniejszy (w sensie mnogościowym) zbiór \(\mathbf{\tilde\Lambda}_{\mathbb{T}}\) taki, że:

%   \begin{enumerate}[label=(PP\arabic*)]
%   \setlength\itemsep{0em}
%   \item Jeśli \(x\in V\), to \(x\in{\mathbf{\tilde\Lambda}}_{\mathbb{T}}\).\label{def:pt-1}
%   \item Jeśli \(M\in\mathbf{\tilde{\Lambda}}_{\mathbb{T}}\) i \(N\in\mathbf{\tilde{\Lambda}}_{\mathbb{T}}\), to \((MN)\in\mathbf{\tilde{\Lambda}}_{\mathbb{T}}\).\label{def:pt-2}
%   \item Dla dowolnych \(x\in V\), \(\sigma\in\mathbb{T}\), \(M\in\mathbf{\tilde{\Lambda}}_{\mathbb{T}}\) mamy, że \((\lambda x:{\sigma}.\,M)\in \mathbf{\tilde{\Lambda}}_{\mathbb{T}}\).\label{def:pt-3}
%   \end{enumerate}
% \end{definicja}
% Elementy \(\mathbf{\tilde\Lambda}_\mathbb{T}\) będziemy oznaczali literami \(L,\ M,\ N,\ P,\ Q,\ R\) i ich wariantami z górnymi lub dolnymi indeksami.Wyrażenia postaci \ref{def:pt-2} nazywamy \emph{aplikacjami} \(M\) do \(N\), zaś wyrażenia postaci \ref{def:pt-3} -- \emph{\(\lambda\)-abstrakcjami}, gdzie o wszystkich podtermach termu \(M\) mówi się, że są w \emph{zasięgu} \(\lambda\)-abstraktora, zaś o \(\lambda\)-zmiennej \(x\) mówi się, że jest nim \emph{związana}. Definicję \ref{def:pseudopreterm-simple} można równoznacznie wyrazić przy pomocy notacji Backusa-Naura. Wówczas ma ona następującą, zwięzłą postać:
% \begin{align*}
%   \mathbf{\tilde\Lambda}\ \leftarrow \ V\ |\ (\mathbf{\tilde\Lambda}\,\mathbf{\tilde\Lambda}) \ |\ (\lambda V.\, \mathbf{\tilde\Lambda})
% \end{align*}

% Stosujemy analogiczne konwencje notacyjne do tych proponowanych przy Definicji \ref{def:lambda-untyped}.

\begin{definicja}(Stwierdzenie, deklaracja, kontekst, sąd)\label{def:statement_simple}
  \begin{enumerate}[label=(\arabic*)]
  \setlength\itemsep{0em}
  \item \emph{Stwierdzeniem} (ang. \emph{statement}) nazywamy każdy napis postaci \(M:\sigma\), gdzie \(M\in\mathbf{\Lambda}\) i \(\sigma\in\mathbb{T}\). W stwierdzeniu \(M:\sigma\) \(\lambda\)-term \(M\) nazwamy \emph{podmiotem}  (ang. \emph{subject}), zaś \(\sigma\) -- \emph{predykatem}\footnote{Nazwy te historycznie sięgają prac nad semantyką formalną języków naturalnych R. Montague.}.
  \item \emph{Deklaracją} (ang. \emph{declaration}) nazywamy każde stwierdzenie w którym podmiot jest zmienną termową.
  \item \emph{Kontekstem} (ang. \emph{context}) nazywamy skończony liniowo uporządkowany zbiór (\emph{listę}) deklaracji \((\Gamma, \preceq)\), w którym wszystkie podmioty są wzajemnie różne.
  \item \emph{Sądem} (ang. \emph{judgement}) nazywamy każdy napis postaci \(\Gamma\vdash M:\sigma\), gdzie \(\Gamma\) jest kontekstem, zaś \(M:\sigma\) -- stwierdzeniem; w przypadku, gdy \(\Gamma = \emptyset\), piszemy \(\vdash M:\sigma\).  
  \end{enumerate}
\end{definicja}

\begin{definicja}\label{def:context_simple}
  \begin{enumerate}[label=(\arabic*)]
  \setlength\itemsep{0em}
  \item Dla kontekstu \(\Gamma=(x_1:\sigma_1,\,\dots,\,x_n:\sigma_n)\) określamy
    \begin{align*}
       \mathrm{dom}\,\Gamma &= \{x\in V\ |\ (x:\sigma) \in \Gamma \},\\
       \mathrm{rg}\,\Gamma &= \{\sigma\in\mathbb{T}\ |\ (x:\sigma) \in \Gamma \}.
    \end{align*}
      Zbiory \(\mathrm{dom}\,\Gamma\) i \(\mathrm{rg}\,\Gamma\) nazywamy odpowiednio \emph{dziedziną} i \emph{zakresem} kontekstu~\(\Gamma\).
  % \item Jeśli \(\Gamma=(x_1:\sigma_1,\,\dots,\,x_n:\sigma_n)\) jest kontekstem, to liniowo
  %   uporządkowany zbiór \( \mathrm{dom}\, \Gamma = (x_1,\dots,x_n) \) nazywamy
  %     \emph{dziedziną} kontekstu \(\Gamma\), zaś zbiór \(\mathrm{rg}\,\Gamma = \{\sigma\in\mathbb{T}\ |\ (x:\sigma) \in \Gamma \}\) -- \emph{zakresem} kontekstu \(\Gamma\).
      % \begin{align*}
      %   \mathrm{dom}\,\Gamma &= \{M\in\mathbf{\Lambda}\ |\ (x:\sigma) \in \Gamma \},\\
      %   \mathrm{rg}\,\Gamma &= \{\sigma\in\mathbb{T}\ |\ (x:\sigma) \in \Gamma \}.
      % \end{align*}
    \item Powiemy, że konteksty \((\Gamma=(D_1, \preceq_1)\) i \(\Delta=(D_2, \preceq_2\) są \emph{rozłączne}, jeśli \(D_1 \cap D_2=\emptyset\).
    \item Kontekst \(\Gamma'\) nazywamy \emph{podkontekstem} \(\Gamma\) i piszemy \(\Gamma'\subseteq\Gamma\), jeśli wszystkie deklaracje występujące w \(\Gamma'\) występują również w \(\Gamma\) z zachowaniem tego samego porządku; kontekst pusty oznaczać będziemy symbolem \(\emptyset\).
    \item Kontekst \(\Gamma'\) nazywamy \emph{permutacją} kontekstu \(\Gamma\), jeśli wszystkie deklaracje w \(\Gamma'\) występują w \(\Gamma\) i odwrotnie.
    % \item Dla kontekstów \(\Delta=(D_1, \preceq_1)\) i \(\Gamma=(D_2, \preceq_2)\) \emph{przekrojem} \(\Delta\) i \(\Gamma\) nazywamy kontekst 
    %   \(\Delta \cap \Gamma = (D_1 \cap D_2, \preceq_{12})\), gdzie dla dowolnych \(d_1, d_2\in D_1\cap D_2\)
 % \[d_1\preceq_{12} d_2 \iff d_1 \preceq_1 d_2 \land d_1 \preceq_2 d_2.\]
    \item Jeśli \(\Gamma=(D_1,\preceq_1)\) i \(\Delta=(D_2, \preceq_2)\) są kontekstami takimi, że \(D_1 \cap D_2=\emptyset\), to \emph{konkatenacją} \(\Gamma\) i \(\Gamma'\) nazywamy kontekst \(\Gamma \concat \Gamma' = (D_1\cup D_2, \preceq_{12})\), gdzie \(d_1 \preceq_{12} d_2\) zachodzi wtedy i tylko wtedy, gdy:
      \begin{enumerate}
      \setlength\itemsep{0em}
        \item dla \(d_1, d_2\in D_1\) zachodzi \(d_1\preceq d_2\) lub
        \item dla \(d_1, d_2\in D_2\) zachodzi \(d_1\preceq d_2\) lub
        \item \(d_1 \in D_1\) i \(d_2 \in D_2\).
      \end{enumerate}
      Przy powyższych ustaleniach, jeśli \(\Gamma=(x_1:\sigma_1,\,\dots,\,x_k:\sigma_m)\) oraz \(\Delta=(y_1:\rho_1,\,\dots\,y_n:\rho_n)\), to mamy 
      \[
        \Gamma \concat \Gamma' = (x_1:\sigma_1,\,\dots,\,x_k:\sigma_m,\,y_1:\rho_1,\,\dots\,y_n:\rho_n).
      \]
    \item Jeśli \(\Gamma\) jest kontekstem i \(\Phi\) jest zbiorem \(\lambda\)-zmiennych, wówczas \emph{projekcją} \(\Gamma\) na \(\Phi\) (symbolicznie \(\Gamma \upharpoonright \Phi\)) nazywamy podkontekst \(\Gamma'\) kontekstu \(\Gamma\) taki, że \(\mathrm{dom} \Gamma' = (\mathrm{dom} \Gamma) \cap \Phi\).  
  \end{enumerate}
\end{definicja}
\begin{przyklad}
  Niech \(\Gamma\equiv(y:\sigma,\,x_1:\rho_1,\,x_2:\rho_2,\,z:\tau,\,x_3:\rho_3)\). Wówczas:
  \begin{enumerate}[label=(\arabic*)]
    \setlength\itemsep{0em}
    \item \(\mathrm{dom}\,\Gamma=\{y,\,x_1,\,x_2,\,z,\,x_3\}\).
    \item \(\emptyset \subseteq (x_1:\rho_1,\,z:\tau)\subseteq\Gamma\).
    \item \((x_1:\rho_1,\,x_2:\rho_2,\,x_3:\rho_3,\,y:\sigma,\,z:\tau)\) jest permutacją \(\Gamma\).
    \item \(\Gamma\upharpoonright \{z,\,u,\,x_1\}=(x_1:\rho_1,\,z:\tau).\)
  \end{enumerate}
\end{przyklad}

\begin{konwencja*}
  Niech \(\Gamma, \Delta\) będą rozłącznymi kontekstami i \(x:\sigma\) dowolną deklaracją. Wprowadzamy następującą notację:
  \begin{align*}
    \Gamma, x:\sigma &\equiv \Gamma \concat (x:\sigma)\\
    \Gamma, \Delta   &\equiv \Gamma \concat \Delta
  \end{align*}
\end{konwencja*}

\subsection{Typowanie}\label{subsec:simple_types_typing}
Wprowadzamy następujące reguły wyprowadzania typu (relacji typowalności):
\vspace{0.5em}
\begin{center}
    \begin{tabular}{ ccc}
      \(\Gamma \vdash x:\sigma\ \text{(var)}\), & jeśli \(x:\sigma\in\Gamma\),
      \vspace{1em}\\
      {\begin{prooftree}
        \Hypo{\Gamma \vdash M:\sigma \to \tau} \Hypo{ \Gamma \vdash N:\sigma}
        \Infer2[(app)]{\Gamma \vdash (MN):\tau}
      \end{prooftree}},&
      \vspace{1em}
      \\ 
      {\begin{prooftree}
        \Hypo{ \Gamma, x:\sigma \vdash M:\tau}
        \Infer1[(abs)]{\Gamma \vdash (\lambda\, x.\, M):\sigma\to\tau}
      \end{prooftree}}.&
    \end{tabular}
\end{center}

\vspace{0.5em}

W systemie tym mamy do czynienia z wyraźnym podziałem na obiekty dwóch rodzajów: \(\lambda\)-termy i typy. \(\lambda\)-termy możemy przekształcać dwoma dualnymi operacjami: \(\lambda\)-abstrakcją i aplikacją. Rezultat operacji zależy od wyboru zmiennej wolnej, którą chcemy wyabstrahować z termu albo wyboru termu, który chcemy zaaplikować do innego termu, odpowiednio. Dlatego mówimy, że w rachunku \(\lambda\) z typami prostymi termy \emph{zależą} od termów. Ponieważ abstrahowanie przebiega wyłącznie po zbiorze \(\lambda\)-zmiennych, mówimy, że zależność (abstrakcja) jest \emph{pierwszego rzędu}.

\begin{definicja}(Wyprowadzenie typu) 
%  Mówimy, że stwierdzenie \(M:\sigma\) jest \emph{wyprowadzalne} z kontekstu \(\Gamma\), jeśli istnieje skończone drzewo sądów \(\mathcal{P}\) spełniające poniższe warunki:
%  Mówimy, że \(\lambda\)-term \(M\) jest typu \(\sigma\) w kontekście \(\Gamma\), jeśli istnieje skończone drzewo sądów \(\mathcal{P}\) spełniające poniższe warunki:
  \emph{Wyprowadzeniem} sądu \(\Gamma\vdash M:\sigma\) nazywamy skończone drzewo sądów \(\mathcal{P}\) takie, że dla pewnego kontekstu \(\Delta\) spełnione są następujące warunki:
%  Wyprowadzeniem typu \(\lambda\)-termu \(M\) nazywamy skończone drzewo sądów \(\mathcal{P}\) takie, że dla pewnego kontekstu \(\Delta\) spełnione są następujące warunki:
  \begin{enumerate}[label=(D\arabic*)]
      \setlength\itemsep{0em}
      \item W korzeniu \(\mathcal{P}\) znajduje się sąd \(\Gamma \vdash M:\sigma\), gdzie \(\Gamma\subset\Delta\).
      \item Liście \(\mathcal{P}\) są \emph{aksjomatami}, czyli sądami postaci \(\Delta \vdash x:\sigma\).
      \item Wszystkie pozostałe sądy w \(\mathcal{P}\) są uzyskane ze swoich dzieci za pomocą reguły (app) albo (abs).
  \end{enumerate}
  Jeśli istnieje wyprowadzenie sądu dla \(\Gamma\vdash M:\sigma\), to powiemy, że jest on \emph{wyprowadzalny}. 
  Jeśli nie będzie to prowadziło do niejednoznaczności, będziemy wówczas również pisali \(\Gamma\vdash M:\sigma\).
%  Drzewo \(\mathcal{P}\) będziemy nazywali \emph{wyprowadzeniem} typu dla \(M\) w kontekście \(\Gamma\) i pisali \(\Gamma \vdash M:\sigma\). %Jeśli wyprowadzalność sądu będzie jednoznacznie wynikała z kontekstu, to będziemy omijać indeks \(\mathbb{T}\) przy symbolu \(\vdash_\mathbb{T}\).
\end{definicja}

\begin{definicja}(Poprawność, typowalność)
  \(\lambda\)-term \(M\in\mathbf{\Lambda}\) nazywamy \emph{poprawnym} (ang. \emph{legal}) lub \emph{typowalnym} (ang. \emph{typable}), jeśli istnieje wyprowadzenie sądu \(\Gamma\vdash M:\rho\) dla pewnego kontekstu \(\Gamma\) i typu \(\rho\in\mathbb{T}\). \end{definicja}

\begin{przyklad}\label{ex:typing}
 \begin{enumerate}[label=(\alph*)]
  \setlength\itemsep{0em}
  \item
    Niech \(\Gamma=(x:\sigma,\, y:\tau)\). Pokażemy, że \(\mathrm{K}=\lambda x y.\, x\) ma typ \(\sigma\to\tau\to\sigma\). Istotnie,
  \begin{center}
  \begin{prooftree}
    \Hypo{x:\sigma, y:\tau \vdash x:\sigma}
    \Infer1[(abs)]{x:\sigma \vdash \lambda y.\,x:{\tau\to\sigma}}
    \Infer1[(abs)]{\vdash \lambda x y.\, x:{\sigma\to\tau\to\sigma}}
\end{prooftree}
  \end{center}

\item\label{ex:typing_2}
    Niech \(\Gamma=(x:{\tau\to\rho},\, y:{\sigma\to\tau},\,z:{\sigma})\). Wówczas:
  \begin{center}
\begin{prooftree}
  \Hypo{\Gamma\vdash x:{\tau\to\rho}}   \Hypo{\Gamma \vdash y:{\sigma\to\tau}} \Hypo{ \Gamma \vdash z:{\sigma}} \Infer2[(app)]{\Gamma \vdash yz:{\tau}}
  \Infer2[(app)]{\Gamma \vdash x(yz):\rho}
  \Infer1[(abs)]{x:{\tau\to\sigma}, y:{\sigma\to\rho}\vdash \lambda z .\, x(yz):{\sigma\to\rho}}
  \Infer1[(abs)]{x:{\tau\to\rho}\vdash \lambda y z.\,x(yz):{(\sigma\to\tau)\to\sigma\to\rho}}
  \Infer1[(abs)]{\vdash \lambda x y z .\, x(yz):{(\tau\to\rho)\to(\sigma\to\tau)\to\sigma\to\rho}}
\item\label{ex:typing_3}  
  Nie wszystkie \(\lambda\)-termy są typowalne. Jeśli \(\Gamma\vdash xx:\tau\), to \(\Gamma\vdash x:\sigma\to\tau\) i \(\Gamma\vdash x:\sigma\). Wówczas \(x:\sigma\in\Gamma\) i \(x:\sigma\to\tau\in\Gamma\). Ponieważ wszystkie deklaracje w \(\Gamma\) są różne, to \(\sigma\equiv\sigma\to\tau\), co nie jest możliwe.
\end{prooftree}
  \end{center}
% \item\label{ex:typing_3}
%   Nie wszystkie \(\lambda\)-termy są typowalne. Niech \(\omega\equiv (\lambda x.\, x x)\) i przypuśćmy, że \(\omega\) ma typ \(\sigma\) w kontekście \(\Gamma\). Zauważmy, że wówczas w \(x:{\sigma\to\sigma}\in\Gamma\). Ponieważ \(\omega\) zawiera w sobie podterm \((xx)\), to w wyprowadzeniu musiał on zostać otrzymany przez zastosowanie reguły (app). Wówczas \(x:\sigma \in \Gamma\)  i \(x:{\sigma\to\sigma} \in \Gamma\), co nie jest możliwe, bo wszystkie deklaracje w \(\Gamma\) muszą mieć różne podmioty.
  
  %Co więcej, można wykazać że typ \((\tau\to\rho)\to(\sigma\to\tau)\to\sigma\to\rho\) może mieć tylko i wyłącznie operacja złożenia~\cite{Wadler1989}.
\end{enumerate}
%  Zauważmy, że term \(\lambda x^{\tau\to\rho}\lambda y^{\sigma\to\tau}\lambda z^\sigma . x(yz)\) odpowiada operacji złożenia funkcji.
\end{przyklad}


\begin{uwaga*}
% Zauważmy, że wyprowadzenia ustalają ścisły porządek częściowy:
%   \begin{easylist}
%     & żaden sąd nie poprzedza sam siebie (antyzwrotność),
%     & jeśli jeden sąd poprzedza drugi, to drugi nie poprzedza pierwszego (antysymetryczność),
%     & jeśli sąd \(J_k\) poprzedza \(J_l\) i \(J_l\) poprzedza \(J_m\), to \(J_k\) poprzedza \(J_m\) (przechodniość).
%   \end{easylist}
  Notacja dowodowa zaproponowana w Przykładzie \ref{ex:typing} utrudnia zorientowanie się w dłuższych wyprowadzeniach przez konieczność wielokrotnego powtarzania kontekstów. Wariant notacji w postaci drzew wprowadzony przez Pravitza i proponowany w \cite{Hindley:2008:LCI:1388400} eliminuje ten problem przez wprowadzanie do wyprowadzenia poszczególnych deklaracji przed użyciem i wykreślanie jej po użyciu. W dalszej części pracy będziemy korzystać z analogicznej pod wieloma względami notacji Fitcha (tzw. notacji flagowej) proponowanej w \cite{nederpelt_geuvers_2014}. Poniżej pokazujemy wyprowadzenia typu z Przykładu \ref{ex:typing} w tej notacji.
  \begin{enumerate}[label=(\alph*)]
   \item
  \begin{equation*}
    \begin{fitch}
      \fh x:\sigma & (var) \\
      \fa \fh y:\tau & (var) \\
      \fa \lambda y.\,x:\tau\to\sigma & (abs) 1 \\
      \lambda x y.\,x:\sigma\to\tau\to\sigma & (abs) 3
    \end{fitch}
  \end{equation*}
  \item
  \begin{equation*}
    \begin{fitch}
      \fh x:\tau\to\rho & (var) \\
      \fa \fh y:\sigma\to\tau & (var) \\
      \fa \fa \fh z:\sigma & (var) \\
      \fa \fa \fa yz:\tau & (app)\ 2\ 3 \\
      \fa \fa \fa x(yz):\rho & (app) 1 4 \\
      \fa \fa \lambda z.\,x(yz):\sigma\to\rho & (abs) 5 \\
      \fa \lambda yz.x(yz):(\sigma\to\tau)\to\sigma\to\rho & (abs) 6\\
      \lambda x y z.\,x(yz):(\tau\to\rho)\to(\sigma\to\tau)\to\sigma\to\rho & (abs) 7 
    \end{fitch}
  \end{equation*}
 \end{enumerate}
\end{uwaga*}
\paragraph{Klasyfikacja problemów z typowaniem}
W teorii typów spotykamy trzy rodzaje problemów dotyczące sądów:
\begin{enumerate}
  \setlength\itemsep{0em}
  \item \emph{Problem typowalności} (ang. \emph{well-typedness, typability})
    Polega na rozstrzygnięciu czy zadany term jest poprawny, czyli znalezieniu kontekstu oraz wyprowadzenia typu względem tego kontekstu dla zadanego termu. Symbolicznie:
    \[ \mathbf{?} \vdash \text{term}\ :\ \mathbf{?} \]
    Problem typowalności przy zadanym kontekście nazywamy problemem \emph{przypisania typu} (ang. \emph{type assignment}). Ma on nastepującą postać: 
    \[ \text{kontekst} \vdash \text{term}\ :\ \mathbf{?} \]
  \item \emph{Problem weryfikacji typu} (ang. \emph{type checking}) 
    
    Polega na sprawdzeniu czy term ma zadany typ względem danego kontekstu. Symbolicznie:
    \[ \text{kontekst} \stackrel{\mathbf{?}}{\vdash} \text{term}\ :\ \text{typ} \]
  \item \emph{Problem inhabitacji} (ang. \emph{inhabitation, term finding})

    Polega na skonstruowaniu termu (lub przynajmniej wykazaniu istnienia takiego termu), który    miałby zadany typ względem danego kontekstu. Symbolicznie: 
    \[
      \text{kontekst} \vdash \mathbf{?}\ :\ \text{typ}
    \]
\end{enumerate}

W wielu systemach problem typowalności można sprowadzić do problemu weryfikacji typu. Istotnie, przypuśćmy, że \(M\) jest poprawnym termem i \(\mathrm{FV}(M)=\{x_1,\,\dots\,x_n\}\). Zauważmy, że \(M\) jest typowalny, jeśli wyprowadzalny jest sąd
\[
  x_0:p\vdash \mathrm{K} x_0 (\lambda x_1 \dots x_n.\,M):p,
\]
gdzie \(p\in U\) jest zmienną typową, zaś kombinator \(K\equiv \lambda xy.\,x\).

Wszystkie wymienione problemy są w rachunku \(\lambda\) z typami prostymi rozstrzygalne, tzn. istnieją efektywnie obliczalne metody ich rozwiązywania. Czytelnika zainteresowanego szczegółami odsyłamy do \cite[Twierdzenie 3.2.7]{Urzyczyn2006} i \cite[Rozdział 4.4]{Barendregt_1992}.
Fakt ten nie jest oczywisty dla innych systemów typów; za przykład wystarczy wziąć wynik J. B. Wellsa \cite{Wells_98}, który stwierdza, że problemy typowalności i weryfikacji typu w Systemie F (w stylu Currego) są nierozstrzygalne.
\subimport{includes/chapters/}{unification.tex}

\subsection{Własności}

Przedstawimy teraz szereg lematów ustalających związki między rachunkiem \(\lambda\) bez typów wprowadzonym w Rozdziale \ref{sec:untyped_lambda}, a rachunkiem \(\lambda\) z typami prostymi oraz najistotniejsze własności wprowadzonego właśnie systemu typów.

\begin{lemat}(O generowaniu)\label{thm:generation}
  \begin{enumerate}[label=(\arabic*)]
     \setlength\itemsep{0em}
     \item Jeśli \(\Gamma\vdash x:\sigma\), to \(x:\sigma\in\Gamma\).\label{thm:generation_1}
     \item Jeśli \(\Gamma\vdash MN:\tau\), to \(\Gamma\vdash M:\sigma\to\tau\) i \(\Gamma\vdash N:\sigma\) dla pewnego \(\sigma\in\mathbb{T}\).\label{thm:generation_2}
     \item Jeśli \(\Gamma\vdash\lambda x.\, M:\tau\) i \(x\not\in\mathrm{dom}\,\Gamma\), to \(\tau\equiv \tau_1\to\tau_2\) oraz \(\Gamma,x:\tau_1\vdash N:\tau_2\). \label{thm:generation_3}
  \end{enumerate} 
\end{lemat}
\begin{dowod}
  Wynika natychmiast z postaci \(\lambda\)-termu.  \qed
\end{dowod}

\begin{lemat}(O podtermie)\label{thm:subterm}
  Podterm poprawnego \(\lambda\)-termu jest poprawny.
  % (Given as Proposition 3.2.9 (see also 3.1.9) in Barendregt, 1992.)
\end{lemat}
\begin{dowod}
  Załóżmy, że sąd \(J: \Gamma\vdash M:\sigma\) jest wyprowadzalny. Dowód przebiega przez indukcję względem długości wyprowadzenia \(J\). Rozważmy następujące przypadki:
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item Jeśli \(J\) jest konsekwencją reguły \emph{var}, to \(\mathrm{Sub}(M)=\{M\}\) (Definicja~\ref{def:untyped_subterm}.\ref{def:untyped_subterm_1}), a zatem teza jest trywialnie spełniona.
     \item Jeśli \(J\) jest konsekwencją reguły \emph{app}, to \(M\equiv PQ\) dla \(P,\,Q\) dla których twierdzenie zachodzi. Ponieważ \(\mathrm{Sub}(M)=\mathrm{Sub}(P)\cup\mathrm{Sub}(Q)\cup\{PQ\}\) (Definicja~\ref{def:untyped_subterm}.\ref{def:untyped_subterm_2}), to teza również zachodzi.
    \item Jeśli \(J\) jest konsekwencją reguły \emph{abs}, to \(M\equiv \lambda
      x.\,P\) dla pewnego \(P\) dla którego twierdzenie zachodzi. Ponieważ
      \(\mathrm{Sub}(\lambda x.\,M) = \mathrm{Sub}(M) \cup \{\lambda x.\,M\}\),
      (Definicja~\ref{def:untyped_subterm}.\ref{def:untyped_subterm_3})
      to teza zachodzi również w tym przypadku.
  \end{enumerate}
  \qed
\end{dowod}

\begin{lemat}(O zmiennych wolnych)\label{thm:fv}
  Jeśli sąd \(\Gamma \vdash L:\sigma\) jest wyprowadzalny, to \(\mathrm{FV}(L)\subseteq \mathrm{dom}\,\Gamma\).
\end{lemat}
\begin{dowod}
  Dowód przeprowadzamy przez indukcję względem długości wyprowadzenia sądu \(J:\Gamma \vdash L:\sigma\). Rozważmy następujące przypadki:
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item Jeśli \(J\) jest konsekwencą reguły \emph{var}, to \(L\equiv x\) dla pewnej \(\lambda\)-zmiennej \(x\). Wobec tego \(x:\sigma\in\Gamma\), a zatem \(\mathrm{FV}(x)\subseteq\mathrm{dom}\,\Gamma\).
    \item Jeśli \(J\) jest konsekwencją reguły \emph{app}, to \(J\) musi mieć postać \(\Gamma\vdash MN:\sigma\). Z założenia indukcyjnego: \(\mathrm{FV}(M)\subseteq \mathrm{dom}\,\Gamma\) i  \(\mathrm{FV}(N)\subseteq \mathrm{dom}\,\Gamma\). Z Definicji \ref{def:untyped_fv}: \(\mathrm{FV}(MN)=\mathrm{FV}(M)\cup\mathrm{FV}(N)\). Stąd \(\mathrm{FV}(MN)\subseteq \mathrm{dom}\,\Gamma\).
    \item Jeśli \(J\) jest konsekwencją reguły \emph{abs}, to \(J\) musi mieć postać \(\Gamma\vdash \lambda x.\,M:\sigma\). Z~założenia indukcyjnego \(FV(M)\subseteq\mathrm{dom}\,\Gamma\). Ponieważ \(\mathrm{FV}(\lambda x.\,M)=\mathrm{FV}(M)\setminus\{x\}\subseteq\mathrm{FV}(M)\) (z Definicji \ref{def:untyped_fv}), to \(\mathrm{FV}(M)\subseteq\mathrm{dom}\,\Gamma\). 
  \end{enumerate}  
  \qed
\end{dowod}

\begin{lemat}\label{thm:permutation_simple}
  \begin{enumerate}[label=(\arabic*), ref=(\arabic*)]
    \setlength\itemsep{0em}
    \item Niech \(\Gamma'\) i \(\Gamma''\) bedą kontekstami takimi, że \(\Gamma' \subseteq \Gamma''\). Jeśli \(\Gamma'\vdash M:\sigma\), to \(\Gamma''\vdash M:\sigma\).\label{thm:permutation_1}
    \item Jeśli \(\Gamma\vdash M:\sigma\), to \(\Gamma \upharpoonright \mathrm{FV}(M)\vdash M:\sigma\).\label{thm:permutation_2}
    \item Jeśli \(\Gamma\vdash M:\sigma\) i \(\Gamma'\) jest permutacją \(\Gamma\), to \(\Gamma'\vdash M:\sigma\).\label{thm:permutation_3}
  \end{enumerate}
\end{lemat}
\begin{dowod}
  Dowody przebiegają przez indukcję względem długości wyprowadzenia. Czytelnika zainteresowanego szczegółami odsyłamy do \cite[Tw. 3.1.7]{Barendregt_1992}. 
  \qed
\end{dowod}

% \begin{uwaga*}
%   Zauważmy, że część \ref{thm:permutation_3} Lematu \ref{thm:permutation_simple} rozluźnia konieczność eliminowania maksymalnej deklaracji z kontekstu przy stosowaniu reguły \emph{abs}. W tekstach wprowadzających typy proste zazwyczaj przez kontekst rozumie się po prostu skończony zbiór wzajemnie różnych deklaracji \cite{Barendregt_1992, Urzyczyn2006, Hindley:2008:LCI:1388400}. Ponieważ branie dowolnej permutacji listy nie wpływa na typowanie, to widzimy, że obydwa znaczenia możemy stosować zamiennie, bowiem jest to nic innego jak traktowanie kontekstu jako zbioru deklaracji. 
% \end{uwaga*}

\begin{lemat}(O podstawieniu)\label{thm:substitution}
  Załóżmy, że
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item \(\Gamma_1,\,x:\sigma,\,\Gamma_2\vdash M:\rho\) 
    \item \(\Gamma_1\vdash N:\sigma\)
  \end{enumerate}
  Wówczas \(\Gamma_1,\Gamma_2 \vdash M[x/N]:\rho\).
\end{lemat}
\begin{dowod}
%  Dowód przebiega przez indukcję względem długości wyprowadzenia typu \(M\). 
%   \begin{enumerate}[label=(\roman*)]
%    \setlength\itemsep{0em}
  Niech \(\Gamma=\Gamma_1 \concat \Gamma_2\). Korzystając z części \ref{thm:permutation_3} Lematu \ref{thm:permutation_simple}
  dowód przeprowadzimy przez indukcję względem długości wyprowadzenia \(\Gamma,\,x:\sigma\vdash M:\rho\). Rozważmy następujące przypadki:
    \begin{enumerate}[label=(\roman*)]
      \setlength\itemsep{0em}
      \item   Jeśli    \(\Gamma,\,x:\sigma\vdash   M:\rho\)   jest
konsekwencją reguły  \emph{var},  to   \(M\equiv  x\).  Wówczas
        \(M[x/N]\equiv N\) i \(\rho \equiv  \sigma\). Teza zachodzi w oczywisty
sposób.
      \item  \(\Gamma,\,x:\sigma\vdash M:\rho\)  jest konsekwencją
      reguły  \emph{app}.   Wówczas \(M\equiv  PQ\)   i  istnieją
      wyprowadzenia    \(\Gamma,\,x:\sigma\vdash    P:\tau\to\rho\)
      oraz  \(\Gamma,\,  x:\sigma\vdash   Q:\tau\).  Z  założenia
      indykcyjnego  mamy,  że \(  \Gamma\vdash  P[x/N]:\tau\to\rho
        \)   oraz   \(   \Gamma\vdash   Q[x/N]:\tau   \). Wówczas stosując regułę \emph{app} mamy:
      \begin{center}
      {\begin{prooftree}
        \Hypo{\Gamma \vdash P[x/N]:\tau \to \rho} \Hypo{ \Gamma \vdash Q[x/N]:\tau}
        \Infer2[(app)]{\Gamma \vdash (P[x/N]Q[x/N]):\rho}
      \end{prooftree}}.
      \end{center}
      Tezę otrzymujemy z faktu, że \((PQ)[x/N]=P[x/N]Q[x/N]\). 
    \item Jeśli \(\Gamma,\,x:\sigma\vdash   M:\rho\) jest konsekwencją reguły \emph{abs}, to \(M\equiv \lambda y.\,P:\rho\) dla \(\rho\equiv \sigma\to\tau,\,y\not\equiv x\). Z założenia indukcyjnego istnieje wyprowadzenie
      \( \Gamma',\,y:\tau\vdash P[x/N]:\rho \), gdzie \(\Gamma'=\Gamma\concat (x:\sigma)\).
        Wówczas, stosując regułę \emph{abs} mamy:
      \begin{center}  
        {\begin{prooftree}
          \Hypo{ \Gamma', y:\tau\vdash P[x/N]:\rho}
          \Infer1[(abs)]{\Gamma' \vdash (\lambda\, y.\, P[x/N]):\tau\to\rho}
        \end{prooftree}}.
      \end{center}
        Ponieważ \((\lambda y.\,P)[x/N]=\lambda y.\,P[x/N]\) oraz \(M\equiv \lambda y.\,P:\tau\to\rho\), otrzymujemy tezę.
    \end{enumerate}
    \item    
  \qed
%  \end{enumerate}
\end{dowod}
\begin{lemat}(Redukcja podmiotu)\label{thm:subject_reduction}
    Załóżmy, że
    \begin{enumerate}[label=(\roman*)]
      \setlength\itemsep{0em}
      \item \(\Gamma\vdash M:\sigma\) 
      \item \(M\to^{*}_\beta N\)
    \end{enumerate}
    Wówczas \(\Gamma\vdash N:\sigma\).
\end{lemat}
\begin{dowod}
  Pokażemy, że twierdzenie zachodzi dla jednego kroku redukcji \(\to_\beta\). Dowód zwrotności jest trywialny, zaś aby pokazać przechodniość wystarczy skorzystać z indukcji wzgledem długości ciągu redukcji.

  Niech \(M\to_\beta N\). Dowód przeprowadzimy przez indukcję względem długości wyprowadzenia \(\Gamma\vdash M:\sigma\). Rozważmy następujące przypadki:
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item    \(\Gamma\vdash     M:\sigma\)    jest    konsekwencją
    reguły   \emph{var}.  Wówczas   \(M\equiv   x\)  dla   pewnej
    \(\lambda\)-zmiennej  \(x\in   V\).  Wówczas   poprzednik  nie
    jest  spełniony,   bowiem  \(M\)  nie  da   się  zredukować.
    Zatem  twierdzenie  trywialnie zachodzi.  
  
    \item  \(\Gamma\vdash  M:\sigma\)  jest  konsekwencją  reguły
    \emph{app}.    Wówczas   \(M\equiv    PQ\)   oraz    istnieją
    wyprowadzenia  \(\Gamma\vdash   P:\tau\to\sigma\)  oraz  \(\Gamma
    \vdash   Q:\sigma\).   Ponadto   zakładamy,  że   dla   pewnych
    \(P',\,Q'\in\mathbf{\Lambda}\)   mamy   \(P\to_\beta   P'\)   i
    \(Q\to_\beta   Q'\).  Istnieją   dwie  możliwości   redukcji
    \(M\to_\beta N\):
      \begin{enumerate}[label=(\arabic*)]
        \setlength\itemsep{0em}
        \item \(N\equiv PQ'\). Poniważ \(\Gamma\vdash Q':\sigma\) (założenie indukcyjne), to możemy zastosować regułę \emph{app}:

        \begin{center}
          {\begin{prooftree}
            \Hypo{\Gamma \vdash P:\tau \to \sigma} \Hypo{ \Gamma \vdash Q':\tau}
            \Infer2[(app)]{\Gamma \vdash PQ':\sigma}
          \end{prooftree}}.
        \end{center}
          Ponieważ \(N\equiv PQ'\), to otrzymujemy tezę. 
          \label{thm:subject_reduction_1}
        \item \(N\equiv P'Q\). Postępujemy analogicznie do przypadku \ref{thm:subject_reduction_1}
      \end{enumerate}
    \item  \(\Gamma\vdash  M:\sigma\)  jest  konsekwencją  reguły
    \emph{abs}.  Wówczas \(M\equiv  \lambda  x.\,P\), dla  pewnych
    \(\rho,\,\tau\in\mathbb{T}\) mamy  \(\sigma\equiv \rho\to\tau\)
    oraz   istnieje  wyprowadzenie   sądu  \(\Gamma,\,x:\rho\vdash
      P:\tau\). Ponadto zakładamy, że dla pewnego \(P'\in\mathbf{\Lambda}\)
      mamy \(P\to_\beta P'\). \(\beta\)-redukcja \(M\to_\beta N\) musi prowadzić w tym wypadku do \(N\equiv \lambda x.\,P'\). Ponieważ \(\Gamma, x:\rho\vdash P':\tau\) (założenie indukcyjne), to możemy zastosowac regułę \emph{abs}:
      \begin{center}  
        {\begin{prooftree}
          \Hypo{ \Gamma', x:\rho\vdash P':\tau}
          \Infer1[(abs)]{\Gamma \vdash \lambda\, x.\, P':\rho\to\tau}
        \end{prooftree}}.
      \end{center}
      Stąd teza.
  \end{enumerate}
  \qed
\end{dowod}

\begin{lemat}(Zachowawczość \(\eta\)-redukcji)\label{thm:eta_uniqueness_simple}
    Załóżmy, że
    \begin{enumerate}[label=(\roman*), ref=\roman*]
      \setlength\itemsep{0em}
      \item \(\Gamma\vdash M:\sigma\), 
      \item \(M\to^{*}_\eta N\).
    \end{enumerate}
    Wówczas \(\Gamma\vdash N:\sigma\).
\end{lemat}

\begin{dowod}
  Dowód przeprowadzamy analogicznie do Lematu \ref{thm:subject_reduction}.\qed
\end{dowod}

\begin{twierdzenie}(Własność Churcha-Rossera)
  Relacja \(\to_\beta\) określona na typowalnych \(\lambda\)-termach  ma własność CR.
\end{twierdzenie}
\begin{dowod}
  Wynika to bezpośrednio z Faktu \ref{thm:cr_untyped} i Lematu \ref{thm:subject_reduction}. \qed
\end{dowod}

\subimport{includes/chapters/}{polymorphism.tex}

\subimport{includes/chapters/}{strong_normalization.tex}
% \begin{fakt}\label{thm:uniqueness}
% Jeśli \(\Gamma\vdash M^\sigma\) oraz \(\Gamma\vdash M^\tau\), to \(\sigma=\tau\).
% \begin{dowod}
%   Dowód przez indukcję strukturalną względem M. \qed
% \end{dowod}
% \end{fakt}

\subimport{includes/chapters/}{to_church_style.tex}
\subsection{Podsumowanie}
System typów, który był przedmiotem Rozdziału \ref{sec:simple_types} jest najbardziej elementarnym przypadkiem typowanego rachunku \(\lambda\)\footnote{Patologicznym przypadkiem jest rachunek \(\lambda\) bez typów, jeśli przyjmiemy, że wszystkie wyrażenia mają w nim dokładnie jeden typ. Argument ten często podejmowany jest przeciwko dynamicznie typowanym językom programowania.}. W literaturze występują pewne rozbieżności co do składni typów prostych: niekiedy występuje w niej typ bazowy z którego budowane są pozostałe typy lub dodatkowy konstruktor typu dla pary (można porównać np. \cite{Girard:1989:PT:64805,DBLP:journals/corr/abs-0804-3434}). Rozszerzenia takie nie wpływają jednak na samą istotę typowania, która polega na \emph{zależności termów od termów}. Jak przekonamy się w Rozdziale \ref{sec:system_f}, zależność tę można rozszerzyć pozwalając również typom na decydowanie o postaci termu. 
%
%W literaturze często spotyka się być może jeszcze prostszy, równoważny wariant typów prostych, w którym wszystkie typy buduje się wyłącznie z jednej stałej typowej. Pod pojęciem typów prostych rozumie się w literaturze także rozszerzenie przedstawionego przez nas systemu dodające do niego konstruktor typu dla par


% Ich celem jest zwiększenie ekspresji, np. o odpowiednie konstrukcje dla par%, w których pierwszy element może być innego typu niż drugi. Konstrukcja ta jest bowiem niemożliwa w naszym, elementarnym ujęciu.

% Istotnie, rozważmy następujące kodowanie pary i dwóch projekcji:
% \begin{align*}
%   \mathrm{pair}&\equiv\lambda x:\sigma\, \lambda y:\tau.\ z x y \\
%   \mathrm{fst} &\equiv \lambda p:\sigma\to\sigma.\ p\,(\lambda x:\sigma\, \lambda y:\tau.\ x) \\
%   \mathrm{snd} &\equiv \lambda p:\tau\to\tau.\ p\,(\lambda x:\sigma\, \lambda y:\tau.\ y) % \end{align*} 

%Mają one na ogół szczególny cel praktyczny: na przykład rozszerzenie o typ dla par umożliwiają elegancką prezentację analogii między intuicjonistycznym rachunkiem zdań, typowanym rachunkiem \(\lambda\) i kategoriami kartezjańsko domkniętymi, znanej szerzej jako izomorfizm Currego-Howarda-Lambeka \cite[Rozdział~3.1]{Girard:1989:PT:64805}.

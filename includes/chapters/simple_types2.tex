\section{Rachunek \(\lambda\) z typami prostymi}
\subsection{Typy proste}\label{ssec:typy-proste}
Niech \(U\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych \(p,\ q,\ \dots\ \) (być może indeksowanych liczbami naturalnymi), które będziemy nazywali \emph{zmiennymi typowymi}.

\begin{definicja}\label{def:typy-proste}(Typy proste)
\emph{Typami prostymi} będziemy określali najmniejszy w sensie mnogościowym zbiór wyrażeń taki, że:
\begin{enumerate}[label=(S\arabic*)]
  \setlength\itemsep{0em}
  \item Jeśli \(p\) jest zmienną typową, to \(p\) jest typem prostym.\label{def:t-1}
  \item Jeśli \(\sigma\) i \(\tau\) są typami prostymi, to \(\left(\sigma\to\tau\right)\) jest typem prostym.\label{def:t-2}
\end{enumerate}
\end{definicja}

Typy proste zbudowane tylko wedle reguły \ref{def:t-1} nazywamy typami \emph{atomowymi}, zaś wyrażenia zbudowe wedle reguły \ref{def:t-2} -- typami \emph{funkcyjnymi}. Zbiór typów prostych określony w myśl powyższej definicji będziemy oznaczali przez \(\mathbb{T}\). Definicję \ref{def:typy-proste} można równoznacznie wyrazić przy pomocy notacji Backusa-Naura. Wówczas ma ona następującą, zwięzłą postać:
\begin{align*}
  \mathbb{T}\ \leftarrow \ U\ |\ (\mathbb{T}\to\mathbb{T})
\end{align*}

Późniejsze litery alfabetu greckiego (\(\sigma,\, \tau,\, \rho,\,\dots\)), być może z indeksami, będą służyły nam za zmienne metasyntaktyczne do oznaczania typów prostych. Dla lepszej czytelności będziemy pomijali najbardziej zewnętrzne nawiasy. Konstruktor typu \(\to\) wiąże prawostronnie; oznacza to, że typy \(\sigma\to\tau\to\rho\) oraz \(\sigma\to(\tau\to\rho)\) będziemy uznawali za tożsame.

Zauważmy, że obiekty skonstruowane w myśl Definicji \ref{def:typy-proste} mają strukturę drzewa binarnego. Wysokość takiego drzewa będziemy nazywali \emph{stopniem} typu. 
\begin{definicja}\label{def:stopien-typu}(Stopień typu)
  Stopniem typu nazywamy następująco określoną funkcję \(\delta :\: \mathbb{T} \to \mathbb{N}\)
  \begin{align*}
    \delta(p) &= 0,\ \text{gdzie \(p\) jest typem atomowym},\\
    \delta(\sigma\to\sigma)&=1 + \max\left(\delta(\sigma),\ \delta(\sigma)\right).
  \end{align*}
\end{definicja}

% \subsection{Pseudotermy}
%   Niech \(\mathrm{V}\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych \(x,\ y,\ \dots\ \) (indeksowanych być może liczbami naturalnymi). Elementy takiego zbioru będziemy nazywali \emph{\(\lambda\)-zmiennymi}.
% \begin{definicja}\label{def:pseudopreterm-simple}(Pseudo-pretermy)\\
%   \emph{Pseudo-pretermami} będziemy nazywali najmniejszy (w sensie mnogościowym) zbiór \(\mathbf{\tilde\Lambda}_{\mathbb{T}}\) taki, że:

%   \begin{enumerate}[label=(PP\arabic*)]
%   \setlength\itemsep{0em}
%   \item Jeśli \(x\in V\), to \(x\in{\mathbf{\tilde\Lambda}}_{\mathbb{T}}\).\label{def:pt-1}
%   \item Jeśli \(M\in\mathbf{\tilde{\Lambda}}_{\mathbb{T}}\) i \(N\in\mathbf{\tilde{\Lambda}}_{\mathbb{T}}\), to \((MN)\in\mathbf{\tilde{\Lambda}}_{\mathbb{T}}\).\label{def:pt-2}
%   \item Dla dowolnych \(x\in V\), \(\sigma\in\mathbb{T}\), \(M\in\mathbf{\tilde{\Lambda}}_{\mathbb{T}}\) mamy, że \((\lambda x:{\sigma}.\,M)\in \mathbf{\tilde{\Lambda}}_{\mathbb{T}}\).\label{def:pt-3}
%   \end{enumerate}
% \end{definicja}
% Elementy \(\mathbf{\tilde\Lambda}_\mathbb{T}\) będziemy oznaczali literami \(L,\ M,\ N,\ P,\ Q,\ R\) i ich wariantami z górnymi lub dolnymi indeksami.Wyrażenia postaci \ref{def:pt-2} nazywamy \emph{aplikacjami} \(M\) do \(N\), zaś wyrażenia postaci \ref{def:pt-3} -- \emph{\(\lambda\)-abstrakcjami}, gdzie o wszystkich podtermach termu \(M\) mówi się, że są w \emph{zasięgu} \(\lambda\)-abstraktora, zaś o \(\lambda\)-zmiennej \(x\) mówi się, że jest nim \emph{związana}. Definicję \ref{def:pseudopreterm-simple} można równoznacznie wyrazić przy pomocy notacji Backusa-Naura. Wówczas ma ona następującą, zwięzłą postać:
% \begin{align*}
%   \mathbf{\tilde\Lambda}\ \leftarrow \ V\ |\ (\mathbf{\tilde\Lambda}\,\mathbf{\tilde\Lambda}) \ |\ (\lambda V.\, \mathbf{\tilde\Lambda})
% \end{align*}

% Stosujemy analogiczne konwencje notacyjne do tych proponowanych przy Definicji \ref{def:lambda-untyped}.

\begin{definicja}(Stwierdzenie, deklaracja, kontekst, sąd)
  \begin{enumerate}[label=(\arabic*)]
  \setlength\itemsep{0em}
  \item \emph{Stwierdzeniem} (ang. \emph{statement}) nazywamy każdy napis postaci \(M:\sigma\), gdzie \(M\in\mathbf{\Lambda}\) i \(\sigma\in\mathbb{T}\). W stwierdzeniu \(M:\sigma\) \(\lambda\)-term \(M\) nazwamy \emph{podmiotem} (ang. \emph{subject}), zaś \(\sigma\) -- \emph{predykatem}.
  \item \emph{Deklaracją} (ang. \emph{declaration}) nazywamy każde stwierdzenie w którym podmot jest zmienną termową.
  \item \emph{Kontekstem} (ang. \emph{context}) nazywamy skończony liniowo uporządkowany zbiór deklaracji, w którym wszystkie podmioty są wzajemnie różne.
  \item \emph{Sądem} (ang. \emph{judgement}) nazywamy kazdy napis postaci \(\Gamma\vdash M:\sigma\), gdzie \(\Gamma\) jest kontekstem, zaś \(M:\sigma\) -- stwierdzeniem.  
  \end{enumerate}
\end{definicja}

Wprowadzamy następujące reguły wyprowadzania typu:
\vspace{0.5em}
    \begin{center}
    \begin{tabular}{ ccc}
      {\begin{prooftree}
        \Hypo{}
        \Infer1[(Var)]{\Gamma, x:\sigma\vdash x:\sigma}
      \end{prooftree}},
      \quad 
      {\begin{prooftree}
        \Hypo{\Gamma \vdash M:\varphi \to \psi} \Hypo{ \Gamma \vdash N:\varphi}
        \Infer2[(App)]{\Gamma \vdash (MN):\psi}
      \end{prooftree}},
      \vspace{1em}
      \\ 
      {\begin{prooftree}
        \Hypo{ \Gamma, x:\varphi \vdash M:\psi }
        \Infer1[(Abs)]{\Gamma \vdash (\lambda\, x:\varphi.\, M):\varphi\to\psi}
      \end{prooftree}}.
      \end{tabular}
\end{center}
\vspace{0.5em}

\begin{definicja}(Typowalność)\\
  Mówimy, że \(\lambda\)-term \(M\) jest typu \(\sigma\) w kontekście \(\Gamma\) (jest \emph{typowalny}), jeśli istnieje skończone drzewo stwierdzeń spełniające poniższe warunki:
  \begin{enumerate}[label=(D\arabic*)]
      \setlength\itemsep{0em}
      \item W korzeniu drzewa znajduje się stwierdzenie \(\Gamma \vdash M:\sigma\).
      \item Liście są \emph{aksjomatami}, czyli stwierdzeniami postaci \(\Gamma, x:\sigma \vdash x:\sigma\).
      \item Każdego rodzica można otrzymać z jego dzieci przez zastosowanie którejś z reguł wyprowadzania typu.
  \end{enumerate}
  Tak określone drzewo będziemy nazywali \emph{wyprowadzeniem} typu i pisali \(\Gamma \vdash_\mathbb{T} M:\sigma\). O stwierdzeniu \(\Gamma \vdash M:\sigma\) będziemy mówili, że jest \emph{wyprowadzalne}.
\end{definicja}

\begin{definicja}(Poprawność)
  \(\lambda\)-term \(M\in\mathbf{\Lambda}\) nazywamy \emph{poprawnym} (ang. \emph{legal}), jeśli istnieje wyprowadzenie \(\Gamma\vdash M:\rho\) dla pewnego kontekstu \(\Gamma\) i typu \(\rho\in\mathbb{T}\). 
\end{definicja}

\subsection{Silna normalizacja}

\begin{lemat}
  Niech \(\tau\in\mathbb{T}\) bedzie dowolnym typem prostym. Wówczas:
  \begin{enumerate}[label=(\arabic*)]
    \setlength\itemsep{0em}
    \item \(\llbracket \tau \rrbracket  \subseteq \mathrm{SN}\).\label{def:l1_a}
    \item Jeśli \(N_1,\,N_2,\,\dots,\,N_k\in\mathrm{SN}\), to \(xN_1 N_2 \dots N_k \in \llbracket \tau \rrbracket\).\label{def:l1_b}
  \end{enumerate}
\end{lemat}
\begin{dowod}
  Dowód przeprowadzimy przez indukcję strukturalną względem \(\tau\). Mamy do rozważenia następujące dwa przypadki:
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item \(\tau\) jest zmienną typową.
     \begin{enumerate}[label=(\arabic*)]
      \setlength\itemsep{0em}
     
        \item Wynika bezpośrednio z definicji \(\llbracket \tau \rrbracket\in \mathrm{SN}\). 
         
        \item Niech \(N_1,\,N_2,\,\dots,\,N_k \in \mathrm{SN}\). Wówczas \(N_1,\,N_2,\,\dots,\,N_k\in\mathrm{SN}\). Z definicji \(\llbracket \tau \rrbracket\) mamy, że \(xN_1 N_2 \dots N_k \in\llbracket \tau \rrbracket\).
      \end{enumerate}

    \item Przypuśćmy, że \(\tau=\sigma\to\rho\) oraz twierdzenie zachodzi dla \(\sigma\) i \(\rho\).
    \begin{enumerate}[label=(\arabic*)]
    \setlength\itemsep{0em}

    \item Niech \(M\in\llbracket \sigma \to \rho\rrbracket\) i niech \(x\) bedzie dowolną \(\lambda\)-zmienną. Z części \ref{def:l1_b} założenia indukcyjnego mamy \(x\in\llbracket \sigma \rrbracket\), zatem z definicji \(\llbracket \sigma\to\rho\rrbracket\) mamy \(Mx\in\llbracket p\rrbracket\). Ponieważ z części \ref{def:l1_a} założenia indukcyjnego \(\llbracket\rho\rrbracket\in\mathrm{SN}\), to \(Mx\in\mathrm{SN}\) i w konsekwencji \(\llbracket\sigma\to\rho\rrbracket\subseteq \mathrm{SN}\).
    \item Niech \(P\in\llbracket \sigma \rrbracket\). Wówczas z części \ref{def:l1_a} założenia indukcyjnego \(P\in\mathrm{SN}\). Chcemy pokazać, że \(xN_1 N_2 \dots N_k \in \llbracket \rho \rrbracket\). Z części \ref{def:l1_b} założenia indukcyjnego \[xN_1 N_2 \dots N_k N_{k+1} \in \llbracket \rho \rrbracket.\] Ustalając \(N_{k+1}\equiv P\) otrzymujemy tezę.
     \end{enumerate}
  \end{enumerate}
  \qed
\end{dowod}

\begin{lemat}
  Załóżmy, że:
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
  \item  \(M[x/N_0]N_1\dots N_k\in\mathrm{SN}\),
  \item  \(N_0\in \mathrm{SN}\).
  \end{enumerate}
  Wówczas \((\lambda x.\,M)N_0 N_1 \dots N_k \in \mathrm{SN}\).
\end{lemat}
\begin{dowod}
  \qed
\end{dowod}
\begin{lemat}
  Załóżmy, że:
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item  \(M[x/N_0]N_1\dots N_k\in \llbracket \tau \rrbracket\),
  \item  \(N_0\in \mathrm{SN}\).
  \end{enumerate}
  Wówczas \((\lambda x.\,M)N_0 N_1 \dots N_k \in \llbracket \tau \rrbracket \).
\end{lemat}
\begin{dowod}
  \qed
\end{dowod}
\begin{definicja}
  Powiemy, że kontekst \(\Gamma=\{x_1:\sigma_1,\,x_2:\sigma_2,\dots ,\,x_n:\sigma_n\}\) \emph{spełnia} stwierdzenie \(M:\sigma\) i będziemy pisali \(\Gamma\models M:\sigma\), jeśli dla dowolnych \(N_1\in\llbracket \sigma_1 \rrbracket\), \(N_2\in\llbracket \sigma_2 \rrbracket\), \(\dots\), \(N_n\in\llbracket \sigma_n \rrbracket\) mamy, że:
  \[
    M[x_1/N_1,\,x_2/N_2,\,\dots,\,x_n/N_n]\in\llbracket \tau \rrbracket.
  \]
\end{definicja}
\begin{twierdzenie}(O poprawności)
  Jeśli \(\Gamma\vdash_{\mathbb{T}}M:\tau\), to \(\Gamma\models M:\tau\).
\end{twierdzenie}
\begin{dowod}
  \qed
\end{dowod}

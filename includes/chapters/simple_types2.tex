\section{Rachunek \(\lambda\) z typami prostymi}\label{sec:simple_types}
\subsection{Typy proste}\label{ssec:typy-proste}
Niech \(U\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych \(p,\ q,\ \dots\ \) (być może indeksowanych liczbami naturalnymi), które będziemy nazywali \emph{zmiennymi typowymi}.

\begin{definicja}\label{def:typy-proste}(Typy proste)
\emph{Typami prostymi} będziemy określali najmniejszy w sensie mnogościowym zbiór wyrażeń taki, że:
\begin{enumerate}[label=(S\arabic*)]
  \setlength\itemsep{0em}
  \item Jeśli \(p\) jest zmienną typową, to \(p\) jest typem prostym.\label{def:t-1}
  \item Jeśli \(\sigma\) i \(\tau\) są typami prostymi, to \(\left(\sigma\to\tau\right)\) jest typem prostym.\label{def:t-2}
\end{enumerate}
\end{definicja}

Zmienne typowe nazywa się w literaturze niekiedy \emph{stałymi typowymi}\footnote{Ta raczej nieszczęśliwa konwencja podkreśla fakt, że abstrakcja nie może odbywać się po zmiennych typowych.}. Typy proste zbudowane tylko wedle reguły \ref{def:t-1} nazywamy typami \emph{atomowymi}, zaś wyrażenia zbudowe wedle reguły \ref{def:t-2} -- typami \emph{funkcyjnymi}. Zbiór typów prostych określony w myśl powyższej definicji będziemy oznaczali przez \(\mathbb{T}\). Definicję \ref{def:typy-proste} można równoznacznie wyrazić przy pomocy notacji Backusa-Naura. Wówczas ma ona następującą, zwięzłą postać:
\begin{align*}
  \mathbb{T}\ \leftarrow \ U\ |\ (\mathbb{T}\to\mathbb{T})
\end{align*}

Późniejsze litery alfabetu greckiego (\(\sigma,\, \tau,\, \rho,\,\dots\)), być może z indeksami, będą służyły nam za zmienne metasyntaktyczne do oznaczania typów prostych. Dla lepszej czytelności będziemy pomijali najbardziej zewnętrzne nawiasy. Konstruktor typu \(\to\) wiąże prawostronnie; oznacza to, że typy \(\sigma\to\tau\to\rho\) oraz \(\sigma\to(\tau\to\rho)\) będziemy uznawali za tożsame.

Zauważmy, że obiekty skonstruowane w myśl Definicji \ref{def:typy-proste} mają strukturę drzewa binarnego. Wysokość takiego drzewa będziemy nazywali \emph{stopniem} typu. 
\begin{definicja}\label{def:stopien-typu}(Stopień typu)
  Stopniem typu nazywamy następująco określoną funkcję \(\delta :\: \mathbb{T} \to \mathbb{N}\)
  \begin{align*}
    \delta(p) &= 0,\ \text{gdzie \(p\) jest typem atomowym},\\
    \delta(\sigma\to\sigma)&=1 + \max\left(\delta(\sigma),\ \delta(\sigma)\right).
  \end{align*}
\end{definicja}

% \subsection{Pseudotermy}
%   Niech \(\mathrm{V}\) będzie przeliczalnie nieskończonym zbiorem zmiennych przedmiotowych \(x,\ y,\ \dots\ \) (indeksowanych być może liczbami naturalnymi). Elementy takiego zbioru będziemy nazywali \emph{\(\lambda\)-zmiennymi}.
% \begin{definicja}\label{def:pseudopreterm-simple}(Pseudo-pretermy)\\
%   \emph{Pseudo-pretermami} będziemy nazywali najmniejszy (w sensie mnogościowym) zbiór \(\mathbf{\tilde\Lambda}_{\mathbb{T}}\) taki, że:

%   \begin{enumerate}[label=(PP\arabic*)]
%   \setlength\itemsep{0em}
%   \item Jeśli \(x\in V\), to \(x\in{\mathbf{\tilde\Lambda}}_{\mathbb{T}}\).\label{def:pt-1}
%   \item Jeśli \(M\in\mathbf{\tilde{\Lambda}}_{\mathbb{T}}\) i \(N\in\mathbf{\tilde{\Lambda}}_{\mathbb{T}}\), to \((MN)\in\mathbf{\tilde{\Lambda}}_{\mathbb{T}}\).\label{def:pt-2}
%   \item Dla dowolnych \(x\in V\), \(\sigma\in\mathbb{T}\), \(M\in\mathbf{\tilde{\Lambda}}_{\mathbb{T}}\) mamy, że \((\lambda x:{\sigma}.\,M)\in \mathbf{\tilde{\Lambda}}_{\mathbb{T}}\).\label{def:pt-3}
%   \end{enumerate}
% \end{definicja}
% Elementy \(\mathbf{\tilde\Lambda}_\mathbb{T}\) będziemy oznaczali literami \(L,\ M,\ N,\ P,\ Q,\ R\) i ich wariantami z górnymi lub dolnymi indeksami.Wyrażenia postaci \ref{def:pt-2} nazywamy \emph{aplikacjami} \(M\) do \(N\), zaś wyrażenia postaci \ref{def:pt-3} -- \emph{\(\lambda\)-abstrakcjami}, gdzie o wszystkich podtermach termu \(M\) mówi się, że są w \emph{zasięgu} \(\lambda\)-abstraktora, zaś o \(\lambda\)-zmiennej \(x\) mówi się, że jest nim \emph{związana}. Definicję \ref{def:pseudopreterm-simple} można równoznacznie wyrazić przy pomocy notacji Backusa-Naura. Wówczas ma ona następującą, zwięzłą postać:
% \begin{align*}
%   \mathbf{\tilde\Lambda}\ \leftarrow \ V\ |\ (\mathbf{\tilde\Lambda}\,\mathbf{\tilde\Lambda}) \ |\ (\lambda V.\, \mathbf{\tilde\Lambda})
% \end{align*}

% Stosujemy analogiczne konwencje notacyjne do tych proponowanych przy Definicji \ref{def:lambda-untyped}.

\begin{definicja}(Stwierdzenie, deklaracja, kontekst, sąd)\label{def:statement_simple}
  \begin{enumerate}[label=(\arabic*)]
  \setlength\itemsep{0em}
  \item \emph{Stwierdzeniem} (ang. \emph{statement}) nazywamy każdy napis postaci \(M:\sigma\), gdzie \(M\in\mathbf{\Lambda}\) i \(\sigma\in\mathbb{T}\). W stwierdzeniu \(M:\sigma\) \(\lambda\)-term \(M\) nazwamy \emph{podmiotem}  (ang. \emph{subject}), zaś \(\sigma\) -- \emph{predykatem}\footnote{Nazwy te historycznie sięgają prac nad semantyką formalną języków naturalnych R. Montague'a.}.
  \item \emph{Deklaracją} (ang. \emph{declaration}) nazywamy każde stwierdzenie w którym podmot jest zmienną termową.
  \item \emph{Kontekstem} (ang. \emph{context}) nazywamy skończony liniowo uporządkowany zbiór (\emph{listę}) deklaracji, w którym wszystkie podmioty są wzajemnie różne.
  \item \emph{Sądem} (ang. \emph{judgement}) nazywamy kazdy napis postaci \(\Gamma\vdash M:\sigma\), gdzie \(\Gamma\) jest kontekstem, zaś \(M:\sigma\) -- stwierdzeniem.  
  \end{enumerate}
\end{definicja}

\begin{definicja}
  \begin{enumerate}[label=(\arabic*)]
  \setlength\itemsep{0em}
  \item Jeśli \(\Gamma=(x_1:\sigma_1,\,\dots,\,x_n:\sigma_n)\), to liniowo
    uporządkowany zbiór \( \mathrm{dom}\, \Gamma = (x_1,\dots,x_n) \) nazywamy
      \emph{dziedziną} kontekstu \(\Gamma\), zaś \( \mathrm{rg}\, \Gamma =(\sigma_1,\,\dots,\,\sigma_n)\) -- zakresem kontekstu \(\Gamma\) oraz
      \begin{align*}
        \mathrm{dom}\,\Gamma &= \{M\in\mathbf{\Lambda}\ |\ (x:\sigma) \in \Gamma \},\\
        \mathrm{rg}\,\Gamma &= \{\sigma\in\mathbb{T}\ |\ (x:\sigma) \in \Gamma \}.
      \end{align*}
    \item Kontekst \(\Gamma'\) nazywamy \emph{podkontekstem} \(\Gamma\) i piszemy \(\Gamma'\subseteq\Gamma\), jeśli wszystkie deklaracje występujące w \(\Gamma\) występują również w \(\Gamma\) z zachowaniem tego samego porządku.
    \item Kontekst \(\Gamma'\) nazywamy \emph{permutacją} kontekstu \(\Gamma\), jeśli wszystkie deklaracje w \(\Gamma'\) występują w \(\Gamma\) i odwrotnie.
    \item Jeśli \(\Gamma\) jest kontekstem i \(\Phi\) jest zbiorem \(\lambda\)-zmiennych, wówczas \emph{projekcją} \(\Gamma\) na \(\Phi\) (symbolicznie \(\Gamma \upharpoonright \Phi\)) nazywamy podkontekst \(\Gamma'\) kontekstu \(\Gamma\) taki, że \(\mathrm{dom} \Gamma' = (\mathrm{dom} \Gamma) \cap \Phi\)  
    \item Dla kontekstów \(\Gamma=(x_1:\sigma_1,\,\dots,\,x_k:\sigma_m)\) i \(\Gamma'=(y_1:\rho_1,\,\dots\,y_n:\rho_n)\) takich, że \(\mathrm{dom}(\Gamma)\cap\mathrm{dom}(\Gamma')=\emptyset\) \emph{konkatenacją} \(\Gamma\) i \(\Gamma'\) nazywamy kontekst
      \[
        \Gamma \concat \Gamma' = (x_1:\sigma_1,\,\dots,\,x_k:\sigma_m,\,y_1:\rho_1,\,\dots\,y_n:\rho_n).
      \]
  \end{enumerate}
\end{definicja}
\begin{przyklad}
  Niech \(\Gamma\equiv(y:\sigma,\,x_1:\rho_1,\,x_2:\rho_2,\,z:\tau,\,x_3:\rho_3)\). Wówczas:
  \begin{enumerate}[label=(\arabic*)]
    \setlength\itemsep{0em}
    \item \(\mathrm{dom}\,\Gamma=(y,\,x_1,\,x_2,\,z,\,x_3)\).
    \item \(\emptyset \subseteq (x_1:\rho_1,\,z:\tau)\subseteq\Gamma\)
    \item \((x_1:\rho_1,\,x_2:\rho_2,\,x_3:\rho_3,\,y:\sigma,\,z:\tau)\) jest permutacją \(\Gamma\).
    \item \(\Gamma\upharpoonright \{z,\,u,\,x_1\}=(x_1:\rho_1,\,z:\tau).\)
  \end{enumerate}
\end{przyklad}

\subsection{Typowanie}
Wprowadzamy następujące reguły wyprowadzania typu (relacji typowalności):
\vspace{0.5em}
\begin{center}
    \begin{tabular}{ ccc}
      \(\Gamma \vdash x:\sigma\ \text{(var)}\), & jeśli \(x:\sigma\in\Gamma\),
      \vspace{1em}\\
      {\begin{prooftree}
        \Hypo{\Gamma \vdash M:\sigma \to \tau} \Hypo{ \Gamma \vdash N:\sigma}
        \Infer2[(app)]{\Gamma \vdash (MN):\tau}
      \end{prooftree}},&
      \vspace{1em}
      \\ 
      {\begin{prooftree}
        \Hypo{ \Gamma, x:\sigma \vdash M:\tau}
        \Infer1[(abs)]{\Gamma \vdash (\lambda\, x.\, M):\sigma\to\tau}
      \end{prooftree}}.&
      \end{tabular}
\end{center}

\vspace{0.5em}

W systemie tym mamy do czynienia z wyraźnym podziałem na obiekty dwóch rodzajów: \(\lambda\)-termy i typy. \(\lambda\)-termy możemy przekształcać dwoma dualnymi operacjami: \(\lambda\)-abstrakcją i aplikacją. Rezultat operacji zależy od wyboru zmiennej wolnej, którą chcemy wyabstrahować z termu albo wyboru termu, który chcemy zaaplkować do innego termu, odpowiednio. Dlatego mówimy, że w rachunku \(\lambda\) z typami prostymi termy \emph{zależą} od termów. Ponieważ abstrahowanie przebiega wyłącznie po zbiorze \(\lambda\)-zmiennych, mówimy, że zależność (abstrakcja) jest \emph{pierwszego rzędu}.

\begin{definicja}(Typowalność)\\
  Mówimy, że \(\lambda\)-term \(M\) jest typu \(\sigma\) w kontekście \(\Gamma\), jeśli istnieje skończone drzewo sądów spełniające poniższe warunki:
  \begin{enumerate}[label=(D\arabic*)]
      \setlength\itemsep{0em}
      \item W korzeniu drzewa znajduje się sąd \(\Gamma \vdash M:\sigma\).
      \item Liście są \emph{aksjomatami}, czyli sądami postaci \(\Gamma \vdash x:\sigma\).
      \item Każdego rodzica można otrzymać z jego dzieci przez zastosowanie którejś z reguł wyprowadzania typu.
  \end{enumerate}
  Tak określony obiekt będziemy nazywali \emph{wyprowadzeniem} typu dla \(M\) (w kontekście \(\Gamma\)) i pisali \(\Gamma \vdash_\mathbb{T} M:\sigma\). O sądzie \(\Gamma \vdash M:\sigma\) będziemy wówczas mówili, że jest \emph{wyprowadzalny}. %Jeśli wyprowadzalność sądu będzie jednoznacznie wynikała z kontekstu, to będziemy omijać indeks \(\mathbb{T}\) przy symbolu \(\vdash_\mathbb{T}\).
\end{definicja}

\begin{przyklad}\label{ex:typing}
 \begin{enumerate}[label=(\alph*)]
  \setlength\itemsep{0em}
  \item
    Niech \(\Gamma=(x:\sigma,\, y:\tau)\). Pokażemy, że \(\mathrm{K}=\lambda x y.\, x\) ma typ \(\sigma\to\tau\to\sigma\). Istotnie,
  \begin{center}
  \begin{prooftree}
    \Hypo{x:\sigma, y:\tau \vdash x:\sigma}
    \Infer1[(abs)]{x:\sigma \vdash \lambda y.\,x:{\tau\to\sigma}}
    \Infer1[(abs)]{\vdash \lambda x y.\, x:{\sigma\to\tau\to\sigma}}
\end{prooftree}
  \end{center}

\item\label{ex:typing_2}
    Niech \(\Gamma=(x:{\tau\to\rho},\, y:{\sigma\to\tau},\,z:{\sigma})\). Wówczas:
  \begin{center}
\begin{prooftree}
  \Hypo{\Gamma\vdash x:{\tau\to\rho}}   \Hypo{\Gamma \vdash y:{\sigma\to\tau}} \Hypo{ \Gamma \vdash z:{\sigma}} \Infer2[(app)]{\Gamma \vdash yz:{\tau}}
  \Infer2[(app)]{\Gamma \vdash x(yz):\rho}
  \Infer1[(abs)]{x:{\tau\to\sigma}, y:{\sigma\to\rho}\vdash \lambda z .\, x(yz):{\sigma\to\rho}}
  \Infer1[(abs)]{x:{\tau\to\rho}\vdash \lambda y z.\,x(yz):{(\sigma\to\tau)\to\sigma\to\rho}}
  \Infer1[(abs)]{\vdash \lambda x y z .\, x(yz):{(\tau\to\rho)\to(\sigma\to\tau)\to\sigma\to\rho}}
\end{prooftree}
  \end{center}
\item
  Nie wszystkie \(\lambda\)-termy są typowalne. Niech \(\omega\equiv (\lambda x.\, x x)\) i przypuśćmy, że \(\omega\) ma typ \(\sigma\) w kontekście \(\Gamma\). Zauważmy, że wówczas w \(x:{\sigma\to\sigma}\in\Gamma\). Ponieważ \(\omega\) zawiera w sobie podterm \((xx)\), to w wyprowadzeniu musiał on zostać otrzymany przez zastosowanie reguły (app). Wówczas \(x:\sigma \in \Gamma\)  i \(x:{\sigma\to\sigma} \in \Gamma\), co nie jest możliwe, bo wszystkie deklaracje w \(\Gamma\) muszą mieć różne podmioty.
  %Co więcej, można wykazać że typ \((\tau\to\rho)\to(\sigma\to\tau)\to\sigma\to\rho\) może mieć tylko i wyłącznie operacja złożenia~\cite{Wadler1989}.
\end{enumerate}
%  Zauważmy, że term \(\lambda x^{\tau\to\rho}\lambda y^{\sigma\to\tau}\lambda z^\sigma . x(yz)\) odpowiada operacji złożenia funkcji.
\end{przyklad}

\begin{uwaga*}
  Notacja dowodowa zaproponowana w Przykładzie \ref{ex:typing} wprowadza wiele redundancji, która utrudnia zorientowanie się w dłuższych wyprowadzeniach, zaś zlinearyzowanie dowodów pozwala na notowanie kolejnych sądów w arbitralnym porządku. Nic nie stoi na przeszkodzie abyśmy ograniczyli się tylko do rozpatrywania wyprowadzeń, w których zależności pomiędzy sądami ustalają ścisły porządek częściowy, tzn. takich, że:
  \begin{easylist}
    &   żaden sąd nie poprzedza sam siebie (antyzwrotność),
   
    &  jeśli jeden sąd poprzedza drugi, to drugi nie poprzedza pierwszego (antysymetryczność),
    & jeśli sąd \(J_k\) poprzedza \(J_l\) i \(J_l\) poprzedza \(J_m\), to \(J_k\) poprzedza \(J_m\) (przechodzniość).
  \end{easylist}
  Taki charakter dowodów oddaje wariant notacji w postaci drzew wprowadzony przez Pravitza i proponowany w \cite{Hindley:2008:LCI:1388400}. Powtarzanie się kontekstów eliminuje się w niej przez wprowadzanie każdej deklaracji do dowodu przed użyciem i wykreślanie jej po użyciu. W dalszej części pracy będziemy korzystać z analogicznej pod wieloma względami notacji Fitcha (tzw. notacji flagowej). Poniżej pokazujemy wyprowadzenia typu z Przykładu \ref{ex:typing} w tej notacji.
  \begin{enumerate}[label=(\alph*)]
   \item
  \begin{equation*}
    \begin{fitch}
      \fh x:\sigma & (var) \\
      \fa \fh y:\sigma & (var) \\
      \fa \lambda y.\,x:\tau\to\sigma:\sigma & (abs) 1 \\
      \lambda x y.\,x:\sigma\to\tau\to\sigma & (abs) 3
    \end{fitch}
  \end{equation*}
  \item
  \begin{equation*}
    \begin{fitch}
      \fh x:\tau\to\rho & (var) \\
      \fa \fh y:\sigma\to\tau & (var) \\
      \fa \fa \fh z:\sigma & (var) \\
      \fa \fa \fa yz:\tau & (app)\ 2\ 3 \\
      \fa \fa \fa x(yz):\rho & (app) 1 4 \\
      \fa \fa \lambda z.\,x(yz):\sigma\to\rho & (abs) 5 \\
      \fa \lambda yz.x(yz):(\sigma\to\tau)\to\sigma\to\rho & (abs) 6\\
      \lambda x y z.\,x(yz):(\tau\to\rho)\to(\sigma\to\tau)\to\sigma\to\rho & (abs) 7 
    \end{fitch}
  \end{equation*}
 \end{enumerate}
\end{uwaga*}

\begin{definicja}(Poprawność, typowalność)
  \(\lambda\)-term \(M\in\mathbf{\Lambda}\) nazywamy \emph{poprawnym} (ang. \emph{legal}) lub \emph{typowalnym} (ang. \emph{typable}), jeśli istnieje wyprowadzenie \(\Gamma\vdash M:\rho\) dla pewnego kontekstu \(\Gamma\) i typu \(\rho\in\mathbb{T}\). 
\end{definicja}

\subsubsection{Rodzaje problemów} 
W teorii typów spotykamy trzy rodzaje problemów dotyczące sądów:
\begin{enumerate}
  \setlength\itemsep{0em}
  \item \emph{Problem typowalności} (ang. \emph{well-typedness, typability})

    Polega na rozstrzygnięciu czy zadany term jest poprawny, czyli znalezieniu kontekstu oraz wyprowadzenia typu względem tego kontekstu dla zadanego termu. Symbolicznie:
    \[ \mathbf{?} \vdash \text{term}\ :\ \mathbf{?} \]
    Problem typowalności przy zadanym kontekście nazywamy problemem \emph{przypisania typu} (ang. \emph{type assignment}). Ma on nastepującą postać: 
    \[ \text{kontekst} \vdash \text{term}\ :\ \mathbf{?} \]
  \item \emph{Problem weryfikacji typu} (ang. \emph{type checking}) 
    
    Polega na sprawdzeniu czy term ma zadany typ względem danego kontekstu.
    \[ \text{kontekst} \stackrel{\mathbf{?}}{\vdash} \text{term}\ :\ \text{typ} \]
  \item \emph{Problem inhabitacji} (ang. \emph{inhabitation, term finding})

    Polega na skonstruowaniu termu (lub przynajmniej wykazaniu istnienia takiego termu), który    miałby zadany typ względem danego kontekstu. 
    \[
      \text{kontekst} \vdash \mathbf{?}\ :\ \text{typ}
    \]
\end{enumerate}

W wielu systemach problem typowalności można sprowadzić do problemu weryfikacji typu. Istotnie, przypuśćmy, że \(M\) jest poprawnym termem i \(\mathrm{FV}(M)=\{x_1,\,\dots\,x_n\}\). Zauważmy, że \(M\) jest typowalny, jeśli wyprowadzalny jest sąd
\[
  x_0:p\vdash \mathrm{K} x_0 (\lambda x_1 \dots x_n.\,M):p,
\]
gdzie \(p\in U\) jest zmienną typową, zaś kombinator \(K\equiv \lambda xy.\,x\).

Wszystkie wymione problemy są w rachunku \(\lambda\) z typami prostymi są rozstrzygalne\footnote{Nie jest to bynajmniej oczywiste dla innych systemów typów; za przykład wystarczy wziąć słynny wynik J. B. Wellsa \cite{Wells_98}, który stwierdza, że  problemy typowalności i weryfikacji typu w Systemie F są nierozstrzygalne. Stąd w praktyce uzasadnione jest zainteresowanie mniej ekspresywnymi systemami typów, np. systemem Hindleya-Milnera.}, tzn. istnieją efektywnie obliczalne metody ich rozwiązywania. Czytelnika zainteresowanego szczegółami odsyłamy do \cite[Twierdzenie 3.2.7]{Urzyczyn2006} i \cite[Rozdział 4.4]{Barendregt_1992}.

\subimport{includes/chapters/}{unification.tex}

\subsection{Własności}

Przedstawimy teraz szereg lematów ustalających między innymi związki między rachunkiem \(\lambda\) bez typów wprowadzonym w Rozdziale \ref{sec:untyped_lambda}, a rachunkiem \(\lambda\) z typami prostymi.

\begin{lemat}(O generowaniu)\label{thm:generation}
  \begin{enumerate}[label=(\arabic*)]
     \setlength\itemsep{0em}
     \item Jeśli \(\Gamma\vdash_{\mathbb{T}} x:\sigma\), to \(x:\sigma\in\Gamma\).\label{thm:generation_1}
     \item Jeśli \(\Gamma\vdash_{\mathbb{T}}MN:\tau\), to \(\Gamma\vdash_\mathbb{T} M:\sigma\to\tau\) i \(\Gamma\vdash_\mathbb{T} N:\sigma\) dla pewnego \(\sigma\in\mathbb{T}\).\label{thm:generation_2}
     \item Jeśli \(\Gamma\vdash_{\mathbb{T}}\lambda x.\, M:\tau\) i \(x\not\in\mathrm{dom}\,\Gamma\), to \(\tau\equiv \tau_1\to\tau_2\) oraz \(\Gamma,x:\tau_1\vdash_\mathbb{T} N:\tau_2\). \label{thm:generation_3}
  \end{enumerate} 
\end{lemat}
\begin{dowod}
  Wynika natychmiast z postaci \(\lambda\)-termu.  \qed
\end{dowod}

\begin{lemat}(O podtermie)
  Podterm poprawnego \(\lambda\)-termu jest poprawny.
  % (Given as Proposition 3.2.9 (see also 3.1.9) in Barendregt, 1992.)
\end{lemat}
\begin{dowod}
  Załóżmy, że sąd \(J: \Gamma\vdash M:\sigma\) jest wyprowadzalny. Dowód przebiega przez indukcję wględem długosci wyprowadzenia \(J\). Rozważmy następujące przypadki:
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item Jeśli \(J\) jest konsekwencją reguły \emph{var}, to \(\mathrm{Sub}(M)=\{M\}\) (Definicja~\ref{def:untyped_subterm}.\ref{def:untyped_subterm_1}), a zatem teza jest trywialnie spełniona.
     \item Jesli \(J\) jest konsekwencją reguły \emph{app}, to \(M\equiv PQ\) dla \(P,\,Q\) dla których twierdzenie zachodzi. Ponieważ \(\mathrm{Sub}(M)=\mathrm{Sub}(P)\cup\mathrm{Sub}(Q)\cup\{PQ\}\) (Definicja~\ref{def:untyped_subterm}.\ref{def:untyped_subterm_2}), to teza również zachodzi.
    \item Jeśli \(J\) jest konsekwencją reguły \emph{abs}, to \(M\equiv \lambda
      x.\,P\) dla pewnego \(P\) dla którego twierdzenie zachodzi. Ponieważ
      \(\mathrm{Sub}(\lambda x.\,M) = \mathrm{Sub}(M) \cup \{\lambda x.\,M\}\),
      (Definicja~\ref{def:untyped_subterm}.\ref{def:untyped_subterm_3})
      to teza zachodzi również w tym przypadku.
  \end{enumerate}
  \qed
\end{dowod}

\begin{lemat}(O zmiennych wolnych)
  Jeśli sąd \(J: \Gamma \vdash L:\sigma\) jest wyprowadzalny, to \(\mathrm{FV}(L)\subseteq \mathrm{dom}\,\Gamma\).
\end{lemat}
\begin{dowod}
  Prosty dowód przeprowadzamy przez indukcję względem długości wyprowadzenia sądu \(J\). Rozważmy następujące przypadki:
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item Jeśli \(J\) jest konsekwencą reguły \emph{var}, to \(L\equiv x\) dla pewnej \(\lambda\)-zmiennej \(x\). Wobec tego \(x:\sigma\in\Gamma\), a zatem \(\mathrm{FV}(x)\subseteq\mathrm{dom}\,\Gamma\).
    \item Jesli \(J\) jest konsekwencją reguły \emph{app}, to \(J\) musi mieć postać \(\Gamma\vdash MN:\sigma\). Z założenia indukcyjnego: \(\mathrm{FV}(M)\subseteq \mathrm{dom}\,\Gamma\) i  \(\mathrm{FV}(N)\subseteq \mathrm{dom}\,\Gamma\). Z Definicji \ref{def:untyped_fv}: \(\mathrm{FV}(MN)=\mathrm{FV}(M)\cup\mathrm{FV}(N)\). Stąd \(\mathrm{FV}(MN)\subseteq \mathrm{dom}\,\Gamma\).
    \item Jesli \(J\) jest konsekwencją reguły \emph{abs}, to \(J\) musi mieć postać \(\Gamma\vdash \lambda x.\,M:\sigma\). Z założenia indukcyjnego \(FV(M)\subseteq\mathrm{dom}\,\Gamma\). Ponieważ \(\mathrm{FV}(\lambda x.\,M)=\mathrm{FV}(M)\setminus\{x\}\subseteq\mathrm{FV}(M)\) (z Definicji \ref{def:untyped_fv}), to \(\mathrm{FV}(M)\subseteq\mathrm{dom}\,\Gamma\). 
  \end{enumerate}  
  \qed
\end{dowod}

\begin{lemat}\label{thm:permutation_simple}
  \begin{enumerate}[label=(\arabic*), ref=(\arabic*)]
    \setlength\itemsep{0em}
    \item Niech \(\Gamma'\) i \(\Gamma''\) bedą kontekstami takimi, że \(\Gamma' \subseteq \Gamma''\). Jeśli \(\Gamma'\vdash M:\sigma\), to \(\Gamma''\vdash M:\sigma\).
    \item Jeśli \(\Gamma\vdash M:\sigma\), to \(\Gamma \upharpoonright \mathrm{FV}(M)\vdash M:\sigma\).
    \item Jeśli \(\Gamma\vdash M:\sigma\) i \(\Gamma'\) jest permutacją \(\Gamma\), to \(\Gamma'\vdash M:\sigma\).\label{thm:permutation_3}
  \end{enumerate}
\end{lemat}
\begin{dowod}
  Dowody przebiegają przez indukcję względem długości wyprowadzenia. Czytelnika zainteresowanego szczegółami odsyłamy do \cite[Tw. 3.1.7]{Barendregt_1992}. 
  \qed
\end{dowod}

\begin{uwaga*}
  Zauważmy, że (\ref{thm:permutation_simple}.\ref{thm:permutation_3}) rozluźnia konieczność eliminowania maksymalnej deklaracji z kontekstu przy stosowaniu reguły \emph{abs}. W tekstach wprowadzających typy proste zazwyczaj przez kontekst rozumie się po prostu skończony zbiór wzajemnie różnych deklaracji \cite{Barendregt_1992, Urzyczyn2006, Hindley:2008:LCI:1388400}. Określenie na tak rozumianych kontekstach porządku liniowego upraszcza przeprowadzanie rozumowań indukcyjnych. Ponieważ branie dowolnej permutacji listy nie wpływa na typizację, to widzimy, że obydwa znaczenia możemy stosować zamiennie, bowiem jest to nic innego jak traktowanie kontekstu jako zbioru deklaracji. 
\end{uwaga*}

\begin{lemat}(O podstawieniu)\label{thm:substitution}
  Załóżmy, że
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item \(\Gamma_1,\,x:\sigma,\,\Gamma_2\vdash M:\rho\) 
    \item \(\Gamma_1\vdash N:\sigma\)
  \end{enumerate}
  Wówczas \(\Gamma_1,\Gamma_2 \vdash M[x/N]:\rho\).
\end{lemat}
\begin{dowod}
%  Dowód przebiega przez indukcję względem długości wyprowadzenia typu \(M\). 
%   \begin{enumerate}[label=(\roman*)]
%    \setlength\itemsep{0em}
  Niech \(\Gamma=\Gamma_1 \concat \Gamma_2\). Korzystając z części \ref{thm:permutation_3} Lematu \ref{thm:permutation_simple}
  dowód przeprowadzimy przez indukcję względem długości wyprowadzenia \(\Gamma,\,x:\sigma\vdash M:\rho\). Rozważmy następujące przypadki:
    \begin{enumerate}[label=(\roman*)]
      \setlength\itemsep{0em}
      \item   Jeśli    \(\Gamma,\,x:\sigma\vdash   M:\rho\)   jest
konsekwencją reguły  \emph{var},  to   \(M\equiv  x\).  Wówczas
        \(M[x/N]\equiv N\) i \(\rho \equiv  \sigma\). Teza zachodzi w oczywisty
sposób.
      \item  \(\Gamma,\,x:\sigma\vdash M:\rho\)  jest konsekwencją
      reguły  \emph{app}.   Wówczas \(M\equiv  PQ\)   i  istnieją
      wyprowadzenia    \(\Gamma,\,x:\sigma\vdash    P:\tau\to\rho\)
      oraz  \(\Gamma,\,  x:\sigma\vdash   Q:\tau\).  Z  założenia
      indykcyjnego  mamy,  że \(  \Gamma\vdash  P[x/N]:\tau\to\rho
        \)   oraz   \(   \Gamma\vdash   Q[x/N]:\tau   \). Wówczas stosując regułę \emph{app} mamy:
      \begin{center}
      {\begin{prooftree}
        \Hypo{\Gamma \vdash P[x/N]:\tau \to \rho} \Hypo{ \Gamma \vdash Q[x/N]:\tau}
        \Infer2[(app)]{\Gamma \vdash (P[x/N]Q[x/N]):\rho}
      \end{prooftree}},
      \end{center}
      Tezę otrzymujemy z faktu, że \((PQ)[x/N]=P[x/N]Q[x/N]\). 
    \item Jeśli \(\Gamma,\,x:\sigma\vdash   M:\rho\) jest konsekwencją reguły \emph{abs}, to \(M\equiv \lambda y.\,P:\rho\) dla \(\rho\equiv \sigma\to\tau,\,y\not\equiv x\). Z założenia indukcyjnego istnieje wyprowadzenie
      \( \Gamma',\,y:\tau\vdash P[x/N]:\rho \), gdzie \(\Gamma'=\Gamma\concat (x:\sigma)\).
        Wówczas, stosując regułę \emph{abs} mamy:
      \begin{center}  
        {\begin{prooftree}
          \Hypo{ \Gamma', y:\tau\vdash P[x/N]:\rho}
          \Infer1[(abs)]{\Gamma' \vdash (\lambda\, y.\, P[x/N]):\tau\to\rho}
        \end{prooftree}}
      \end{center}
        Ponieważ \((\lambda y.\,P)[x/N]=\lambda y.\,P[x/N]\) oraz \(M\equiv \lambda y.\,P:\tau\to\rho\), otrzymujemy tezę.
    \end{enumerate}
    \item    
  \qed
%  \end{enumerate}
\end{dowod}
\begin{lemat}(Redukcja podmiotu)\label{thm:subject_reduction}
    Załóżmy, że
    \begin{enumerate}[label=(\roman*)]
      \setlength\itemsep{0em}
      \item \(\Gamma\vdash_\mathbb{T} M:\sigma\) 
      \item \(M\to^{*}_\beta N\)
    \end{enumerate}
    Wówczas \(\Gamma\vdash_\mathbb{T}N:\sigma\).
\end{lemat}
\begin{dowod}
  Pokażemy, że twierdzenie zachodzi dla jednego kroku redukcji \(\to_\beta\). Dowód zwrotności jest trywialny, zaś aby pokazać przechodniość wystarczy skorzystać z indukcji wzgledem długości ciągu redukcji.

  Niech \(M\to_\beta N\). Dowód przeprowadzimy przez indukcję względem długości wyprowadzenia \(\Gamma\vdash M:\sigma\). Rozważmy następujące przypadki:
  \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{0em}
    \item    \(\Gamma\vdash     M:\sigma\)    jest    konsekwencją
    reguły   \emph{var}.  Wówczas   \(M\equiv   x\)  dla   pewnej
    \(\lambda\)-zmiennej  \(x\in   V\).  Wówczas   poprzednik  nie
    jest  spełniony,   bowiem  \(M\)  nie  da   się  zredukować.
    Zatem  twierdzenie  trywialnie zachodzi.  
  
    \item  \(\Gamma\vdash  M:\sigma\)  jest  konsekwencją  reguły
    \emph{app}.    Wówczas   \(M\equiv    PQ\)   oraz    istnieją
    wyprowadzenia  \(\Gamma\vdash   P:\tau\to\sigma\)  oraz  \(\Gamma
    \vdash   Q:\sigma\).   Ponadto   zakładamy,  że   dla   pewnych
    \(P',\,Q'\in\mathbf{\Lambda}\)   mamy   \(P\to_\beta   P'\)   i
    \(Q\to_\beta   Q'\).  Istnieją   dwie  możliwości   redukcji
    \(M\to_\beta N\):
      \begin{enumerate}[label=(\arabic*)]
        \setlength\itemsep{0em}
        \item \(N\equiv PQ'\). Poniważ \(\Gamma\vdash Q':\sigma\) (założenie indukcyjne), to możemy zastosować regułę \emph{app}:

        \begin{center}
          {\begin{prooftree}
            \Hypo{\Gamma \vdash P:\tau \to \sigma} \Hypo{ \Gamma \vdash Q':\tau}
            \Infer2[(app)]{\Gamma \vdash PQ':\sigma}
          \end{prooftree}},
        \end{center}
          Ponieważ \(N\equiv PQ'\), to otrzymujemy tezę. 
          \label{thm:subject_reduction_1}
        \item \(N\equiv P'Q\). Postępujemy analogicznie do przypadku \ref{thm:subject_reduction_1}
      \end{enumerate}
    \item  \(\Gamma\vdash  M:\sigma\)  jest  konsekwencją  reguły
    \emph{abs}.  Wówczas \(M\equiv  \lambda  x.\,P\), dla  pewnych
    \(\rho,\,\tau\in\mathbb{T}\) mamy  \(\sigma\equiv \rho\to\tau\)
    oraz   istnieje  wyprowadzenie   sądu  \(\Gamma,\,x:\rho\vdash
      P:\tau\). Ponadto zakładamy, że dla pewnego \(P'\in\mathbf{\Lambda}\)
      mamy \(P\to_\beta P'\). \(\beta\)-redukcja \(M\to_\beta N\) musi prowadzić w tym wypadku do \(N\equiv \lambda x.\,P'\). Ponieważ \(\Gamma, x:\rho\vdash P':\tau\) (założenie indukcyjne), to możemy zastosowac regułę \emph{abs}:
      \begin{center}  
        {\begin{prooftree}
          \Hypo{ \Gamma', x:\rho\vdash P':\tau}
          \Infer1[(abs)]{\Gamma \vdash \lambda\, x.\, P':\rho\to\tau}
        \end{prooftree}}
      \end{center}
      Stąd teza.
  \end{enumerate}
  \qed
\end{dowod}

\begin{lemat}(Zachowawczość \(\eta\)-redukcji)
    Załóżmy, że
    \begin{enumerate}[label=(\roman*), ref=\roman*]
      \setlength\itemsep{0em}
      \item \(\Gamma\vdash_\mathbb{T} M:\sigma\) 
      \item \(M\to^{*}_\eta N\)
    \end{enumerate}
    Wówczas \(\Gamma\vdash_\mathbb{T}N:\sigma\).
\end{lemat}

\begin{dowod}
  Dowód przeprowadzamy analogicznie do Lematu \ref{thm:subject_reduction}.\qed
\end{dowod}

\begin{twierdzenie}(Własność Churcha-Rossera)
  Relacja \(\to_\beta\) określona na typowalnych \(\lambda\)-termach  ma własność CR.
\end{twierdzenie}
\begin{dowod}
  Wynika to bezpośrednio z Twierdzenia \ref{thm:cr_untyped} i Lematu \ref{thm:subject_reduction}. \qed
\end{dowod}

\subimport{includes/chapters/}{polymorphism.tex}

\subimport{includes/chapters/}{strong_normalization.tex}
% \begin{fakt}\label{thm:uniqueness}
% Jesli \(\Gamma\vdash M^\sigma\) oraz \(\Gamma\vdash M^\tau\), to \(\sigma=\tau\).
% \begin{dowod}
%   Dowód przez indukcję strukturalną względem M. \qed
% \end{dowod}
% \end{fakt}

\subimport{includes/chapters/}{to_church_style.tex}
\subsection{Podsumowanie}
System typów, który był przedmiotem Rozdziału \ref{sec:simple_types} jest najbardziej elementarnym przypadkiem typowanego rachunku \(\lambda\)\footnote{Patologicznym przypadkiem jest rachunek \(\lambda\) bez typów, jeśli przyjmiemy, że wszystkie wyrażenia mają w nim dokładnie jeden typ. Argument ten często podejmowany jest na rzecz statycznie typowanych języków programowania.}. W literaturze często spotyka się być może jeszcze prostszy, równoważny wariant typów prostych, w którym wszystkie typy buduje się wyłącznie z jednej stałej typowej. Pod pojęciem typów prostych rozumie się także szereg rozszerzeń przedstawionego przez nas systemu.% Ich celem jest zwiększenie ekspresji, np. o odpowiednie konstrukcje dla par%, w których pierwszy element może być innego typu niż drugi. Konstrukcja ta jest bowiem niemożliwa w naszym, elementarnym ujęciu.

% Istotnie, rozważmy następujące kodowanie pary i dwóch projekcji:
% \begin{align*}
%   \mathrm{pair}&\equiv\lambda x:\sigma\, \lambda y:\tau.\ z x y \\
%   \mathrm{fst} &\equiv \lambda p:\sigma\to\sigma.\ p\,(\lambda x:\sigma\, \lambda y:\tau.\ x) \\
%   \mathrm{snd} &\equiv \lambda p:\tau\to\tau.\ p\,(\lambda x:\sigma\, \lambda y:\tau.\ y) 
% \end{align*}

Mają one na ogół szczególny cel praktyczny: na przykład rozszerzenie o typ dla par umożliwiają elegancką prezentację analogii między intuicjonistycznym rachunkiem zdań, typowanym rachunkiem \(\lambda\) i kategoriami kartezjańsko domkniętymi, znanej szerzej jako izomorfizm Currego-Howarda-Lambeka \cite[Rozdział 3.1]{Girard:1989:PT:64805}. Nie wpływa to jednak na samą istotę typowania.  

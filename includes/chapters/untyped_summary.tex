\subsection{Podsumowanie}
Istotą rachunku \(\lambda\) bez typów jest uchwycenie pojęcia aplikacji argumentu do funkcji. Kodując selektor \texttt{if} dla typu \texttt{Boolean} w \ref{ref:untyped_simple_enumeration} zauważmy, że nic nie powstrzymuje nas przed zaaplikowaniem do wyrażenia \texttt{if} dowolnego \(\lambda\)-termu. Analogiczna sytuacja ma miejsce, gdy określamy operacje na reprezentacji liczb naturalnych. Widzimy, że w ramach tak zakrojonego systemu nie mamy możlwiości uchwycenia które rezultaty są sensowne. Jak przekonamy się w Rozdziale \ref{sec:simple_types}, problem ten eliminuje w pewnym stopniu rozszerzenie systemu rachunku \(\lambda\) o typy wyrażeń. Wówczas aplikacja argumentu do funkcji wymaga wcześniejszej \emph{weryfikacji} typu, zaś typy argumentów oraz rezultatu funkcji są z góry określone (z dokładnością do polimorfizmu). Niestety, w rezultacie otrzymujemy system w którym wiele sensownych wyrażeń możliwych do zbudowania w rachunku \(\lambda\) nie jest poprawnych. Szukanie bogatych systemów typów, które jednocześnie nie ograniczałyby ekspresji (lub mówiąc bardziej obrazowo językiem informatyki: pozwalałyby na określenie większej ilości poprawnie zbudowanych programów ograniczając ilość tych błędnych) jest stale pojawiającym się tematem w dziedzinie teorii typów.

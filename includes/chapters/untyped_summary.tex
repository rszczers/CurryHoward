\subsection{Podsumowanie}
Istotą rachunku \(\lambda\) bez typów jest uchwycenie pojęcia aplikacji argumentu do funkcji. Kodując selektor \texttt{if} dla typu \texttt{Boolean} w \ref{ref:untyped_simple_enumeration} zauważmy, że nic nie powstrzymuje nas przed zaaplikowaniem do wyrażenia \texttt{if} dowolnego \(\lambda\)-termu. Analogiczna sytuacja ma miejsce, gdy określamy operacje na reprezentacji liczb naturalnych. Widzimy, że w ramach tak zakrojonego systemu nie mamy możlwiości uchwycenia które rezultaty są sensowne. Jak przekonamy się w Rozdziale \ref{sec:simple_types}, problem ten eliminuje w pewnym stopniu rozszerzenie systemu rachunku \(\lambda\) o typy wyrażeń. Wówczas aplikacja argumentu do funkcji wymaga wcześniejszej \emph{weryfikacji} typu, zaś typy argumentów oraz rezultatu funkcji są z góry określone (z dokładnością do podstawienia). Niestety, w rezultacie otrzymujemy system w którym wiele sensownych wyrażeń możliwych do zbudowania w rachunku \(\lambda\) nie jest poprawnych. W dziedzinie projektowania języków programowania pożądane zaś są bogate systemy typów, które jednocześnie nie ograniczają ekspresji (lub mówiąc bardziej obrazowo: pozwalałyby na określenie większej ilości poprawnie zbudowanych programówm, ograniczając ilość tych błędnych). 

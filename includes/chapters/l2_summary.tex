\subsection{Język pośredni GHC}

Języki programowania to narzędzia służące do reprezentowania pojęć i łączących je wzajemnie zależności w sposób umożliwiający efektywne tłumaczenie ich na język maszynowy. Myśleć można o nich w bardzo uproszczony sposób jak o środkach komunikacji człowieka z maszyną.

GHC (ang. \emph{Glasgow Haskell Compiler}) to otwartoźródłowy kompilator języka Haskell. Kompilatorem nazywamy program, którego zadaniem jest tłumaczenie kodu programu napisanego w danym języku (w \emph{języku kodu źródłowego}) na kod w innym języku (języku \emph{wyjściowym}) z zachowaniem własności programu wejściowego. GHC jest stosunkowo wyjątkowym kompilatorem, gdyż kompilację do kodu wyjściowego poprzedza w nim kompilacja do kodu \emph{pośredniego}, który jest rozszerzonym wariantem Systemu F w stylu Churcha \cite{Sulzmann2007}. 

Język Haskell to polimorficzny statycznie typowany, leniwy, czysto funkcyjny język programowania. Leniwość odnosi się do strategii ewaluacji nakreślonej w Rozdziale \ref{subsec:lazy_eval}. Funkcyjność języka polega na tym, że funkcje są w nim obiektami pierwszego rzędu, tzn. można z nich budować struktury danych i przesyłać jako argument tak jak pozostałe obiekty języka. Czystość oznacza ograniczenie efektów ubocznych: funkcje nie współdzielą stanu i zwracają za każdym razem tę samą wartość obliczenia. 

\paragraph{Statyczność}
Określenie \emph{statyczny} oznacza, że na etapie kompilacji do kodu wyjściowego wszystkie typy wyrażeń są ustalone właśnie na gruncie języka pośredniego. Jest kontynuacja wywodzącej się z lat '70 idei oparcia języków programowania na czystym rachunku \(\lambda\) wspomnianej w Rozdziale \ref{subsec:scott_encoding}.

Rozważmy następujący przykładowy kod źródłowy w języku Haskell. Funkcja \texttt{comp} to polimorficzne złożenie funkcji.

\begin{minted}{haskell}
module Fnord where
  comp = \g f x -> g (f x)
\end{minted}

Przypomnijmy Przykład \ref{ex:f_typing_5}, którego rezultatem było następujące przypisanie typu:
\begin{align}
  \begin{aligned}[t]
\lambda \gamma \beta \alpha:*.\,\lambda g: \beta \to \gamma\  f:\alpha\to\beta\ x:\alpha.\ g(f a)\ :\\
\Pi\gamma\beta\alpha:*.(\beta\to\gamma)\to(\alpha\to\beta)\to\alpha\to\gamma
  \end{aligned}\tag{\(\blacklozenge\)}\label{ex:typing_compar}
\end{align}

Rezultatem kompilacja powyższego programu za pomocą kompilatora \texttt{ghc} z dodatkowym argumentem \texttt{-ddump-simpl} jest następujący kod pośredni:

\begin{minted}{haskell}
comp
  :: forall t_aqz t1_aqB t2_aqD.
     (t_aqz -> t1_aqB) -> (t2_aqD -> t_aqz) -> t2_aqD -> t1_aqB
comp =
  \ (@ t_aqz)
    (@ t1_aqB)
    (@ t2_aqD)
    (g_aqg :: t_aqz -> t1_aqB)
    (f_aqh :: t2_aqD -> t_aqz)
    (x_aqi :: t2_aqD) ->
    g_aqg (f_aqh x_aqi)
\end{minted}

Pierwsza, druga i trzecia linia to rezultat przypisania typu. Symbolowi \texttt{forall} odpowiada symbol polimorficznej abstrakcji \(\Pi\). Dalej widzimy ciało funkcji \texttt{comp}: symbol \texttt{\textbackslash} odpowiada w nim \(\lambda\)-abstraktorowi, zaś symbol \texttt{@} wyróżnia zmienne typowe, które oznaczaliśmy symbolem \(\ast\). Widzimy, że (\ref{ex:typing_compar}) i powyższy kod to dokładnie to samo.

Haskell jest \emph{słabo} typowanym językiem: kod źródłowy może być zupełnie pozbawiony deklaracji typowych (chociaż nie musi), zaś kompilacja przebiega przez proces przypisywania wyrażeniom typu\footnote{Może to prowadzić do nieporozumień. Na przykład język C jest \emph{silnie} statycznie typowanym językiem, ale za typowanie odpowiada wyłącznie programista. Kod zostaje sprawdzony pod względem składni i kompilacja zaciera wszystkie deklaracje typowe.}. Pod tym względem przypomina systemy w stylu Currego. Przypomnijmy jednak, że w Systemie F w tym stylu problem typowania jest nierozstrzygalny \cite{Wells_98}. Rewolucyjne okazuje się dopuszczenie myśli, że język pośredni może dysponować szerszą ekspresją niż język źródłowy. Wówczas dysponując tylko kompilatorem języka pośredniego (np. z wariantu Systemu F do kodu maszynowego), możemy zająć się tłumaczeniem być może uboższego (ale rozstrzygalnego) języka źródłowego na język pośredni. Pozwala to też na swobodne eksperymentowanie z językami źródłowymi, mając jednocześnie pewność, że praca nigdy nie podda się próbie czasu i nie przyćmią jej w przyszłości być może bardziej ekspresywne systemy typów.


\subsection{Podsumowanie}
System F, który był przedmiotem Rozdziału \ref{sec:system_f} można umieścić na kanwie zaproponowanej przez H. P. Barendregta w \cite[Rozdział 5]{Barendregt_1992} klasyfikacji rozszerzeń rachunku \(\lambda\) z typami prostymi (tzw. \emph{kostki \(\lambda\)}, Rysunek \ref{fig:lambda-cube}) w miejscu systemu \(\lambda 2\). 

Wszystkie części kostki \(\lambda\) są systemami w stylu Churcha. System \(\lambda{\to}\) to omawiany przez nas w Rozdziale \ref{sec:simple_types} rachunek \(\lambda\) z typami prostymi. Jak widzieliśmy, rozszerzenie go o typy polimorficzne prowadzi do systemu \(\lambda 2\). 

\begin{figure}
  \centering
  \begin{tikzpicture}
  \matrix (m) [matrix of math nodes,
  row sep=3em, column sep=3em,
  text height=1.5ex,
  text depth=0.25ex]{
              & \lambda\omega             &              & \lambda P \omega             \\
  \lambda 2   &                           & \lambda P 2                                \\
              & \lambda\underline{\omega} &              & \lambda P \underline{\omega} \\
  \lambda{\to}&                           & \lambda P  \\
  };
  \path[-{Latex[length=2.5mm, width=1.5mm]}]
  (m-1-2) edge (m-1-4)
  (m-2-1) edge (m-2-3)
          edge (m-1-2)
  (m-3-2) edge (m-1-2)
          edge (m-3-4)
  (m-4-1) edge (m-2-1)
          edge (m-3-2)
          edge (m-4-3)
  (m-3-4) edge (m-1-4)
  (m-2-3) edge (m-1-4)
  (m-4-3) edge (m-3-4)
          edge (m-2-3);
  \end{tikzpicture}
  \caption{Poszczególne systemy klasyfikacji H. Barendregta; kierunek krawędzi \(\to\)  oznacza relację \(\subseteq\).}\label{fig:lambda-cube}
\end{figure}

System    \(\lambda{\underline{\omega}}\)   to    rozszerzenie,   w
którym   sama   struktura   typów    jest   podobna   do   typów
prostych:   typy   zależą   w  nim   od   typów.   Zaobserwujmy,
że   typy   takie  jak   \(\beta\to\beta\),   \(\gamma\to\gamma\),
\((\beta\to\gamma)\to(\beta\to\gamma)\)   itp.    wszystkie   mają
tę  samą strukturę  postaci   \(\Diamond\to  \Diamond\),  gdzie
\(\Diamond\)  jest tym  samym typem  wystepującym po  obu stronach
\(\to\). Wprowadzając  operator abstrakcji  względem \(\Diamond\)
możemy w  ramach systemu  \(\lambda{\underline{\omega}}\) wyrazić
\emph{rodziny typów}:
\[
  \lambda \alpha: \alpha\to\alpha.
\]
Wyrażenia takie nazywamy \emph{konstruktorami typu}: po zaaplikowaniu do nich typu uzyskujemy znowu typ.
\begin{przyklad}
  Rozważmy następujące redukcje:
  \begin{align*}
    (\lambda \alpha : *.\ \alpha\to\alpha)\beta &\quad\to_\beta\quad \beta\to\beta,\\  
    (\lambda \alpha : *.\ \alpha\to\alpha)\gamma &\quad\to_\beta\quad \gamma\to\gamma,\\
    (\lambda \alpha : *.\ \alpha\to\alpha)(\beta\to\gamma) &\quad\to_\beta\quad (\beta\to\gamma)\to(\beta\to\gamma).
  \end{align*}
\end{przyklad}

Typy konstruktorów typów nazywamy \emph{gatunkami} (ang. \emph{kind}). Zbiór wszystkich gatunków oznaczamy symbolem \(\square\). Mają one następującą postać:
  \begin{align*}
    \square\ &\leftarrow\ \ast |\ (\square\to\square)
  \end{align*}
Mamy   więc    \(\ast:\square\),   \(\ast\to\ast    :   \square\),
\((\ast\to\ast)\to\ast\to\ast\)  itp.   Termy,  które   mają  typ
\(\ast\)  nazywamy   wówczas  \emph{konstruktorami  właściwymi}.
Łącznie, symbole \(\ast\)  i \(\square\) nazywamy \emph{rodzajami}
(ang. \emph{sort}).

System \(\lambda P\) rozszerza typy proste o abstrakcję umożliwiającą uzależnienie typów od termów. Typy takie mają postać \(\lambda x:A.\,M\), gdzie \(M\) jest typem, a \(x\) zmienną typową. 

Jak zauważył Barendregt, rozszerzenia \(\lambda 2\), \(\lambda{\underline{\omega}}\) i \(\lambda P\) są od siebie w pewnym sensie niezależne i można je ze sobą składać. Intuicję tę można sformalizować  w ten sposób, aby wybierając tylko odpowiednią kombinację zależności, otrzymać odpowiadającą jej teorię \cite{barendregt_1991}. Ponieważ przybliżenie tego uogólnionego systemu wykracza poza zamierzony zakres tej pracy, prezentujemy tylko zestawienie systemów kostki \(\lambda\).

  \begin{center}
  \begin{tabular}{r | l | c c c c}
    0 & \(\lambda_{\to}\)                 & \((*,\,*)\) \\
    1 & \(\lambda 2\)                     & \((*,\,*)\) & \((\Box,\,*)\) \\
    2 & \(\lambda P\)                     & \((*,\,*)\) & & \((*,\,\Box)\) \\
    1+2 & \(\lambda P2\)                  & \((*,\,*)\) & \((\Box,\,*)\) & \((*,\,\Box)\) \\
    3 & \(\lambda \underline{\omega}\)    & \((*,\,*)\) & & & \((\Box,\,\Box)\)\\
    1+3 & \(\lambda \omega\)              & \((*,\,*)\) & \((\Box,\,*)\) & & \((\Box,\,\Box)\)\\
    2+3 & \(\lambda P\underline{\omega}\) & \((*,\,*)\) & & \((*,\,\Box)\) & \((\Box,\,\Box)\) \\
    1+2+3 & \(\lambda C\)                 & \((*,\,*)\) & \((\Box,\,*)\) & \((*,\,\Box)\) & \((\Box,\,\Box)\) \\
  \end{tabular}

  \begin{itemize}
    \item \((*,*)\) - termy zależne od termów (typy funkcyjne),
    \item \((\Box,*)\) - termy zalezne od typów (typy polimorficzne),
    \item \((*,\Box)\) - typy zależne od termów (typy zależne),
    \item \((\Box, \Box)\) - typy zależne od typów (rodziny typów, higher-kinded types).
  \end{itemize}
  \end{center}

